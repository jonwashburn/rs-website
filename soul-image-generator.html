<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soul Image Generator - Recognition Science</title>
    <link rel="stylesheet" href="/style.css">
    <style>
        body {
            background: #f5f5f7;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2em;
        }
        
        h1 {
            font-family: 'VT323', monospace;
            font-size: 2.5em;
            margin-bottom: 1em;
        }
        
        #generateBtn {
            background: #007AFF;
            color: white;
            border: none;
            padding: 1em 2em;
            font-size: 1.2em;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            margin-bottom: 2em;
            transition: all 0.2s ease;
        }
        
        #generateBtn:hover {
            background: #0056CC;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 122, 255, 0.3);
        }
        
        #soulCanvas {
            border: 2px solid #000;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            background: #fff;
        }
        
        #downloadLink {
            margin-top: 1em;
            color: #007AFF;
            text-decoration: none;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <h1>ðŸŒŸ Soul Image Generator</h1>
    <button id="generateBtn">Generate New Soul Image</button>
    <canvas id="soulCanvas" width="1024" height="1024"></canvas>
    <a id="downloadLink" href="#" download="soul-image.png">Download Image</a>
    
    <script>
        // Constants
        const CANVAS_SIZE = 1024;
        const PHI = 1.618033988749;
        const VIRTUES = [
            'Love', 'Justice', 'Forgiveness', 'Wisdom', 'Courage', 'Temperance', 'Prudence',
            'Compassion', 'Gratitude', 'Patience', 'Humility', 'Hope', 'Creativity', 'Sacrifice'
        ];
        
        // Professional Color Palettes (Mapan-inspired)
        const SOUL_PALETTES = [
            { name: 'Fire Spirit', base: '#D32F2F', accent: '#1976D2', warm: '#F57C00', complement: '#FFD700' },
            { name: 'Mystic Depth', base: '#7B1FA2', accent: '#388E3C', warm: '#FBC02D', complement: '#FF5722' },
            { name: 'Ocean Soul', base: '#303F9F', accent: '#F57C00', warm: '#C2185B', complement: '#4CAF50' },
            { name: 'Earth Wisdom', base: '#5D4037', accent: '#FF9800', warm: '#2196F3', complement: '#8BC34A' },
            { name: 'Solar Harmony', base: '#FF8F00', accent: '#3F51B5', warm: '#E91E63', complement: '#00BCD4' }
        ];
        
        // Golden Ratio based composition points
        function getCompositionPoints() {
            const phi = PHI;
            return {
                focal1: { x: CANVAS_SIZE / phi, y: CANVAS_SIZE / phi },
                focal2: { x: CANVAS_SIZE - (CANVAS_SIZE / phi), y: CANVAS_SIZE - (CANVAS_SIZE / phi) },
                center: { x: CANVAS_SIZE / 2, y: CANVAS_SIZE / 2 },
                thirds: [
                    { x: CANVAS_SIZE / 3, y: CANVAS_SIZE / 3 },
                    { x: (2 * CANVAS_SIZE) / 3, y: CANVAS_SIZE / 3 },
                    { x: CANVAS_SIZE / 3, y: (2 * CANVAS_SIZE) / 3 },
                    { x: (2 * CANVAS_SIZE) / 3, y: (2 * CANVAS_SIZE) / 3 }
                ]
            };
        }
        
        // Convert hex to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }
        
        // Create intentional brush strokes instead of random noise
        function createBrushStroke(ctx, startX, startY, endX, endY, color, alpha, thickness) {
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.strokeStyle = color;
            ctx.lineWidth = thickness;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            
            // Add subtle curve for organic feel
            const midX = (startX + endX) / 2 + (Math.random() - 0.5) * 20;
            const midY = (startY + endY) / 2 + (Math.random() - 0.5) * 20;
            ctx.quadraticCurveTo(midX, midY, endX, endY);
            ctx.stroke();
            ctx.restore();
        }
        
        // Apply virtue influences architecturally
        function calculateVirtueInfluences(virtueScores) {
            return {
                justice: { symmetry: virtueScores[1], balance: virtueScores[1] },
                love: { warmth: virtueScores[0], glow: virtueScores[0] * 0.3 },
                wisdom: { complexity: virtueScores[3] * 0.7, depth: virtueScores[3] },
                courage: { boldness: virtueScores[4], extension: virtueScores[4] * 0.5 },
                temperance: { harmony: virtueScores[5], restraint: virtueScores[5] },
                creativity: { variation: virtueScores[12] * 0.6, novelty: virtueScores[12] },
                hope: { upwardFlow: virtueScores[11], lightness: virtueScores[11] * 0.4 },
                humility: { subtlety: virtueScores[10], interconnection: virtueScores[10] }
            };
        }
        
        function generateSoulImage() {
            const canvas = document.getElementById('soulCanvas');
            const ctx = canvas.getContext('2d');
            
            // Clear canvas
            ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            
            // Generate parameters
            const delta = (Math.random() * 8 - 4);
            const virtueScores = VIRTUES.map(() => Math.random());
            const influences = calculateVirtueInfluences(virtueScores);
            const palette = SOUL_PALETTES[Math.floor(Math.random() * SOUL_PALETTES.length)];
            const composition = getCompositionPoints();
            
            // 1. SOLID COLOR FOUNDATION (like Mapan)
            ctx.fillStyle = palette.base;
            ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            
            // 2. GEOMETRIC SCAFFOLDING
            const baseRgb = hexToRgb(palette.accent);
            const accentColor = `rgba(${baseRgb.r}, ${baseRgb.g}, ${baseRgb.b}, 0.7)`;
            
            // Create diagonal structure inspired by Mapan's geometric foundation
            if (influences.justice.symmetry > 0.3) {
                const stripeCount = 3 + Math.floor(influences.wisdom.complexity * 5);
                const angle = (delta * 0.1) + (Math.PI / 4); // Diagonal bias with delta influence
                
                for (let i = 0; i < stripeCount; i++) {
                    const progress = i / stripeCount;
                    const width = 20 + influences.courage.boldness * 80;
                    const spacing = CANVAS_SIZE / stripeCount;
                    
                    ctx.save();
                    ctx.translate(CANVAS_SIZE / 2, CANVAS_SIZE / 2);
                    ctx.rotate(angle);
                    
                    const warmRgb = hexToRgb(palette.warm);
                    const alpha = 0.3 + influences.temperance.harmony * 0.4;
                    ctx.fillStyle = `rgba(${warmRgb.r}, ${warmRgb.g}, ${warmRgb.b}, ${alpha})`;
                    
                    const x = -CANVAS_SIZE + (i * spacing);
                    ctx.fillRect(x, -CANVAS_SIZE, width, CANVAS_SIZE * 2);
                    ctx.restore();
                }
            }
            
            // 3. FOCAL ARROW/DIRECTIONAL ELEMENT (Mapan signature)
            if (influences.hope.upwardFlow > 0.4) {
                const focal = composition.focal1;
                const arrowSize = 100 + influences.courage.boldness * 150;
                
                ctx.fillStyle = palette.complement;
                ctx.globalAlpha = 0.8;
                ctx.beginPath();
                ctx.moveTo(focal.x - arrowSize/2, focal.y + arrowSize/4);
                ctx.lineTo(focal.x + arrowSize/2, focal.y + arrowSize/4);
                ctx.lineTo(focal.x + arrowSize/4, focal.y - arrowSize/4);
                ctx.lineTo(focal.x, focal.y - arrowSize/2);
                ctx.lineTo(focal.x - arrowSize/4, focal.y - arrowSize/4);
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 1;
            }
            
            // 4. INTENTIONAL SOUL SQUIGGLES (controlled spontaneity)
            const eigenvaluePoints = [];
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + delta * 0.1;
                const radius = 150 + influences.courage.extension * 200;
                const point = {
                    x: composition.center.x + Math.cos(angle) * radius,
                    y: composition.center.y + Math.sin(angle) * radius
                };
                eigenvaluePoints.push(point);
                
                // Draw controlled squiggle from center to eigenvalue point
                ctx.save();
                ctx.strokeStyle = palette.accent;
                ctx.lineWidth = 2 + influences.wisdom.depth * 4;
                ctx.globalAlpha = 0.6 + influences.love.glow * 0.3;
                ctx.shadowBlur = 15 * influences.love.warmth;
                ctx.shadowColor = palette.warm;
                
                ctx.beginPath();
                ctx.moveTo(composition.center.x, composition.center.y);
                
                // Controlled curve with virtue influence
                const segments = 2 + Math.floor(influences.creativity.variation * 3);
                let currentX = composition.center.x;
                let currentY = composition.center.y;
                
                for (let s = 1; s <= segments; s++) {
                    const progress = s / segments;
                    const targetX = currentX + (point.x - currentX) * (1 / (segments - s + 1));
                    const targetY = currentY + (point.y - currentY) * (1 / (segments - s + 1));
                    
                    // Add controlled deviation based on virtues
                    const deviation = 50 * influences.creativity.novelty * (1 - influences.temperance.restraint);
                    const controlX = targetX + (Math.random() - 0.5) * deviation;
                    const controlY = targetY + (Math.random() - 0.5) * deviation;
                    
                    ctx.quadraticCurveTo(controlX, controlY, targetX, targetY);
                    currentX = targetX;
                    currentY = targetY;
                }
                
                ctx.stroke();
                ctx.restore();
            }
            
            // 5. SUBTLE TEXTURAL ELEMENTS
            if (influences.humility.subtlety > 0.3) {
                const brushStrokes = Math.floor(influences.creativity.variation * 20 + 5);
                for (let i = 0; i < brushStrokes; i++) {
                    const start = composition.thirds[i % 4];
                    const length = 50 + influences.wisdom.depth * 100;
                    const angle = Math.random() * Math.PI * 2;
                    const end = {
                        x: start.x + Math.cos(angle) * length,
                        y: start.y + Math.sin(angle) * length
                    };
                    
                    createBrushStroke(
                        ctx, start.x, start.y, end.x, end.y,
                        palette.warm, 
                        0.1 + influences.humility.interconnection * 0.2,
                        1 + influences.courage.boldness * 3
                    );
                }
            }
            
            // 6. LIGHT EMERGENCE POINTS (virtue-driven shines)
            const highVirtues = virtueScores
                .map((score, i) => ({ virtue: VIRTUES[i], score, index: i }))
                .filter(v => v.score > 0.7)
                .slice(0, 3); // Top 3 virtues only
            
            highVirtues.forEach((v, i) => {
                const shine = eigenvaluePoints[v.index % 8];
                const shineRadius = 30 + v.score * 70;
                
                const gradient = ctx.createRadialGradient(shine.x, shine.y, 0, shine.x, shine.y, shineRadius);
                const complementRgb = hexToRgb(palette.complement);
                gradient.addColorStop(0, `rgba(${complementRgb.r}, ${complementRgb.g}, ${complementRgb.b}, ${v.score * 0.6})`);
                gradient.addColorStop(1, `rgba(${complementRgb.r}, ${complementRgb.g}, ${complementRgb.b}, 0)`);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(shine.x, shine.y, shineRadius, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Update download link
            const downloadLink = document.getElementById('downloadLink');
            downloadLink.href = canvas.toDataURL('image/png');
            
            console.log(`Generated soul with palette: ${palette.name}, Î´=${delta.toFixed(2)}`);
        }
        
        // Event listeners
        document.getElementById('generateBtn').addEventListener('click', generateSoulImage);
        
        // Initial generation
        generateSoulImage();
    </script>
</body>
</html> 