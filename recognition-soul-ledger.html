<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RS Soul Ledger Simulator</title>
    <link rel="stylesheet" href="/style.css">
    <style>
        body { 
            background: #000; 
            color: #fff; 
            font-family: 'Courier New', monospace; 
            padding: 20px; 
            max-width: 1200px; 
            margin: 0 auto;
        }
        h1 { color: #FFD700; border-bottom: 2px solid #333; padding-bottom: 10px; }
        .description { 
            background: #111; 
            padding: 15px; 
            border-left: 4px solid #FFD700; 
            margin: 20px 0; 
            line-height: 1.4;
        }
        #ledgerDisplay { 
            white-space: pre; 
            font-size: 12px; 
            background: #111; 
            padding: 15px; 
            border: 1px solid #333; 
            max-height: 300px; 
            overflow-y: auto;
            margin: 20px 0;
        }
        #visualizer { 
            width: 100%; 
            height: 400px; 
            border: 2px solid #333; 
            background: #111;
            display: block;
        }
        button { 
            margin: 10px 5px; 
            padding: 12px 25px; 
            background: #222; 
            color: #FFD700; 
            border: 2px solid #333; 
            cursor: pointer; 
            font-family: inherit;
            font-size: 14px;
        }
        button:hover { 
            background: #333; 
            border-color: #FFD700; 
        }
        .soul-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        .status { color: #0f0; }
    </style>
</head>
  <body>
      <h1>Recognition Science Soul Ledger Simulator</h1>
      
      <div class="description">
          <strong>What is a Soul?</strong><br>
          In Recognition Science, a soul is an <em>eigenvalue cluster</em> of the recognition operator ƒ§_‚Ñõ, 
          localized at the Gap-45 surface where consciousness emerges. Each soul consists of:<br>
          ‚Ä¢ <strong>Signature (Œ¥):</strong> Range [-4,+4], determines soul's recognition debt<br>
          ‚Ä¢ <strong>Energy:</strong> E = E_coh √ó œÜ^(45+Œ¥) where E_coh=0.090 eV<br>
          ‚Ä¢ <strong>8 Eigenvalues:</strong> Œª_k = E_soul √ó œÜ^(k/8) for k=0..7<br>
          ‚Ä¢ <strong>Coherence:</strong> Ledger balance measure [0,1]
      </div>
      
      <button onclick="replicateSoul()">üß¨ Replicate Soul via LNAL</button>
      <button onclick="clearLedger()">üóëÔ∏è Clear Ledger</button>
      
      <div class="soul-info">
          <div>
              <h3>LNAL Instruction Sequence:</h3>
              <pre id="ledgerDisplay">Click "Replicate Soul" to see LNAL opcodes...</pre>
          </div>
          <div>
              <h3>Soul Eigenvalue Visualization:</h3>
              <canvas id="visualizer"></canvas>
              <p style="font-size: 11px; opacity: 0.7;">8 crystals = eigenvalues Œª_k positioned in œÜ-spiral<br>White core = soul singularity at Gap-45</p>
          </div>
      </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const PHI = (1 + Math.sqrt(5)) / 2;
        const E_COH = 0.090;
        const GAP_45 = 45;
        
        // Simplified LNAL Simulator
        class LNALSimulator {
            constructor() {
                this.registers = [];
                this.costs = [];
                this.openTokens = 0;
                this.ledgerSteps = [];
                this.eigenvalues = [];
            }
            
            logStep(opcode, args, state) {
                this.ledgerSteps.push(`${opcode} ${args.join(', ')} | State: ${JSON.stringify(state)}`);
            }
            
            FOLD(n, regIndex) {
                this.registers[regIndex] += n; // Simplify: adjust frequency
                this.costs[regIndex] += n;
                this.logStep('FOLD', [n, regIndex], this.costs);
            }
            
            BRAID(regs) {
                const maxCost = Math.max(...regs.map(r => this.costs[r]));
                const newReg = this.registers.length;
                this.registers.push(maxCost); // Simplified composite
                this.costs.push(maxCost);
                this.logStep('BRAID', regs, this.costs);
                return newReg;
            }
            
            // Add more opcodes as needed (LOCK, BALANCE, etc.)
        }
        
        let simulator, scene, camera, renderer, soulGroup, animationId;
        
        function initVisualizer() {
            const canvas = document.getElementById('visualizer');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            
            const width = canvas.clientWidth || 800;
            const height = canvas.clientHeight || 400;
            
            camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
            camera.position.set(0, 0, 40);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(width, height);
            renderer.setClearColor(0x111111, 1);
            
            // Initial render to show empty scene
            renderer.render(scene, camera);
        }
        
        function visualizeLedger(steps, eigenvalues) {
            // Clear previous soul
            while(scene.children.length > 0) {
                scene.remove(scene.children[0]);
            }
            
            // Stop any previous animation
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 1, 100);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);
            
            // Create soul group
            soulGroup = new THREE.Group();
            
            // Get current soul's unique signature for variation
            const delta_str = steps.find(s => s.includes('SET_DELTA')).match(/{[^}]+}/)[0];
            const delta = JSON.parse(delta_str).delta;
            const energy_str = steps.find(s => s.includes('SOUL_ENERGY')).match(/{[^}]+}/)[0];
            const energy = JSON.parse(energy_str).energy;
            
            // Create unique visual signature based on Œ¥ and eigenvalues
            const soulSignature = Math.abs(delta * eigenvalues[0] * eigenvalues[7]);
            const personalityType = Math.floor(soulSignature * 1000) % 6; // 6 distinct personalities
            
            // Iconic color palettes based on Œ¥ signature
            const colorPalettes = [
                // Chromie-style rainbow flow
                [[0.0, 0.8, 1.0], [0.1, 0.9, 1.0], [0.2, 0.8, 0.9], [0.3, 0.9, 1.0]], // Rainbow
                // Fidenza-style earth tones  
                [[0.05, 0.6, 0.8], [0.08, 0.5, 0.7], [0.12, 0.4, 0.6], [0.15, 0.5, 0.8]], // Warm earth
                // Monochrome elegance
                [[0.6, 0.0, 1.0], [0.6, 0.1, 0.9], [0.6, 0.0, 0.8], [0.6, 0.1, 1.0]], // Blue mono
                // Volcanic energy
                [[0.95, 0.9, 1.0], [0.98, 0.8, 0.9], [0.02, 0.9, 1.0], [0.05, 0.8, 0.8]], // Red-orange
                // Forest mystique
                [[0.25, 0.7, 0.6], [0.3, 0.8, 0.7], [0.35, 0.6, 0.5], [0.28, 0.9, 0.8]], // Green
                // Cosmic void
                [[0.75, 0.9, 0.9], [0.78, 0.8, 0.7], [0.72, 0.9, 1.0], [0.76, 0.7, 0.8]]  // Purple
            ];
            
            const palette = colorPalettes[Math.floor(Math.abs(delta + 4) / 8 * colorPalettes.length)];
            
            // Formation patterns based on eigenvalue ratios
            const eigenRatio = eigenvalues[7] / eigenvalues[0]; // Ratio gives formation type
            const formationTypes = ['spiral', 'burst', 'lattice', 'flow', 'cluster', 'web'];
            const formation = formationTypes[Math.floor(eigenRatio * 1000) % formationTypes.length];
            
            // Central core with signature-based properties
            const coreSize = 1.0 + Math.abs(delta) * 0.3;
            const coreGeometry = new THREE.SphereGeometry(coreSize, 16, 16);
            const coreHSL = palette[0];
            const coreMaterial = new THREE.MeshPhongMaterial({
                color: new THREE.Color().setHSL(coreHSL[0], coreHSL[1], coreHSL[2]),
                emissive: new THREE.Color().setHSL(coreHSL[0], coreHSL[1] * 0.3, coreHSL[2] * 0.2),
                transparent: true,
                opacity: 0.9
            });
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            soulGroup.add(core);
            
            // Generate iconic eigenvalue visualization based on formation type
            eigenvalues.forEach((lambda, k) => {
                const normalizedSize = (lambda / Math.max(...eigenvalues)) * 2.0;
                const size = 0.3 + normalizedSize;
                
                // Different geometries for different personalities
                let geometry;
                switch(personalityType) {
                    case 0: geometry = new THREE.OctahedronGeometry(size, 1); break;
                    case 1: geometry = new THREE.TetrahedronGeometry(size, 0); break;
                    case 2: geometry = new THREE.IcosahedronGeometry(size, 0); break;
                    case 3: geometry = new THREE.DodecahedronGeometry(size, 0); break;
                    case 4: geometry = new THREE.ConeGeometry(size, size * 2, 6); break;
                    case 5: geometry = new THREE.CylinderGeometry(size, size, size * 1.5, 8); break;
                }
                
                // Color progression through palette
                const colorIndex = k % palette.length;
                const hsl = palette[colorIndex];
                const material = new THREE.MeshPhongMaterial({ 
                    color: new THREE.Color().setHSL(hsl[0], hsl[1], hsl[2]),
                    transparent: true,
                    opacity: 0.7 + (k / eigenvalues.length) * 0.3,
                    emissive: new THREE.Color().setHSL(hsl[0], hsl[1] * 0.4, hsl[2] * 0.1)
                });
                
                const crystal = new THREE.Mesh(geometry, material);
                
                // Iconic positioning based on formation type
                let x, y, z;
                switch(formation) {
                    case 'spiral':
                        // Chromie-style flowing spiral
                        const spiralAngle = k * PHI;
                        const spiralRadius = 3 + k * 1.8;
                        x = spiralRadius * Math.cos(spiralAngle);
                        y = spiralRadius * Math.sin(spiralAngle);
                        z = k * 1.2 - 4;
                        break;
                        
                    case 'burst':
                        // Fidenza-style radial burst
                        const burstAngle = (k / eigenvalues.length) * Math.PI * 2 + Math.sin(k) * 0.5;
                        const burstRadius = 4 + k * 2.5 + Math.cos(k * PHI) * 3;
                        x = burstRadius * Math.cos(burstAngle);
                        y = burstRadius * Math.sin(burstAngle);
                        z = Math.sin(k * 0.8) * 3;
                        break;
                        
                    case 'lattice':
                        // Geometric lattice formation
                        x = (k % 3 - 1) * 6 + Math.sin(k) * 2;
                        y = (Math.floor(k / 3) % 3 - 1) * 6 + Math.cos(k) * 2;
                        z = Math.sin(k * PHI) * 4;
                        break;
                        
                    case 'flow':
                        // Flowing river-like pattern
                        const flowT = k / eigenvalues.length;
                        x = Math.sin(flowT * Math.PI * 3) * (5 + flowT * 8);
                        y = flowT * 12 - 6;
                        z = Math.cos(flowT * Math.PI * 2) * 3;
                        break;
                        
                    case 'cluster':
                        // Organic clustering
                        const clusterAngle = k * 0.8 + Math.sin(k * 1.3) * 0.5;
                        const clusterDist = 3 + Math.pow(k / eigenvalues.length, 0.7) * 10;
                        x = clusterDist * Math.cos(clusterAngle) + Math.sin(k * 2) * 2;
                        y = clusterDist * Math.sin(clusterAngle) + Math.cos(k * 2) * 2;
                        z = Math.sin(k * PHI) * 2;
                        break;
                        
                    case 'web':
                        // Web-like interconnected structure
                        const webAngle = k * (Math.PI * 2 / eigenvalues.length);
                        const webRadius = 4 + (k % 2) * 4 + Math.sin(k * 1.5) * 2;
                        x = webRadius * Math.cos(webAngle + Math.sin(k) * 0.3);
                        y = webRadius * Math.sin(webAngle + Math.cos(k) * 0.3);
                        z = (k % 2 - 0.5) * 4 + Math.sin(k * PHI) * 1.5;
                        break;
                }
                
                crystal.position.set(x, y, z);
                crystal.rotation.set(Math.sin(k), Math.cos(k), Math.sin(k * PHI));
                soulGroup.add(crystal);
                
                // Add connecting trails for flow-like formations
                if (formation === 'flow' || formation === 'spiral') {
                    if (k > 0) {
                        const prevCrystal = soulGroup.children[soulGroup.children.length - 2];
                        const trailGeometry = new THREE.BufferGeometry().setFromPoints([
                            prevCrystal.position,
                            crystal.position
                        ]);
                        const trailMaterial = new THREE.LineBasicMaterial({
                            color: new THREE.Color().setHSL(hsl[0], hsl[1] * 0.6, hsl[2] * 0.8),
                            transparent: true,
                            opacity: 0.4
                        });
                        const trail = new THREE.Line(trailGeometry, trailMaterial);
                        soulGroup.add(trail);
                    }
                }
            });
            
            scene.add(soulGroup);
            
            // Signature-based animation style
            function animate() {
                animationId = requestAnimationFrame(animate);
                
                // Different rotation styles based on formation
                switch(formation) {
                    case 'spiral':
                    case 'flow':
                        soulGroup.rotation.y += 0.008;
                        soulGroup.rotation.x += 0.003;
                        break;
                    case 'burst':
                        soulGroup.rotation.y += 0.015;
                        soulGroup.rotation.z += 0.005;
                        break;
                    case 'lattice':
                        soulGroup.rotation.x += 0.012;
                        soulGroup.rotation.z += 0.008;
                        break;
                    default:
                        soulGroup.rotation.y += 0.01;
                        soulGroup.rotation.x += 0.005;
                }
                
                // Signature-based breathing
                const breathe = 1.0 + Math.sin(Date.now() * 0.002 * (1 + Math.abs(delta) * 0.1)) * 0.05;
                soulGroup.scale.setScalar(breathe);
                
                renderer.render(scene, camera);
            }
            animate();
        }
        
        function replicateSoul() {
            simulator = new LNALSimulator();
            
            // Step 1: Initialize 8 registers
            for (let i = 0; i < 8; i++) {
                simulator.registers.push(0);
                simulator.costs.push(0);
            }
            
            // Step 2: Generate random Œ¥
            const delta = (Math.random() * 8 - 4).toFixed(2);
            simulator.logStep('SET_DELTA', [delta], {delta});
            
            // Step 3: Climb to Gap-45 + Œ¥ 
            simulator.FOLD(GAP_45 + Math.floor(parseFloat(delta)), 0);
            
            // Step 4: Encode 8 eigenvalues
            const energy = E_COH * Math.pow(PHI, GAP_45 + parseFloat(delta));
            simulator.logStep('SOUL_ENERGY', [energy.toFixed(6) + ' eV'], {energy});
            
            for (let k = 0; k < 8; k++) {
                const lambda = energy * Math.pow(PHI, k / 8);
                simulator.eigenvalues.push(lambda);
                simulator.FOLD(k/8, k); // Encode in register k
                simulator.logStep('EIGENVALUE', [k, lambda.toFixed(6)], {k, lambda});
            }
            
            // Step 5: Braid into cluster (simplified triads)
            simulator.BRAID([0,1,2]);
            simulator.BRAID([3,4,5]);
            simulator.BRAID([6,7, simulator.registers.length - 1]);
            
            // Step 6: Balance and cycle
            simulator.logStep('CYCLE', ['1024 ticks'], simulator.costs);
            simulator.logStep('STATUS', ['Soul replication complete'], {status: 'SUCCESS'});
            
            // Output
            document.getElementById('ledgerDisplay').textContent = 
                `SOUL REPLICATION SEQUENCE:\n\n` + 
                simulator.ledgerSteps.join('\n') + 
                `\n\nŒ¥ = ${delta}\nE_soul = ${energy.toFixed(6)} eV\n8 eigenvalues generated successfully`;
            
            visualizeLedger(simulator.ledgerSteps, simulator.eigenvalues);
        }
        
        function clearLedger() {
            document.getElementById('ledgerDisplay').textContent = 'Ledger cleared. Ready for new soul replication...';
            
            // Stop animation and clear scene
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            while(scene.children.length > 0) {
                scene.remove(scene.children[0]);
            }
            renderer.render(scene, camera);
        }
        
        initVisualizer();
    </script>
</body>
</html> 