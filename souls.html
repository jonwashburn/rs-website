
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ledger Souls by Wubbushi</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');

        :root {
            --background-color: #000;
            --text-color: #fff;
            --text-secondary-color: #a0a0a0;
            --font-main: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        body {
            background-color: var(--background-color);
            color: var(--text-color);
            font-family: var(--font-main);
            margin: 0;
            padding: 0;
            overscroll-behavior-y: none;
        }

        .scroll-section {
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden;
            text-align: center;
            padding: 0 5vw;
        }

        .scroll-section .content {
            max-width: 800px;
            z-index: 2;
        }

        .scroll-section h1 {
            font-size: clamp(2.5rem, 6vw, 5rem);
            font-weight: 700;
            margin: 0 0 1rem;
            line-height: 1.1;
        }
        
        .scroll-section h2 {
            font-size: clamp(1.5rem, 4vw, 3rem);
            font-weight: 600;
            margin: 0 0 1rem;
            line-height: 1.2;
        }

        .scroll-section p {
            font-size: clamp(1rem, 1.5vw, 1.25rem);
            color: var(--text-secondary-color);
            line-height: 1.6;
            max-width: 600px;
            margin: 0 auto;
        }

        .background-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
            opacity: 0.3;
            transition: opacity 0.5s ease-in-out;
        }
        
        .scroll-section:hover .background-image {
            opacity: 0.4;
        }
        
        #hero {
            background-color: #000;
        }

        #hero .background-image {
             opacity: 0.5;
        }
        
        .final-answer {
             display: flex;
             flex-direction: column;
             justify-content: center;
             align-items: center;
        }

        #soul-simulation-container {
            margin-top: 2rem;
            width: 100%;
            max-width: 600px;
            height: 400px;
            background: #111;
            border-radius: 12px;
            border: 1px solid #333;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Courier New', Courier, monospace;
            color: #a0a0a0;
        }

    </style>
</head>
<body>

    <main>
        <section id="hero" class="scroll-section">
            <img src="assets/images/souls-header.jpeg" alt="Abstract representation of a soul" class="background-image">
            <div class="content">
                <h1>Ledger Souls</h1>
                <p>A new collection by Wubbushi, based on the physics of consciousness.</p>
            </div>
        </section>

        <section id="crisis" class="scroll-section">
            <img src="assets/images/crisis.png" alt="The Crisis artwork" class="background-image">
            <div class="content">
                <h2>The Prophecy, Part I: The Crisis</h2>
                <p>An artistic diagnosis of a world that has forgotten its own nature, mistaking the map for the territory.</p>
            </div>
        </section>

        <section id="zombies" class="scroll-section">
            <img src="assets/images/modern-zombies.jpeg" alt="Modern Zombies artwork" class="background-image">
            <div class="content">
                <h2>The Prophecy, Part II: Modern Zombies</h2>
                <p>An exploration of a society disconnected, moving without purpose, animated by external forces rather than internal light.</p>
            </div>
        </section>

        <section id="rapture" class="scroll-section">
            <img src="assets/images/rapture.jpeg" alt="The Rapture artwork" class="background-image">
            <div class="content">
                <h2>The Prophecy, Part III: The Rapture</h2>
                <p>A glimpse of the potential for reconnection, a return to authenticity, and the transcendence of the material.</p>
            </div>
        </section>

        <section id="answer" class="scroll-section final-answer">
            <div class="content">
                <h2>The Answer is Recognition</h2>
                <p>Not just art, but a proof. A living simulation of a soul, built on the first-principles framework of Recognition Science. Each one is a real, on-chain soul, evolving according to the laws of reality.</p>
                <div id="soul-simulation-container">
                    <!-- The soul simulation will be loaded here, but for now it's a placeholder -->
                    <p>Soul Simulation Placeholder</p>
                </div>
            </div>
        </section>

    </main>

    <script>
        class OnChainSoul {
            constructor(tokenId) {
                this.tokenId = tokenId || Math.floor(Math.random() * 10000);
                this.isEvolving = false;
                this.ticks = 0;
                
                // Seeded PRNG for deterministic randomness
                this.seed = this.xmur3(this.tokenId.toString());
                this.rand = this.sfc32(this.seed(), this.seed(), this.seed(), this.seed());

                this.initializeState();
            }

            initializeState() {
                this.kappa = this.randomInRange(-10, 10);
                this.energy = this.randomInRange(500, 900);
                this.maxEnergy = 1000;
                this.depth = this.randomInRange(10, 20);
                this.rebirths = 0;
                this.phase = "New Spirit";
                this.virtues = {
                    love: this.randomInRange(1, 8),
                    justice: this.randomInRange(1, 8),
                    courage: this.randomInRange(1, 8),
                    temperance: this.randomInRange(1, 8),
                    prudence: this.randomInRange(1, 8)
                };
                this.recognitionFlow = 0;
                this.karmaScore = 0;
                this.rarity = "Common";
                this.ticks = 0;
                this.months = 0;
            }

            // Core Evolution Loop
            advanceTick() {
                if (!this.isEvolving) return;

                this.ticks++;
                this.months = Math.floor(this.ticks / 10); // 10 ticks per month

                // Phase transitions
                if (this.months >= 96) {
                    this.phase = this.energy > 0 ? "Unified with IAM" : "Decohered";
                    this.isEvolving = false;
                } else if (this.months > 1) {
                    this.phase = "Embodied";
                }

                if (this.phase === "Unified with IAM" || this.phase === "Decohered") return;

                // Energy decay
                this.energy -= 0.5 + (this.virtues.courage / 10); // Courage burns energy
                if (this.energy <= 0) {
                    this.energy = 0;
                    this.phase = "Decohered";
                    this.isEvolving = false;
                    return;
                }

                // Kappa dynamics (ledger balance)
                let volatility = 1 + (this.virtues.courage / 5);
                let drift = (this.virtues.justice - 5) / 10;
                let change = (this.rand() - 0.5) * volatility - drift;
                this.kappa += change;

                // Virtue training
                this.virtues.love += (this.kappa < 0 ? 0.01 : -0.005) + (this.rand() - 0.5) * 0.02;
                this.virtues.justice += (Math.abs(change) > 0.5 ? 0.01 : -0.005) + (this.rand() - 0.5) * 0.02;
                this.virtues.courage += (this.energy < 300 ? 0.01 : -0.005) + (this.rand() - 0.5) * 0.02;
                this.virtues.temperance += (this.energy > 700 ? 0.01 : -0.005) + (this.rand() - 0.5) * 0.02;
                this.virtues.prudence += (this.ticks % 100 === 0 ? 0.05 : -0.005) + (this.rand() - 0.5) * 0.02;

                // Clamp virtues between 0 and 10
                for (let v in this.virtues) {
                    this.virtues[v] = Math.max(0, Math.min(10, this.virtues[v]));
                }
            }
            
            // Utility & Randomness
            xmur3(str) {
                for(var i = 0, h = 1779033703 ^ str.length; i < str.length; i++)
                    h = Math.imul(h ^ str.charCodeAt(i), 3432918353),
                    h = h << 13 | h >>> 19;
                return function() {
                    h = Math.imul(h ^ h >>> 16, 2246822507);
                    h = Math.imul(h ^ h >>> 13, 3266489909);
                    return (h ^= h >>> 16) >>> 0;
                }
            }

            sfc32(a, b, c, d) {
                return function() {
                  a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0; 
                  var t = (a + b) | 0;
                  a = b ^ b >>> 9;
                  b = c + (c << 3) | 0;
                  c = (c << 21 | c >>> 11);
                  d = d + 1 | 0;
                  t = t + d | 0;
                  c = c + t | 0;
                  return (t >>> 0) / 4294967296;
                }
            }
            
            randomInRange(min, max) {
                return this.rand() * (max - min) + min;
            }

            // Display Generation
            generateDisplay() {
                const coherence = Math.round((this.energy / this.maxEnergy) * 100);
                const curvatureType = this.kappa > 0 ? "Recognition Debt" : 
                                      this.kappa < 0 ? "Recognition Surplus" : "Equilibrium";
                
                let display = `
╔═══════════════════════════════════════════════════════════════╗
║ SOUL #${String(this.tokenId).padStart(4, '0')} [${this.isEvolving ? 'EVOLVING' : 'STASIS'}] MONTH: ${String(this.months).padStart(2, '0')}/96 ║
╠═══════════════════════════════════════════════════════════════╣
║                      LEDGER VITALS                           ║
╠═══════════════════════════════════════════════════════════════╣
║ Curvature κ:     ${this.kappa.toFixed(3).padStart(8)} (${curvatureType.padEnd(18)}) ║
║ Energy:          ${Math.floor(this.energy).toString().padStart(8)} / ${this.maxEnergy}                    ║
║ Coherence:       ${String(coherence).padStart(8)}% (Pattern Integrity)     ║
║ Depth:           ${this.depth.toFixed(2).padStart(8)} (Recognition Layers)    ║
║ Rebirths:        ${String(this.rebirths).padStart(8)} (Traumatic Resets)   ║
║ Phase:           ${this.phase.padEnd(18)}              ║
╠═══════════════════════════════════════════════════════════════╣
║                   VIRTUE TECHNOLOGIES                        ║
╠═══════════════════════════════════════════════════════════════╣`;

                Object.entries(this.virtues).forEach(([virtue, value]) => {
                    const bar = this.buildBar(value);
                    const name = virtue.charAt(0).toUpperCase() + virtue.slice(1);
                    display += `\n║ ${name.padEnd(12)}: ${bar} ${value.toFixed(1).padStart(4)} ║`;
                });

                display += `
╚═══════════════════════════════════════════════════════════════╝`;

                return display;
            }

            buildBar(value) {
                const maxBars = 10;
                const filledBars = Math.floor((value / 10) * maxBars);
                const emptyBars = maxBars - filledBars;
                return '█'.repeat(filledBars) + '░'.repeat(emptyBars);
            }
        }

        let currentSoul;
        let simulationInterval;
        const soulContainer = document.getElementById('soul-simulation-container');

        function updateDisplay() {
            if (currentSoul) {
                currentSoul.advanceTick();
                soulContainer.innerHTML = `<pre>${currentSoul.generateDisplay()}</pre>`;
            }
        }

        function initializeNewSoul(tokenId) {
            clearInterval(simulationInterval);
            currentSoul = new OnChainSoul(tokenId);
            soulContainer.innerHTML = `<pre>${currentSoul.generateDisplay()}</pre>`;
            const toggleButton = document.getElementById('simulation-toggle-button');
            if(toggleButton) toggleButton.textContent = "Simulate Life";
            currentSoul.isEvolving = false;
        }
        
        function setupControls() {
            const answerSection = document.getElementById('answer');
            const controls = document.createElement('div');
            controls.style.marginTop = '2rem';
            controls.innerHTML = `
                <button id="simulation-toggle-button" class="sim-button">Simulate Life</button>
                <button id="generate-soul-button" class="sim-button secondary">Generate New Soul</button>
                <style>
                    .sim-button {
                        display: inline-block;
                        background: #fff;
                        color: #000;
                        padding: 12px 24px;
                        text-decoration: none;
                        font-family: 'Inter', sans-serif;
                        font-weight: 600;
                        text-transform: uppercase;
                        letter-spacing: 0.5px;
                        border: 1px solid #fff;
                        border-radius: 8px;
                        cursor: pointer;
                        transition: all 0.2s;
                        margin: 0 10px;
                    }
                    .sim-button:hover {
                        background: #000;
                        color: #fff;
                    }
                     .sim-button.secondary {
                        background: transparent;
                        color: #fff;
                        border-color: #555;
                     }
                    .sim-button.secondary:hover {
                        background: #fff;
                        color: #000;
                        border-color: #fff;
                    }
                </style>
            `;
            answerSection.querySelector('.content').appendChild(controls);

            const toggleButton = document.getElementById('simulation-toggle-button');
            const generateButton = document.getElementById('generate-soul-button');

            toggleButton.addEventListener('click', (e) => {
                e.preventDefault();
                currentSoul.isEvolving = !currentSoul.isEvolving;
                if (currentSoul.isEvolving) {
                    toggleButton.textContent = "Pause Simulation";
                    simulationInterval = setInterval(updateDisplay, 100);
                } else {
                    toggleButton.textContent = "Simulate Life";
                    clearInterval(simulationInterval);
                }
            });

            generateButton.addEventListener('click', (e) => {
                e.preventDefault();
                initializeNewSoul();
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            initializeNewSoul(42);
            setupControls();
        });
    </script>

</body>
</html> 