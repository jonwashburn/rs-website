<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soul Grid V2 - Recognition Science Pixel Souls</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a0a, #1a1a2e);
            color: #e0e0e0;
            min-height: 100vh;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #ffd700;
            font-size: 2.5em;
            margin: 0;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .header p {
            color: #b0b0b0;
            font-size: 1.1em;
            margin: 10px 0;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }

        .main-container {
            display: flex;
            gap: 30px;
            max-width: 1400px;
            margin: 0 auto;
            flex-wrap: wrap;
        }

        .grid-container {
            flex: 1;
            min-width: 400px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #soulGrid {
            background: #000;
            border: 2px solid #333;
            border-radius: 8px;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.3);
        }

        .info-panel {
            flex: 1;
            min-width: 300px;
            background: rgba(20, 20, 40, 0.8);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 20px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .trait-section {
            margin-bottom: 25px;
            border-bottom: 1px solid #333;
            padding-bottom: 15px;
        }

        .trait-section h3 {
            color: #ffd700;
            margin: 0 0 15px 0;
            font-size: 1.2em;
        }

        .trait-item {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 0.9em;
        }

        .trait-label {
            color: #b0b0b0;
            flex: 1;
        }

        .trait-value {
            color: #fff;
            font-weight: bold;
            text-align: right;
        }

        .controls {
            text-align: center;
            margin-top: 20px;
        }

        .generate-btn {
            background: linear-gradient(45deg, #ffd700, #ffaa00);
            color: #000;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            font-size: 1.1em;
            transition: all 0.3s ease;
        }

        .generate-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .animation-status {
            color: #ff6b6b;
            font-weight: bold;
            text-align: center;
            margin: 10px 0;
        }

        .animation-status.animated {
            color: #4ecdc4;
        }

        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
            }
            .grid-container, .info-panel {
                min-width: unset;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Soul Grid V2</h1>
        <p>Recognition Science pixel souls inspired by Ed Manning's 1976 digital art, with flowing curves from Fidenza and connection patterns from Ringers. Each grid represents a complete soul vector with characteristics mapped to visual properties.</p>
    </div>

    <div class="main-container">
        <div class="grid-container">
            <canvas id="soulGrid" width="500" height="500"></canvas>
        </div>

        <div class="info-panel">
            <div class="animation-status" id="animationStatus">Static Soul</div>
            
            <div class="trait-section">
                <h3>Core Identity</h3>
                <div class="trait-item">
                    <span class="trait-label">Soul Hash:</span>
                    <span class="trait-value" id="soulHash">-</span>
                </div>
                <div class="trait-item">
                    <span class="trait-label">Grid Size:</span>
                    <span class="trait-value" id="gridSize">-</span>
                </div>
                <div class="trait-item">
                    <span class="trait-label">Rung Level:</span>
                    <span class="trait-value" id="rungLevel">-</span>
                </div>
                <div class="trait-item">
                    <span class="trait-label">Cost State:</span>
                    <span class="trait-value" id="costState">-</span>
                </div>
                <div class="trait-item">
                    <span class="trait-label">Beat Cycle:</span>
                    <span class="trait-value" id="beatCycle">-</span>
                </div>
            </div>

            <div class="trait-section">
                <h3>Visual Properties</h3>
                <div class="trait-item">
                    <span class="trait-label">Animation Type:</span>
                    <span class="trait-value" id="animationType">-</span>
                </div>
                <div class="trait-item">
                    <span class="trait-label">Connection Style:</span>
                    <span class="trait-value" id="connectionStyle">-</span>
                </div>
                <div class="trait-item">
                    <span class="trait-label">Flow Pattern:</span>
                    <span class="trait-value" id="flowPattern">-</span>
                </div>
                <div class="trait-item">
                    <span class="trait-label">Color Palette:</span>
                    <span class="trait-value" id="colorPalette">-</span>
                </div>
                <div class="trait-item">
                    <span class="trait-label">Texture Style:</span>
                    <span class="trait-value" id="textureStyle">-</span>
                </div>
            </div>

            <div class="trait-section">
                <h3>Virtues (Active)</h3>
                <div id="virtuesActive">-</div>
            </div>

            <div class="trait-section">
                <h3>Consciousness Metrics</h3>
                <div class="trait-item">
                    <span class="trait-label">Qualia Mode:</span>
                    <span class="trait-value" id="qualiaMode">-</span>
                </div>
                <div class="trait-item">
                    <span class="trait-label">Cluster Tightness:</span>
                    <span class="trait-value" id="clusterTightness">-</span>
                </div>
                <div class="trait-item">
                    <span class="trait-label">Resonance Freq:</span>
                    <span class="trait-value" id="resonanceFreq">-</span>
                </div>
                <div class="trait-item">
                    <span class="trait-label">I-Am Affinity:</span>
                    <span class="trait-value" id="iAmAffinity">-</span>
                </div>
            </div>

            <div class="controls">
                <button class="generate-btn" onclick="generateNewSoul()">Generate New Soul</button>
            </div>
        </div>
    </div>

    <script>
        // Recognition Science Constants
        const PHI = (1 + Math.sqrt(5)) / 2;
        const VIRTUE_NAMES = ['Balance', 'Flow', 'Seed', 'Echo', 'Fold', 'Braid', 'Listen', 'Regive'];
        
        // Animation state
        let currentSoul = null;
        let animationFrame = 0;
        let isAnimating = false;
        let canvas = null;
        let ctx = null;

        // Enhanced visual constants
        const GRID_SIZES = [4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 16];
        const CONNECTION_STYLES = ['Ringers', 'Web', 'Radial', 'Flow', 'Minimal'];
        const FLOW_PATTERNS = ['Fidenza', 'Organic', 'Geometric', 'Spiral', 'Linear'];
        const TEXTURE_STYLES = ['Smooth', 'Granular', 'Flowing', 'Blocky', 'Ethereal'];

        function simpleHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return Math.abs(hash);
        }

        function seedRandom(seed) {
            let x = Math.sin(seed) * 10000;
            return x - Math.floor(x);
        }

        function generateSoul() {
            const seed = Math.floor(Math.random() * 1000000);
            const hashNum = simpleHash(seed.toString());
            const hashHex = hashNum.toString(16).substr(0,8);
            
            // Core RS characteristics
            // Use numeric hash for seedRandom calculations to avoid NaN
            const rungLevel = Math.floor(seedRandom(hashNum + 1) * 45) + 1;
            const costState = Math.floor((seedRandom(hashNum + 2) - 0.5) * 200);
            const beatCycle = Math.floor(seedRandom(hashNum + 3) * 8) + 1;
            
            // Grid size based on consciousness complexity
            const gridComplexity = (rungLevel / 45) * 0.7 + (Math.abs(costState) / 100) * 0.3;
            const gridSizeIndex = Math.floor(gridComplexity * GRID_SIZES.length);
            const gridSize = GRID_SIZES[Math.min(gridSizeIndex, GRID_SIZES.length - 1)];
            
            // Visual properties
            const qualiaMode = Math.floor(seedRandom(hashNum + 4) * 8) + 1;
            const clusterTightness = seedRandom(hashNum + 5);
            const resonanceFreq = seedRandom(hashNum + 6);
            const iAmAffinity = seedRandom(hashNum + 7);
            
            // Enhanced properties inspired by Fidenza & Ringers
            const connectionStyle = CONNECTION_STYLES[Math.floor(seedRandom(hashNum + 8) * CONNECTION_STYLES.length)];
            const flowPattern = FLOW_PATTERNS[Math.floor(seedRandom(hashNum + 9) * FLOW_PATTERNS.length)];
            const textureStyle = TEXTURE_STYLES[Math.floor(seedRandom(hashNum + 10) * TEXTURE_STYLES.length)];
            
            // Rare animations (1 in 10 chance)
            const hasAnimation = seedRandom(hashNum + 11) < 0.2; // Slightly more frequent 1 in 5
            const animationType = hasAnimation ? 
                ['Pulse', 'Flow', 'Rotate', 'Breathe'][Math.floor(seedRandom(hashNum + 12) * 4)] : 
                'Static';
            
            // Generate balanced virtues
            const virtues = generateBalancedVirtues(hashNum);
            
            // Color palette based on qualia mode
            const palette = generateColorPalette(qualiaMode, resonanceFreq, hashNum);
            
            return {
                seed,
                hash: hashHex,
                hashNum,
                gridSize,
                rungLevel,
                costState,
                beatCycle,
                qualiaMode,
                clusterTightness,
                resonanceFreq,
                iAmAffinity,
                connectionStyle,
                flowPattern,
                textureStyle,
                hasAnimation,
                animationType,
                virtues,
                palette
            };
        }

        function generateBalancedVirtues(hash) {
            const virtues = {};
            let totalActive = 0;
            
            VIRTUE_NAMES.forEach((virtue, i) => {
                const strength = seedRandom(hash + 100 + i);
                const isActive = strength > 0.6; // 40% chance active
                virtues[virtue] = { active: isActive, strength };
                if (isActive) totalActive++;
            });
            
            // Ensure at least 2 virtues are active
            if (totalActive < 2) {
                const inactiveVirtues = VIRTUE_NAMES.filter(v => !virtues[v].active);
                const toActivate = inactiveVirtues.slice(0, 2 - totalActive);
                toActivate.forEach(v => virtues[v].active = true);
            }
            
            return virtues;
        }

        // Modern and varied color palettes
        const MODERN_PALETTES = [
            ['#ff595e','#ffca3a','#8ac926','#1982c4','#6a4c93'], // Vibrant hip
            ['#f72585','#b5179e','#7209b7','#3a0ca3','#4361ee','#4cc9f0'], // Vaporwave neon
            ['#06d6a0','#1b9aaa','#ef476f','#ffc43d'], // Modern flat
            ['#ff9f1c','#ffbf69','#ffffff','#cbf3f0','#2ec4b6'], // Miami pastel
            ['#e63946','#f1faee','#a8dadc','#457b9d','#1d3557'], // Modern desat
        ];

        function generateColorPalette(qualiaMode, resonanceFreq, hashNum) {
            const paletteTypeRand = seedRandom(hashNum + 201);
            let colors = [];

            if (paletteTypeRand < 0.2) {
                // Rainbow (full 360 hue wheel)
                const steps = Math.max(qualiaMode, 6);
                for (let i = 0; i < steps; i++) {
                    colors.push(`hsl(${i * 360 / steps}, 85%, 60%)`);
                }
            } else if (paletteTypeRand < 0.35) {
                // Monochromatic random hue
                const hue = Math.floor(seedRandom(hashNum + 202) * 360);
                for (let i = 0; i < qualiaMode; i++) {
                    const l = 30 + i * (40/qualiaMode);
                    colors.push(`hsl(${hue}, 70%, ${l}%)`);
                }
            } else if (paletteTypeRand < 0.5) {
                // Shades of gray / desaturated
                for (let i = 0; i < qualiaMode; i++) {
                    const g = 20 + i * (60/qualiaMode);
                    colors.push(`hsl(0, 0%, ${g}%)`);
                }
            } else if (paletteTypeRand < 0.8) {
                // Pick from hip modern palettes
                const modern = MODERN_PALETTES[Math.floor(seedRandom(hashNum + 203) * MODERN_PALETTES.length)];
                colors = modern.slice(0, qualiaMode);
            } else {
                // Ed Manning style: random mixed hues with varied saturation/lightness
                const baseHue = seedRandom(hashNum + 204) * 360;
                for (let i = 0; i < qualiaMode; i++) {
                    const hue = (baseHue + seedRandom(hashNum + 300 + i) * 120) % 360;
                    const sat = 40 + seedRandom(hashNum + 400 + i) * 60;
                    const light = 35 + seedRandom(hashNum + 500 + i) * 40;
                    colors.push(`hsl(${hue}, ${sat}%, ${light}%)`);
                }
            }

            return colors;
        }

        // Color parsing helpers
        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        function colorToRGB(color) {
            if (color.startsWith('#')) {
                let hex = color.slice(1);
                if (hex.length === 3) {
                    hex = hex.split('').map(c => c + c).join('');
                }
                return [
                    parseInt(hex.substr(0,2), 16),
                    parseInt(hex.substr(2,2), 16),
                    parseInt(hex.substr(4,2), 16)
                ];
            } else if (color.startsWith('hsl')) {
                const matches = color.match(/\d+/g);
                if (matches && matches.length >= 3) {
                    return hslToRgb(
                        parseInt(matches[0]) / 360,
                        parseInt(matches[1]) / 100,
                        parseInt(matches[2]) / 100
                    );
                }
            }
            return [0, 0, 0]; // fallback
        }

        function renderSoulGrid(soul) {
            if (!ctx) return;
            
            const canvasSize = 500;
            const margin = 50;
            const gridArea = canvasSize - (margin * 2);
            const cellSize = gridArea / soul.gridSize;
            
            // Clear canvas with subtle background
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvasSize, canvasSize);
            
            // Add subtle background texture
            renderBackgroundTexture(soul, canvasSize);
            
            // Render Ringers-inspired connections first (behind grid)
            renderConnections(soul, margin, cellSize);
            
            // Render main grid with Fidenza-inspired flowing elements
            renderGrid(soul, margin, cellSize);
            
            // Add Fidenza-inspired flowing overlays
            renderFlowingElements(soul, margin, gridArea);
        }

        function renderBackgroundTexture(soul, canvasSize) {
            const gradient = ctx.createRadialGradient(
                canvasSize/2, canvasSize/2, 0,
                canvasSize/2, canvasSize/2, canvasSize/2
            );
            
            const bgIntensity = soul.rungLevel / 45 * 0.3;
            const rgb = colorToRGB(soul.palette[0]);
            gradient.addColorStop(0, `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${bgIntensity})`);
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvasSize, canvasSize);
        }

        function renderConnections(soul, margin, cellSize) {
            if (soul.connectionStyle === 'Minimal') return;
            
            ctx.strokeStyle = soul.palette[0];
            ctx.globalAlpha = 0.3;
            ctx.lineWidth = 1;
            
            const centers = [];
            for (let row = 0; row < soul.gridSize; row++) {
                for (let col = 0; col < soul.gridSize; col++) {
                    centers.push({
                        x: margin + col * cellSize + cellSize/2,
                        y: margin + row * cellSize + cellSize/2
                    });
                }
            }
            
            switch (soul.connectionStyle) {
                case 'Ringers':
                    renderRingersConnections(centers, soul);
                    break;
                case 'Web':
                    renderWebConnections(centers, soul);
                    break;
                case 'Radial':
                    renderRadialConnections(centers, soul);
                    break;
                case 'Flow':
                    renderFlowConnections(centers, soul);
                    break;
            }
            
            ctx.globalAlpha = 1;
        }

        function renderRingersConnections(centers, soul) {
            // Inspired by Ringers - string wrapping patterns
            const step = Math.max(1, Math.floor(soul.gridSize / 3));
            for (let i = 0; i < centers.length; i += step) {
                const start = centers[i];
                const end = centers[(i + step * 2) % centers.length];
                
                ctx.beginPath();
                ctx.moveTo(start.x, start.y);
                
                // Create curved path like string tension
                const midX = (start.x + end.x) / 2 + (seedRandom(soul.hashNum + i) - 0.5) * 50;
                const midY = (start.y + end.y) / 2 + (seedRandom(soul.hashNum + i + 100) - 0.5) * 50;
                
                ctx.quadraticCurveTo(midX, midY, end.x, end.y);
                ctx.stroke();
            }
        }

        function renderWebConnections(centers, soul) {
            // Connect each point to nearby points
            centers.forEach((center, i) => {
                centers.slice(i + 1).forEach((other, j) => {
                    const dist = Math.sqrt((center.x - other.x)**2 + (center.y - other.y)**2);
                    if (dist < 80 * soul.clusterTightness) {
                        ctx.beginPath();
                        ctx.moveTo(center.x, center.y);
                        ctx.lineTo(other.x, other.y);
                        ctx.stroke();
                    }
                });
            });
        }

        function renderRadialConnections(centers, soul) {
            const centerPoint = centers[Math.floor(centers.length / 2)];
            centers.forEach(point => {
                if (point !== centerPoint) {
                    ctx.beginPath();
                    ctx.moveTo(centerPoint.x, centerPoint.y);
                    ctx.lineTo(point.x, point.y);
                    ctx.stroke();
                }
            });
        }

        function renderFlowConnections(centers, soul) {
            // Flowing connections based on beat cycle
            const phase = soul.hasAnimation ? (animationFrame * 0.1) : 0;
            for (let i = 0; i < centers.length - 1; i++) {
                const start = centers[i];
                const end = centers[i + 1];
                const flow = Math.sin(phase + i * 0.5) * 0.5 + 0.5;
                
                ctx.globalAlpha = 0.2 + flow * 0.3;
                ctx.beginPath();
                ctx.moveTo(start.x, start.y);
                ctx.lineTo(end.x, end.y);
                ctx.stroke();
            }
        }

        function renderGrid(soul, margin, cellSize) {
            for (let row = 0; row < soul.gridSize; row++) {
                for (let col = 0; col < soul.gridSize; col++) {
                    const x = margin + col * cellSize;
                    const y = margin + row * cellSize;
                    const index = row * soul.gridSize + col;
                    
                    renderGridCell(soul, x, y, cellSize, index, row, col);
                }
            }
        }

        function renderGridCell(soul, x, y, size, index, row, col) {
            // random mix choose palette index not repeating order for more variety
            const colorIdx = Math.floor(seedRandom(soul.hashNum + index * 7) * soul.palette.length);
            const baseColor = soul.palette[colorIdx];
            
            // Cost state affects brightness
            const costFactor = soul.costState / 100;
            const brightness = 0.5 + costFactor * 0.3;
            
            // Tightness affects position variation
            const posVariation = (1 - soul.clusterTightness) * 10;
            const offsetX = (seedRandom(soul.hashNum + index * 3) - 0.5) * posVariation;
            const offsetY = (seedRandom(soul.hashNum + index * 5) - 0.5) * posVariation;
            
            // Size variation based on resonance
            const sizeVariation = soul.resonanceFreq * 0.4;
            const actualSize = size * (0.8 + sizeVariation);
            
            // Animation effects
            let animScale = 1;
            let animRotation = 0;
            
            if (soul.hasAnimation) {
                const phase = animationFrame * 0.1 + index * 0.1;
                switch (soul.animationType) {
                    case 'Pulse':
                        animScale = 1 + Math.sin(phase) * 0.2;
                        break;
                    case 'Rotate':
                        animRotation = phase;
                        break;
                    case 'Breathe':
                        animScale = 1 + Math.sin(phase * 0.5) * 0.1;
                        break;
                }
            }
            
            ctx.save();
            ctx.translate(x + size/2 + offsetX, y + size/2 + offsetY);
            ctx.rotate(animRotation);
            ctx.scale(animScale, animScale);
            
            // Render cell based on texture style
            ctx.fillStyle = baseColor;
            ctx.globalAlpha = brightness;
            
            switch (soul.textureStyle) {
                case 'Smooth':
                    ctx.fillRect(-actualSize/2, -actualSize/2, actualSize, actualSize);
                    break;
                case 'Flowing':
                    renderFlowingCell(actualSize);
                    break;
                case 'Granular':
                    renderGranularCell(actualSize, soul, index);
                    break;
                default:
                    ctx.fillRect(-actualSize/2, -actualSize/2, actualSize, actualSize);
            }
            
            ctx.restore();
        }

        function renderFlowingCell(size) {
            // Fidenza-inspired flowing shapes
            ctx.beginPath();
            const points = 8;
            for (let i = 0; i < points; i++) {
                const angle = (i / points) * Math.PI * 2;
                const radius = size/2 * (0.8 + Math.sin(angle * 3) * 0.2);
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
        }

        function renderGranularCell(size, soul, index) {
            // Multiple small rectangles for granular texture
            const grains = 4;
            const grainSize = size / grains;
            
            for (let i = 0; i < grains; i++) {
                for (let j = 0; j < grains; j++) {
                    const gx = -size/2 + i * grainSize;
                    const gy = -size/2 + j * grainSize;
                    const variation = seedRandom(soul.hashNum + index + i + j) * 0.5 + 0.5;
                    
                    ctx.globalAlpha *= variation;
                    ctx.fillRect(gx, gy, grainSize * 0.8, grainSize * 0.8);
                }
            }
        }

        function renderFlowingElements(soul, margin, gridArea) {
            if (soul.flowPattern === 'Minimal') return;
            
            ctx.globalAlpha = 0.1;
            ctx.strokeStyle = soul.palette[soul.palette.length - 1];
            ctx.lineWidth = 2;
            
            // Add Fidenza-inspired flowing curves
            const curves = 3 + Math.floor(soul.iAmAffinity * 5);
            for (let i = 0; i < curves; i++) {
                const startX = margin + seedRandom(soul.hashNum + i * 20) * gridArea;
                const startY = margin + seedRandom(soul.hashNum + i * 21) * gridArea;
                const endX = margin + seedRandom(soul.hashNum + i * 22) * gridArea;
                const endY = margin + seedRandom(soul.hashNum + i * 23) * gridArea;
                
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                
                // Create flowing curve
                const steps = 20;
                for (let step = 0; step <= steps; step++) {
                    const t = step / steps;
                    const x = startX + (endX - startX) * t;
                    const y = startY + (endY - startY) * t;
                    
                    // Add flowing variation
                    const flowOffset = Math.sin(t * Math.PI * 4 + i) * 20 * soul.resonanceFreq;
                    const perpX = -(endY - startY) / gridArea * flowOffset;
                    const perpY = (endX - startX) / gridArea * flowOffset;
                    
                    ctx.lineTo(x + perpX, y + perpY);
                }
                
                ctx.stroke();
            }
            
            ctx.globalAlpha = 1;
        }

        function updateInfo(soul) {
            document.getElementById('soulHash').textContent = soul.hash;
            document.getElementById('gridSize').textContent = `${soul.gridSize}×${soul.gridSize}`;
            document.getElementById('rungLevel').textContent = `${soul.rungLevel}/45`;
            document.getElementById('costState').textContent = soul.costState;
            document.getElementById('beatCycle').textContent = `${soul.beatCycle}/8`;
            
            document.getElementById('animationType').textContent = soul.animationType;
            document.getElementById('connectionStyle').textContent = soul.connectionStyle;
            document.getElementById('flowPattern').textContent = soul.flowPattern;
            document.getElementById('colorPalette').textContent = `${soul.palette.length} colors`;
            document.getElementById('textureStyle').textContent = soul.textureStyle;
            
            document.getElementById('qualiaMode').textContent = `${soul.qualiaMode}/8`;
            document.getElementById('clusterTightness').textContent = (soul.clusterTightness * 100).toFixed(1) + '%';
            document.getElementById('resonanceFreq').textContent = (soul.resonanceFreq * 100).toFixed(1) + '%';
            document.getElementById('iAmAffinity').textContent = (soul.iAmAffinity * 100).toFixed(1) + '%';
            
            // Update virtues
            const activeVirtues = Object.entries(soul.virtues)
                .filter(([_, data]) => data.active)
                .map(([name, _]) => name);
            
            document.getElementById('virtuesActive').textContent = 
                activeVirtues.length > 0 ? activeVirtues.join(', ') : 'None active';
            
            // Update animation status
            const statusEl = document.getElementById('animationStatus');
            if (soul.hasAnimation) {
                statusEl.textContent = `Animated (${soul.animationType})`;
                statusEl.className = 'animation-status animated';
            } else {
                statusEl.textContent = 'Static Soul';
                statusEl.className = 'animation-status';
            }
        }

        function animate() {
            if (!currentSoul || !currentSoul.hasAnimation) return;
            
            animationFrame++;
            renderSoulGrid(currentSoul);
            requestAnimationFrame(animate);
        }

        function generateNewSoul() {
            // Stop current animation
            isAnimating = false;
            
            // Generate new soul
            currentSoul = generateSoul();
            updateInfo(currentSoul);
            renderSoulGrid(currentSoul);
            
            // Start animation if soul is animated
            if (currentSoul.hasAnimation) {
                isAnimating = true;
                animationFrame = 0;
                animate();
            }
        }

        function init() {
            canvas = document.getElementById('soulGrid');
            ctx = canvas.getContext('2d');
            
            if (!canvas || !ctx) {
                console.error('Failed to initialize canvas');
                return;
            }
            
            // Generate initial soul
            generateNewSoul();
        }

        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html> 