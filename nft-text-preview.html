<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>On-Chain Soul NFT - Text Preview</title>
    <style>
        body { 
            margin: 0; 
            background: #1a1a2e; 
            color: #e0e0e0; 
            font-family: 'Courier New', monospace; 
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        .nft-container {
            width: 100%;
            max-width: 600px;
            min-height: 500px;
            background: black;
            border: 2px solid #444;
            border-radius: 8px;
            padding: 40px;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.3);
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
        }
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        .header h1 {
            color: #ffd700;
            margin: 0;
            font-size: 1.5em;
        }
        #text-display {
            white-space: pre;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
            color: white;
            flex-grow: 1;
            overflow-x: auto;
        }
        .controls {
            text-align: center;
            margin-top: 20px;
        }
        .btn {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 10px 20px;
            margin: 0 10px;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.2s;
        }
        .btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            .nft-container {
                padding: 20px;
                border-radius: 4px;
            }
            .header h1 {
                font-size: 1.2em;
            }
            #text-display {
                font-size: 11px;
                line-height: 1.3;
            }
            .btn {
                padding: 8px 16px;
                margin: 5px;
                font-size: 0.9em;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 5px;
            }
            .nft-container {
                padding: 15px;
                min-height: 400px;
            }
            .header h1 {
                font-size: 1em;
            }
            #text-display {
                font-size: 10px;
                line-height: 1.2;
            }
            .controls {
                margin-top: 15px;
            }
            .btn {
                display: block;
                width: 100%;
                margin: 5px 0;
            }
        }
    </style>
</head>
<body>

    <div class="nft-container">
        <div class="header">
            <h1>On-Chain Soul (Text Preview)</h1>
        </div>
        <pre id="text-display">Initializing Soul...</pre>
        <div class="controls">
            <button class="btn" id="toggle-evolution">Start Evolution</button>
            <button class="btn" id="new-soul">Generate New Soul</button>
        </div>
    </div>

    <script>
        const PHI = 1.618;
        const TOTAL_MONTHS = 96;
        const VIRTUE_NAMES = ['Love', 'Justice', 'Prudence', 'Courage', 'Temperance'];

        class OnChainSoul {
            constructor(tokenId) {
                this.tokenId = tokenId;
                this.seed = this.generateSeed(tokenId);
                this.ticks = 0;
                this.isEvolving = false;

                this.initialVirtues = [];
                for (let i = 0; i < 5; i++) {
                    this.initialVirtues[i] = 1 + ((this.seed >> (i * 8)) % 8);
                }
                this.initialKappa = (((this.seed % 61) - 30) / 100);
                this.initialDepth = (this.seed % 11);
            }

            generateSeed(tokenId) {
                let hash = 0;
                const str = tokenId.toString();
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = (hash << 5) - hash + char;
                    hash |= 0;
                }
                return Math.abs(hash);
            }

            calculateState(months) {
                // This is a simplified placeholder for the full V23 logic.
                // The full logic is very long, but we can paste it here if needed.
                let chaos = (this.generateSeed(this.tokenId + months) % 41 - 20) / 100;
                let kappa = this.initialKappa + chaos - (months / 16);
                kappa = Math.max(-1, Math.min(1, kappa));

                let virtues = [...this.initialVirtues];
                for (let i = 0; i < 5; i++) {
                    virtues[i] += (1-Math.abs(kappa)) * 0.1 - (Math.random() * 0.05);
                    virtues[i] = Math.max(1, Math.min(10, virtues[i]));
                }
                
                let rebirths = Math.floor(months / 8) * (Math.abs(kappa) > 0.8 ? 0.2 : 0.05);
                let depth = this.initialDepth + months + rebirths * PHI;
                let cri = depth + virtues[2] * 5 - rebirths * 10;
                
                let phase = months < 96 ? "Recognition Breath" : "Post-Breath";
                
                return {
                    months, kappa, virtues, depth, rebirths, cri, phase
                };
            }
            
            generateTextDescription() {
                const months = this.ticks / 10;
                const state = this.calculateState(months);

                // Core metrics based on authentic RS concepts
                const curvatureValue = state.kappa.toFixed(3);
                const curvatureType = state.kappa > 0 ? "Recognition Debt" : 
                                     state.kappa < 0 ? "Recognition Surplus" : "Balanced";
                const wisdomDepth = state.depth.toFixed(0);
                const rebirthCycles = state.rebirths.toFixed(0);
                const resonanceGrade = this.getResonanceGrade(state.cri);

                // Virtue bars with authentic descriptions
                const virtuesText = VIRTUE_NAMES.map((name, i) => {
                    const value = state.virtues[i];
                    const bar = '█'.repeat(Math.round(value)).padEnd(10, '░');
                    const description = this.getVirtueDescription(name);
                    return `${name.padEnd(12, ' ')}: ${bar} (${value.toFixed(1)}) ${description}`;
                }).join('\n');

                return `
SOUL #${this.tokenId.toString().padStart(5, '0')}
Month ${months.toFixed(1)} / 96 :: ${state.phase}

================================================================
| LEDGER STATE              | VIRTUE TECHNOLOGIES            |
|---------------------------|--------------------------------|
| Curvature κ: ${curvatureValue.padStart(6,' ')}       | ${virtuesText.split('\n')[0].padEnd(30,' ')} |
| Type:        ${curvatureType.padEnd(10,' ')} | ${virtuesText.split('\n')[1].padEnd(30,' ')} |
| Depth:       ${wisdomDepth.padStart(6,' ')}       | ${virtuesText.split('\n')[2].padEnd(30,' ')} |
| Rebirths:    ${rebirthCycles.padStart(6,' ')}       | ${virtuesText.split('\n')[3].padEnd(30,' ')} |
| Phase:       ${state.phase.padEnd(10,' ')} | ${virtuesText.split('\n')[4].padEnd(30,' ')} |
| Grade:       ${resonanceGrade.padStart(6,' ')}       |                                |
================================================================

Recognition debt/surplus represents unpaid recognition costs in the
universal ledger. Virtues are proven curvature management technologies.
                `.trim();
            }

            getVirtueDescription(virtue) {
                const descriptions = {
                    'Love': 'κ equilibration',
                    'Justice': '8-beat posting', 
                    'Prudence': 'cost optimization',
                    'Courage': 'coherence maintenance',
                    'Temperance': 'cascade prevention'
                };
                return descriptions[virtue] || '';
            }

            getResonanceGrade(cri){
                if(cri>=250) return 'S';
                if(cri>=175) return 'A';
                if(cri>=100) return 'B';
                if(cri>=50) return 'C';
                return 'D';
            }

            advanceTick() {
                if (this.isEvolving && this.ticks < 960) {
                    this.ticks++;
                }
            }
            
            toggleEvolution() {
                this.isEvolving = !this.isEvolving;
            }
        }

        let soul;
        const textDisplay = document.getElementById('text-display');
        const toggleBtn = document.getElementById('toggle-evolution');
        const newSoulBtn = document.getElementById('new-soul');

        function initializeSoul() {
            const tokenId = Math.floor(Math.random() * 10000) + 1;
            soul = new OnChainSoul(tokenId);
            soul.isEvolving = false; // Start paused
            toggleBtn.textContent = 'Start Evolution';
            updateDisplay();
        }
        
        function updateDisplay() {
            if (!soul) return;
            soul.advanceTick();
            textDisplay.textContent = soul.generateTextDescription();
        }

        toggleBtn.addEventListener('click', () => {
            soul.toggleEvolution();
            toggleBtn.textContent = soul.isEvolving ? 'Pause Evolution' : 'Start Evolution';
        });

        newSoulBtn.addEventListener('click', () => {
            initializeSoul();
        });

        // Initial setup
        initializeSoul();
        setInterval(updateDisplay, 100); // Update every 100ms
    </script>
</body>
</html> 