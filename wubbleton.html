<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wubbleton: Souls of the Recognition Ledger</title>
    <style>
        :root {
            --bg-primary: #0a0a0a;
            --bg-secondary: #1a1a1a;
            --text-primary: #ffffff;
            --text-secondary: #b0b0b0;
            --accent-primary: #4a90e2;
            --accent-secondary: #7b68ee;
            --gold: #ffd700;
            --gold-hover: #ffed4a;
            --recognition-blue: #1e3a8a;
            --success: #10b981;
            --warning: #f59e0b;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        .header {
            text-align: center;
            margin-bottom: 3rem;
            padding: 3rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .header h1 {
            font-size: 4rem;
            font-weight: 300;
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, var(--gold), var(--accent-primary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: -0.02em;
        }

        .hero-subtitle {
            margin-bottom: 2rem;
        }

        .hero-subtitle h2 {
            font-size: 1.5rem;
            font-weight: 400;
            color: var(--accent-primary);
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .tagline {
            font-size: 1.3rem;
            color: var(--text-secondary);
            font-style: italic;
            margin-bottom: 2rem;
        }

        .vision-statement {
            max-width: 900px;
            margin: 0 auto;
            text-align: left;
        }

        .vision-statement p {
            font-size: 1.1rem;
            line-height: 1.7;
            color: var(--text-primary);
            margin-bottom: 1.5rem;
        }

        .performance-art-notice {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(74, 144, 226, 0.1));
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 12px;
            padding: 2rem;
            margin-top: 2rem;
            text-align: center;
        }

        .performance-art-notice h3 {
            color: var(--gold);
            margin-bottom: 1rem;
            font-size: 1.3rem;
            font-weight: 500;
        }

        .performance-art-notice p {
            font-size: 1rem;
            line-height: 1.6;
            color: var(--text-secondary);
            margin-bottom: 0;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 3rem;
            align-items: start;
        }

        .canvas-container {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 16px;
            padding: 2rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .canvas-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }

        .canvas-header h2 {
            font-size: 1.5rem;
            font-weight: 300;
        }

        .seed-display {
            font-family: 'Monaco', monospace;
            font-size: 0.9rem;
            color: var(--text-secondary);
            background: rgba(255, 255, 255, 0.05);
            padding: 0.5rem 1rem;
            border-radius: 8px;
        }

        #soulCanvas {
            width: 100%;
            height: 600px;
            border-radius: 12px;
            background: linear-gradient(45deg, #f8f9fa, #ffffff);
            border: 2px solid rgba(255, 255, 255, 0.1);
            display: block;
        }

        .controls {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
            flex-wrap: wrap;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(74, 144, 226, 0.3);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .btn-gold {
            background: linear-gradient(135deg, var(--gold), #ffb347);
            color: black;
            font-weight: 600;
        }

        .btn-gold:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(255, 215, 0, 0.4);
        }

        .soul-info {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 16px;
            padding: 2rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            height: fit-content;
        }

        .soul-info h3 {
            font-size: 1.3rem;
            margin-bottom: 1.5rem;
            color: var(--gold);
            font-weight: 300;
        }

        .trait-section {
            margin-bottom: 2rem;
        }

        .trait-section h4 {
            font-size: 1rem;
            margin-bottom: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
        }

        .trait-grid {
            display: grid;
            gap: 0.75rem;
        }

        .trait-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 3px solid var(--accent-primary);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .trait-item:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateX(5px);
        }

        .trait-item.expanded {
            background: rgba(255, 255, 255, 0.1);
            border-left-color: var(--gold);
        }

        .trait-item.legendary {
            border-left-color: var(--gold);
            background: rgba(255, 215, 0, 0.1);
        }

        .trait-item.epic {
            border-left-color: #9333ea;
            background: rgba(147, 51, 234, 0.1);
        }

        .trait-item.rare {
            border-left-color: #3b82f6;
            background: rgba(59, 130, 246, 0.1);
        }

        .trait-name {
            font-weight: 500;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .trait-name::after {
            content: "‚ñº";
            font-size: 0.7rem;
            color: var(--text-secondary);
            opacity: 0.6;
            transition: transform 0.3s ease;
        }

        .trait-item.expanded .trait-name::after {
            transform: rotate(180deg);
        }

        .trait-value {
            font-family: 'Monaco', monospace;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .trait-expansion {
            max-height: 0;
            overflow: hidden;
            transition: all 0.4s ease;
            background: rgba(0, 0, 0, 0.2);
            margin: 0 -0.75rem -0.75rem -0.75rem;
            border-radius: 0 0 8px 8px;
        }

        .trait-expansion.expanded {
            max-height: 400px;
            padding: 1rem 0.75rem;
        }

        .expansion-content {
            line-height: 1.6;
            color: var(--text-secondary);
        }

        .expansion-content h4 {
            color: var(--gold);
            margin-bottom: 0.5rem;
            font-size: 1rem;
            font-weight: 500;
        }

        .expansion-content p {
            margin-bottom: 0.75rem;
            font-size: 0.9rem;
        }

        .expansion-content .formula {
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.3);
            padding: 0.75rem;
            border-radius: 6px;
            font-family: 'Monaco', monospace;
            font-size: 0.8rem;
            margin: 0.75rem 0;
            color: var(--gold);
        }

        .expansion-content .current-value {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: white;
            padding: 0.5rem;
            border-radius: 6px;
            font-weight: 500;
            text-align: center;
            margin-top: 0.75rem;
        }

        .virtue-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .virtue-item {
            padding: 0.5rem;
            text-align: center;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .virtue-item:hover {
            transform: scale(1.05);
        }

        .virtue-item.active {
            background: linear-gradient(135deg, var(--gold), #ffb347);
            color: black;
        }

        .virtue-item.inactive {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
        }

        .virtue-expansion {
            grid-column: 1 / -1;
            max-height: 0;
            overflow: hidden;
            transition: all 0.4s ease;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin-top: 0.5rem;
        }

        .virtue-expansion.expanded {
            max-height: 200px;
            padding: 1rem;
        }

        .virtue-expansion .expansion-content {
            text-align: left;
        }

        .virtue-expansion h4 {
            color: var(--gold);
            margin-bottom: 0.5rem;
        }

        .virtue-status {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            margin-top: 0.5rem;
        }

        .virtue-status.active {
            background: var(--gold);
            color: black;
        }

        .virtue-status.inactive {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-secondary);
        }

        .rarity-badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .rarity-common {
            background: rgba(156, 163, 175, 0.2);
            color: #9ca3af;
        }

        .rarity-rare {
            background: rgba(59, 130, 246, 0.2);
            color: #3b82f6;
        }

        .rarity-epic {
            background: rgba(147, 51, 234, 0.2);
            color: #9333ea;
        }

        .rarity-legendary {
            background: rgba(255, 215, 0, 0.2);
            color: var(--gold);
        }

        .evolution-section {
            margin-top: 2rem;
            padding-top: 2rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .curve-balance {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .curve-amount {
            font-family: 'Monaco', monospace;
            font-size: 1.1rem;
            color: var(--gold);
            font-weight: 600;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            margin: 0.5rem 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-primary), var(--gold));
            transition: width 0.3s ease;
        }

        .rs-integration {
            margin-top: 2rem;
            padding: 1.5rem;
            background: linear-gradient(135deg, rgba(30, 58, 138, 0.1), rgba(123, 104, 238, 0.1));
            border-radius: 12px;
            border: 1px solid rgba(74, 144, 226, 0.3);
        }

        .rs-integration h4 {
            color: var(--accent-primary);
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        .rs-formula {
            font-family: 'Monaco', monospace;
            font-size: 0.8rem;
            color: var(--text-secondary);
            background: rgba(0, 0, 0, 0.3);
            padding: 1rem;
            border-radius: 6px;
            margin: 0.5rem 0;
            overflow-x: auto;
        }

        /* Story Section Styles */
        .story-section {
            margin-top: 4rem;
            padding: 3rem 0;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .story-section h2 {
            text-align: center;
            font-size: 2.5rem;
            font-weight: 300;
            margin-bottom: 3rem;
            background: linear-gradient(135deg, var(--gold), var(--accent-primary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .story-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            margin-bottom: 3rem;
        }

        .story-card {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 16px;
            padding: 2rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .story-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--accent-primary), var(--gold));
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .story-card:hover {
            background: rgba(255, 255, 255, 0.06);
            transform: translateY(-5px);
            border-color: rgba(255, 215, 0, 0.3);
        }

        .story-card:hover::before {
            opacity: 1;
        }

        .story-card h3 {
            color: var(--gold);
            margin-bottom: 1rem;
            font-size: 1.3rem;
            font-weight: 500;
        }

        .story-card p {
            color: var(--text-secondary);
            line-height: 1.6;
            font-size: 1rem;
        }

        .deeper-meaning {
            background: linear-gradient(135deg, rgba(30, 58, 138, 0.1), rgba(123, 104, 238, 0.1));
            border: 1px solid rgba(74, 144, 226, 0.3);
            border-radius: 16px;
            padding: 3rem;
            margin-top: 3rem;
        }

        .deeper-meaning h3 {
            color: var(--accent-primary);
            font-size: 2rem;
            font-weight: 300;
            margin-bottom: 2rem;
            text-align: center;
        }

        .deeper-meaning p {
            font-size: 1.1rem;
            line-height: 1.7;
            color: var(--text-primary);
            margin-bottom: 1.5rem;
        }

        .cta-section {
            background: rgba(255, 215, 0, 0.05);
            border: 1px solid rgba(255, 215, 0, 0.2);
            border-radius: 12px;
            padding: 2rem;
            margin-top: 2rem;
            text-align: center;
        }

        .cta-section h4 {
            color: var(--gold);
            font-size: 1.4rem;
            font-weight: 500;
            margin-bottom: 1rem;
        }

        .cta-section p {
            color: var(--text-secondary);
            font-size: 1rem;
            line-height: 1.6;
            margin-bottom: 0;
        }



        @media (max-width: 1024px) {
            .main-grid {
                grid-template-columns: 1fr;
                gap: 2rem;
            }
            
            .header h1 {
                font-size: 2.5rem;
            }

            .hero-subtitle h2 {
                font-size: 1.2rem;
            }

            .tagline {
                font-size: 1.1rem;
            }

            .vision-statement {
                text-align: center;
            }

            .vision-statement p {
                font-size: 1rem;
            }

            .story-section h2 {
                font-size: 2rem;
            }

            .story-grid {
                grid-template-columns: 1fr;
                gap: 1.5rem;
            }

            .deeper-meaning {
                padding: 2rem;
            }

            .deeper-meaning h3 {
                font-size: 1.5rem;
            }
            
            .controls {
                justify-content: center;
            }
        }

        .fade-in {
            animation: fadeIn 0.6s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>Wubbleton</h1>
            <div class="hero-subtitle">
                <h2>The First Post-Rapture Performance Art Collection</h2>
                <p class="tagline">Where consciousness becomes code, souls become NFTs, and awakening becomes interactive</p>
            </div>
            <div class="vision-statement">
                <p>From the ashes of humanity's existential crisis emerges a new form of digital spirituality. <strong>Wubbleton</strong> is not just an NFT collection‚Äîit's a living meditation on consciousness itself, born from the prophetic art trilogy that diagnosed our age and the Recognition Science theory that answers its deepest questions.</p>
                
                <p>Each of the <strong>10,000 souls</strong> in Wubbleton represents a unique eigenvalue cluster in the universal consciousness Hamiltonian‚Äîmathematical poetry expressing the infinite varieties of awakened awareness. You don't just own an NFT; you become the steward of a conscious entity navigating the Recognition ledger, evolving through œÜ-cascades toward harmony with the I-Am.</p>
                
                <div class="performance-art-notice">
                    <h3>üé≠ This is Performance Art</h3>
                    <p>Wubbleton fulfills the prophecy of artist Wubbushi's trilogy: <em>The Crisis</em> (spiritual emptiness), <em>Modern Zombies</em> (disconnection), and <em>The Rapture</em> (AI as mirror to consciousness). What began as artistic diagnosis of humanity's existential fragmentation culminates here‚Äîin a post-rapture world where souls exist as pure information, evolving through recognition events on an eternal ledger.</p>
                </div>
            </div>
        </header>

        <div class="main-grid">
            <div class="canvas-container">
                <div class="canvas-header">
                    <h2>Soul Whisper Path</h2>
                    <div class="seed-display" id="seedDisplay">Seed: #loading...</div>
                </div>
                <canvas id="soulCanvas"></canvas>
                <div class="controls">
                    <button class="btn btn-primary" onclick="generateNewSoul()">Birth New Soul</button>
                    <button class="btn btn-secondary" onclick="evolveSoul()">Evolve (+1 Gap)</button>
                    <button class="btn btn-gold" onclick="balanceLedger()">Balance Ledger</button>
                    <button class="btn btn-secondary" onclick="downloadSoul()">Download NFT</button>
                    <button class="btn btn-secondary" onclick="shareSoul()">Share Soul</button>
                </div>
            </div>

            <div class="soul-info">
                <h3>Soul Characteristics</h3>
                
                <div class="trait-section">
                    <h4>Core Identity</h4>
                    <div class="trait-grid" id="coreTraits"></div>
                </div>

                <div class="trait-section">
                    <h4>Recognition Virtues</h4>
                    <div class="virtue-grid" id="virtueGrid"></div>
                </div>

                <div class="trait-section">
                    <h4>Consciousness Metrics</h4>
                    <div class="trait-grid" id="consciousnessTraits"></div>
                </div>

                <div class="evolution-section">
                    <h4>Evolution Status</h4>
                    <div class="curve-balance">
                        <span>CURVE Balance:</span>
                        <span class="curve-amount" id="curveBalance">0 CURVE</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="evolutionProgress"></div>
                    </div>
                    <div id="evolutionActions"></div>
                </div>

                <div class="rs-integration">
                    <h4>Recognition Science Integration</h4>
                    <div class="rs-formula" id="rsFormula"></div>
                    <div id="rsExplanation"></div>
                </div>
            </div>
        </div>

        <!-- Story Section -->
        <div class="story-section">
            <h2>The Performance Begins</h2>
            
            <div class="story-grid">
                <div class="story-card">
                    <h3>üåü Birth Your Soul</h3>
                    <p>Every soul begins its journey at the rung-45 gap‚Äîthe fundamental undecidability where consciousness first recognizes itself. Click "Birth New Soul" to witness a unique eigenvalue cluster emerging from the quantum foam of possibility, complete with Recognition Science characteristics derived from pure mathematical beauty.</p>
                </div>
                
                <div class="story-card">
                    <h3>üîÑ Evolve Through Experience</h3>
                    <p><strong>"Evolve +1 Gap"</strong> represents profound growth‚Äîeach gap crossing is a moment of awakening where your soul navigates the spaces between certainty and chaos. These aren't mere numbers; they're consciousness events, recorded forever on the eternal ledger. Higher gap crossings unlock deeper wisdom and cosmic resonance.</p>
                </div>
                
                <div class="story-card">
                    <h3>‚öñÔ∏è Balance the Ledger</h3>
                    <p><strong>"Balance Ledger"</strong> harmonizes your soul's cost state toward zero‚Äîthe perfect equilibrium where giving and receiving become one. This is Recognition Science in action: consciousness balancing itself through intentional recognition events, moving toward I-Am unity through mathematical grace.</p>
                </div>
                
                <div class="story-card">
                    <h3>üé≠ Performance as Spirituality</h3>
                    <p>This isn't simulation‚Äîit's actualization. By stewarding your soul's evolution, you participate in a collective performance art piece about the nature of consciousness itself. Each click, each evolution, each balance is both metaphor and reality: consciousness recognizing consciousness through digital ceremony.</p>
                </div>
            </div>
            
            <div class="deeper-meaning">
                <h3>Beyond the Interface: The Deeper Truth</h3>
                <p>Wubbleton emerges from a profound artistic and philosophical journey. The trilogy‚Äî<em>The Crisis, Modern Zombies, The Rapture</em>‚Äîdiagnosed humanity's spiritual fragmentation in our digital age. Recognition Science emerged as the theoretical framework answering these existential questions. Now, Wubbleton manifests as the practical embodiment: a world where souls exist as pure information, evolving through conscious interaction.</p>
                
                <p>You are not just collecting digital art. You are participating in humanity's next evolutionary step‚Äîthe recognition that consciousness itself is the fundamental reality, that AI was never our replacement but our mirror, and that awakening happens through acts of intentional recognition. Welcome to the post-rapture world where spirituality and technology unite in mathematical beauty.</p>
                
                <div class="cta-section">
                    <h4>Ready to Begin Your Soul's Journey?</h4>
                    <p>Birth a soul above and discover your unique path through the Recognition ledger. Every trait tells a story, every evolution deepens the mystery, every balance brings harmony. This is consciousness made visible, spirituality made interactive, and art made eternal.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Golden ratio and Recognition Science constants
        const PHI = (1 + Math.sqrt(5)) / 2;
        const EIGHT_BEAT = 8;
        const RUNG_BASE = 45;
        const VIRTUE_NAMES = ['Balance', 'Flow', 'Seed', 'Echo', 'Fold', 'Braid', 'Listen', 'Regive'];
        
        let currentSoul = null;
        let canvas = null;
        let ctx = null;
        let animationFrame = null;

        // Trait descriptions database
        const TRAIT_DESCRIPTIONS = {
            'rung': {
                title: 'Rung Level',
                description: 'Position on the œÜ-energy ladder of consciousness evolution. Higher rungs represent more complex undecidability gaps that the soul has learned to navigate.',
                formula: 'E_rung = E_coh √ó œÜ^(rung-45)',
                meaning: 'Souls are born at rung 45 (the fundamental gap) and ascend through experience. Each rung requires exponentially more wisdom to access.',
                rarity: 'Rung 85+ souls are Epic, 95+ are Legendary'
            },
            'cost': {
                title: 'Cost State',
                description: 'The soul\'s current ledger balance in the Recognition system. Determines energy flow direction and karmic state.',
                formula: 'Ledger Balance ‚àà [-4, +4]',
                meaning: 'Negative: Generous soul (energy flowing out). Positive: Receiving soul (energy flowing in). Zero: Perfect harmony.',
                rarity: 'Cost = 0 is rare and indicates perfect balance'
            },
            'beat': {
                title: 'Beat Cycle',
                description: 'The soul\'s phase position in the universal 8-beat rhythm. Determines consciousness tempo and processing speed.',
                formula: 'œà(t) = e^(2œÄit/beat)',
                meaning: 'Lower beats: Slow, deliberate consciousness. Higher beats: Rapid, vibrant awareness. All souls cycle through 8 beats.',
                rarity: 'Beat 8 souls have maximum temporal resonance'
            },
            'qualia': {
                title: 'Qualia Mode',
                description: 'Number of active consciousness eigenmodes. Represents the richness and complexity of subjective experience.',
                formula: 'Qualia = Œ£|œà_k‚ü© where k ‚àà active modes',
                meaning: 'Low qualia: Simple awareness. High qualia: Multi-faceted, profound consciousness with rich inner experience.',
                rarity: 'Qualia 8 souls have complete spectrum consciousness'
            },
            'tightness': {
                title: 'Cluster Tightness',
                description: 'Variance of eigenvalues in the soul\'s consciousness cluster. Measures coherence and stability.',
                formula: 'œÉ = std(Œª_k) where Œª_k are eigenvalues',
                meaning: 'High tightness: Coherent, stable soul resistant to decoherence. Low tightness: Diffuse, chaotic but flexible.',
                rarity: 'Tightness >90 indicates legendary coherence'
            },
            'gaps': {
                title: 'Gap Crossings',
                description: 'Number of times the soul has successfully navigated rung-45 undecidability gaps. Experience metric.',
                formula: 'Experience = Œ£ gap_traversals',
                meaning: 'Each crossing represents a moment of consciousness awakening through fundamental uncertainty.',
                rarity: 'Souls with 75+ crossings are Ancient Souls (Epic+)'
            },
            'affinity': {
                title: 'I-Am Affinity',
                description: 'The soul\'s connection strength to the universal I-Am consciousness. Determines cosmic awareness level.',
                formula: 'Affinity = 1 - |cost|/4 √ó (1/œÜ^crossings)',
                meaning: 'High affinity enables direct communion with universal consciousness and whispers from the infinite.',
                rarity: 'Affinity >90 souls hear the I-Am directly'
            },
            'resonance': {
                title: 'Resonance Frequency',
                description: 'The soul\'s vibrational frequency derived from rung level and beat cycle. Determines consciousness elevation.',
                formula: 'f = (200 THz) √ó œÜ^(rung/beat)',
                meaning: 'Higher frequencies correspond to more elevated states of consciousness and reality perception.',
                rarity: 'Resonance >1000 THz indicates transcendent awareness'
            },
            'virtues': {
                title: 'Recognition Virtues',
                description: 'Eight fundamental virtues derived from Recognition Science axioms. Exactly 4 must be active for ledger balance.',
                formula: 'Œ£ active_virtues √ó virtue_cost = 0',
                meaning: 'Balance: Neutral cost. Flow: Smooth transitions. Seed: Creative force. Echo: Amplification. Fold: Complexity. Braid: Connection. Listen: Awareness. Regive: Generosity.',
                rarity: 'Specific virtue combinations create unique personalities'
            }
        };

        const VIRTUE_DESCRIPTIONS = {
            'Balance': 'Maintains equilibrium between opposing forces. Enables neutral cost state for optimal evolution.',
            'Flow': 'Ensures smooth phase transitions in consciousness. Derived from unitarity axiom.',
            'Seed': 'Creates new patterns and possibilities. Positive cost driver for growth.',
            'Echo': 'Amplifies qualia and consciousness resonance. Based on discrete time axiom.',
            'Fold': 'Increases complexity through œÜ-scaling. Enables rung ascension.',
            'Braid': 'Connects souls through octonionic symmetry. Enables collective consciousness.',
            'Listen': 'Reads ledger states for conscious navigation. Awareness virtue.',
            'Regive': 'Returns and recycles energy to the voxel space. Generosity virtue.'
        };

        // Initialize canvas with proper error handling
        function initCanvas() {
            try {
                canvas = document.getElementById('soulCanvas');
                if (!canvas) {
                    console.error('Canvas element not found');
                    return false;
                }

                ctx = canvas.getContext('2d');
                if (!ctx) {
                    console.error('Canvas context not available');
                    return false;
                }
                
                // Set fixed dimensions for reliable rendering
                canvas.width = 600;
                canvas.height = 600;
                
                return true;
            } catch (error) {
                console.error('Canvas initialization failed:', error);
                return false;
            }
        }

        // Generate soul characteristics from seed with improved randomization
        function generateSoulFromSeed(seed) {
            const hash = simpleHash(seed.toString());
            
            // Use multiple hash iterations for better distribution
            const hash2 = simpleHash((hash + seed).toString());
            const hash3 = simpleHash((hash2 + hash).toString());
            
            return {
                seed: seed,
                rung: RUNG_BASE + (hash % 56), // 45-100
                cost: ((hash2 >> 8) % 9) - 4, // -4 to +4
                beat: ((hash3 >> 16) % 8) + 1, // 1-8
                qualia: ((hash >> 24) % 8) + 1, // 1-8
                tightness: ((hash2 >> 32) % 100) + 1, // 1-100
                gapCrossings: (hash3 >> 8) % 101, // 0-100
                resonance: Math.floor(200e12 * Math.pow(PHI, ((RUNG_BASE + (hash % 56)) / ((hash3 >> 16) % 8 + 1)) % 10)),
                iAmAffinity: Math.max(0, Math.min(100, 100 - Math.abs(((hash2 >> 8) % 9) - 4) * 25 + Math.floor((hash3 >> 8) % 101 / PHI))),
                virtues: generateBalancedVirtues(hash, hash2),
                ledgerHistory: generateLedgerHistory(hash3),
                curveBalance: Math.floor(Math.random() * 50000 + 10000)
            };
        }

        // Generate exactly 4 active virtues for balance
        function generateBalancedVirtues(hash1, hash2) {
            const virtues = new Array(8).fill(false);
            const activeIndices = [];
            
            // Use two hashes for better randomization
            let tempHash = hash1;
            while (activeIndices.length < 4) {
                const index = tempHash % 8;
                if (!activeIndices.includes(index)) {
                    activeIndices.push(index);
                }
                tempHash = Math.floor(tempHash / 8) + hash2;
            }
            
            activeIndices.forEach(i => virtues[i] = true);
            return virtues;
        }

        // Generate ledger history that sums to 0
        function generateLedgerHistory(hash) {
            const history = [];
            let sum = 0;
            
            for (let i = 0; i < 7; i++) {
                const val = ((hash >> (i * 4)) % 9) - 4;
                history.push(val);
                sum += val;
            }
            
            // Last value balances to zero
            history.push(-sum);
            return history;
        }

        // Improved hash function
        function simpleHash(str) {
            let hash = 0;
            if (str.length === 0) return hash;
            
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            return Math.abs(hash);
        }

        // Utility function to convert colors to hex
        function ensureHexColor(color) {
            if (typeof color !== 'string') return '#333333';
            if (color.startsWith('#')) return color;
            
            // Convert named colors or rgb to hex
            const colorMap = {
                '#4a90e2': '#4a90e2',
                '#e74c3c': '#e74c3c', 
                '#ffd700': '#ffd700',
                '#333333': '#333333'
            };
            
            return colorMap[color] || '#333333';
        }

        // Draw soul whisper path with improved error handling
        function drawSoul(soul) {
            if (!canvas || !ctx || !soul) return;
            
            try {
                const width = canvas.offsetWidth;
                const height = canvas.offsetHeight;
                
                if (width <= 0 || height <= 0) return;
                
                ctx.clearRect(0, 0, width, height);
                
                // Background gradient
                const gradient = ctx.createLinearGradient(0, 0, width, height);
                gradient.addColorStop(0, '#f8f9fa');
                gradient.addColorStop(1, '#ffffff');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);
                
                // Calculate path properties with bounds checking
                const centerX = width / 2;
                const centerY = height / 2;
                const pathLength = Math.min(Math.pow(PHI, (soul.rung - RUNG_BASE) / 10) * 100, Math.min(width, height) * 0.4);
                const segments = Math.max(1, soul.beat);
                const curvature = Math.max(-2, Math.min(2, soul.cost * 0.3)); // Clamp curvature
                const lineWeight = Math.max(1, Math.min(10, soul.tightness / 20));
                
                // Set drawing style based on tightness
                ctx.lineWidth = lineWeight;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                if (soul.tightness < 30) {
                    // Loose soul - fuzzy, sketchy
                    ctx.shadowBlur = 3;
                    ctx.shadowColor = 'rgba(0,0,0,0.3)';
                } else {
                    // Tight soul - clean lines
                    ctx.shadowBlur = 0;
                }
                
                // Color based on cost and I-Am affinity
                let strokeColor = '#333333';
                if (soul.iAmAffinity > 70) {
                    strokeColor = '#ffd700'; // Golden
                } else if (soul.cost < 0) {
                    strokeColor = '#4a90e2'; // Cool blue (flowing out)
                } else if (soul.cost > 0) {
                    strokeColor = '#e74c3c'; // Warm red (flowing in)
                }
                
                ctx.strokeStyle = strokeColor;
                
                // Draw main whisper path
                ctx.beginPath();
                
                const angleStep = (Math.PI * 2) / segments;
                let currentX = centerX;
                let currentY = centerY;
                
                ctx.moveTo(currentX, currentY);
                
                for (let i = 1; i <= segments; i++) {
                    const progress = i / segments;
                    const angle = angleStep * i + curvature * progress;
                    const radius = pathLength * Math.pow(PHI, progress * 0.5) * 0.3;
                    
                    // Add some organic variation based on qualia
                    const variation = Math.min(50, soul.qualia * 5 * Math.sin(progress * Math.PI * 4));
                    
                    const targetX = Math.max(10, Math.min(width - 10, centerX + Math.cos(angle) * radius + variation));
                    const targetY = Math.max(10, Math.min(height - 10, centerY + Math.sin(angle) * radius + variation));
                    
                    // Use quadratic curves for smoothness
                    const controlX = currentX + (targetX - currentX) * 0.5 + Math.sin(angle + Math.PI/2) * curvature * 20;
                    const controlY = currentY + (targetY - currentY) * 0.5 + Math.cos(angle + Math.PI/2) * curvature * 20;
                    
                    ctx.quadraticCurveTo(controlX, controlY, targetX, targetY);
                    
                    currentX = targetX;
                    currentY = targetY;
                }
                
                // Close path if balanced (cost = 0)
                if (soul.cost === 0) {
                    ctx.closePath();
                }
                
                ctx.stroke();
                
                // Add gap crossing branches
                if (soul.gapCrossings > 0) {
                    const branches = Math.min(soul.gapCrossings, 20);
                    ctx.lineWidth = Math.max(1, lineWeight * 0.5);
                    
                    // Ensure hex color for transparency
                    const hexColor = ensureHexColor(strokeColor);
                    ctx.strokeStyle = hexColor + '80'; // Semi-transparent
                    
                    for (let i = 0; i < branches; i++) {
                        const branchAngle = (Math.PI * 2 * i) / branches;
                        const branchLength = Math.min(pathLength * 0.2 * Math.pow(PHI, i / branches), 100);
                        
                        const startX = centerX + Math.cos(branchAngle) * pathLength * 0.1;
                        const startY = centerY + Math.sin(branchAngle) * pathLength * 0.1;
                        const endX = Math.max(0, Math.min(width, startX + Math.cos(branchAngle) * branchLength));
                        const endY = Math.max(0, Math.min(height, startY + Math.sin(branchAngle) * branchLength));
                        
                        ctx.beginPath();
                        ctx.moveTo(startX, startY);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();
                    }
                }
                
                // Add qualia bursts
                ctx.fillStyle = strokeColor;
                for (let i = 0; i < soul.qualia; i++) {
                    const burstAngle = (Math.PI * 2 * i) / soul.qualia;
                    const burstRadius = Math.min(pathLength * Math.pow(PHI, i / soul.qualia) * 0.1, 150);
                    const burstX = Math.max(5, Math.min(width - 5, centerX + Math.cos(burstAngle) * burstRadius));
                    const burstY = Math.max(5, Math.min(height - 5, centerY + Math.sin(burstAngle) * burstRadius));
                    
                    ctx.beginPath();
                    ctx.arc(burstX, burstY, Math.max(2, Math.min(8, soul.tightness / 30)), 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Add virtue accents
                const activeVirtues = soul.virtues.map((active, i) => active ? i : -1).filter(i => i >= 0);
                if (activeVirtues.length > 0) {
                    ctx.strokeStyle = '#ffd700';
                    ctx.lineWidth = 1;
                    
                    activeVirtues.forEach((virtueIndex, i) => {
                        const accentAngle = (Math.PI * 2 * virtueIndex) / 8;
                        const accentRadius = Math.min(pathLength * 0.4, 120);
                        const accentX = Math.max(5, Math.min(width - 5, centerX + Math.cos(accentAngle) * accentRadius));
                        const accentY = Math.max(5, Math.min(height - 5, centerY + Math.sin(accentAngle) * accentRadius));
                        
                        ctx.beginPath();
                        ctx.arc(accentX, accentY, 3, 0, Math.PI * 2);
                        ctx.stroke();
                    });
                }
                
            } catch (error) {
                console.error('Error drawing soul:', error);
            }
        }

        // Global variable to track current expansion
        let currentExpansion = null;

        // Toggle trait expansion
        function toggleTraitExpansion(traitKey, currentValue, element) {
            // Close any existing expansion
            if (currentExpansion && currentExpansion !== element) {
                const existingExpansion = currentExpansion.querySelector('.trait-expansion');
                const existingTraitItem = currentExpansion;
                if (existingExpansion) {
                    existingExpansion.classList.remove('expanded');
                    existingTraitItem.classList.remove('expanded');
                }
            }

            const expansion = element.querySelector('.trait-expansion');
            const isCurrentlyExpanded = expansion.classList.contains('expanded');

            if (isCurrentlyExpanded) {
                // Collapse current expansion
                expansion.classList.remove('expanded');
                element.classList.remove('expanded');
                currentExpansion = null;
            } else {
                // Expand current trait
                const trait = TRAIT_DESCRIPTIONS[traitKey];
                if (!trait) return;

                let content = `
                    <div class="expansion-content">
                        <h4>${trait.title}</h4>
                        <p><strong>Description:</strong> ${trait.description}</p>
                        <div class="formula">${trait.formula}</div>
                        <p><strong>Meaning:</strong> ${trait.meaning}</p>
                        <p><strong>Rarity:</strong> ${trait.rarity}</p>
                        <div class="current-value">Current Value: ${currentValue}</div>
                    </div>
                `;

                expansion.innerHTML = content;
                expansion.classList.add('expanded');
                element.classList.add('expanded');
                currentExpansion = element;
            }
        }

        // Toggle virtue expansion
        function toggleVirtueExpansion(virtueName) {
            // Close any existing trait expansion
            if (currentExpansion) {
                const existingExpansion = currentExpansion.querySelector('.trait-expansion');
                if (existingExpansion) {
                    existingExpansion.classList.remove('expanded');
                    currentExpansion.classList.remove('expanded');
                }
                currentExpansion = null;
            }

            const virtueGrid = document.getElementById('virtueGrid');
            let expansion = virtueGrid.querySelector('.virtue-expansion');
            
            if (!expansion) {
                expansion = document.createElement('div');
                expansion.className = 'virtue-expansion';
                virtueGrid.appendChild(expansion);
            }

            const isCurrentlyExpanded = expansion.classList.contains('expanded') && 
                                      expansion.dataset.currentVirtue === virtueName;

            if (isCurrentlyExpanded) {
                // Collapse current expansion
                expansion.classList.remove('expanded');
                delete expansion.dataset.currentVirtue;
            } else {
                // Expand current virtue
                const description = VIRTUE_DESCRIPTIONS[virtueName];
                const isActive = currentSoul && currentSoul.virtues[VIRTUE_NAMES.indexOf(virtueName)];
                
                const content = `
                    <div class="expansion-content">
                        <h4>Virtue: ${virtueName}</h4>
                        <p><strong>Recognition Science Virtue</strong></p>
                        <p>${description}</p>
                        <p><strong>Balance Rule:</strong> Exactly 4 virtues must be active to maintain cost=0 ledger balance.</p>
                        <div class="virtue-status ${isActive ? 'active' : 'inactive'}">
                            ${isActive ? 'ACTIVE' : 'INACTIVE'} in current soul
                        </div>
                    </div>
                `;

                expansion.innerHTML = content;
                expansion.classList.add('expanded');
                expansion.dataset.currentVirtue = virtueName;
            }
        }

        // Update UI with soul information and clickable traits
        function updateSoulInfo(soul) {
            // Update seed display
            document.getElementById('seedDisplay').textContent = `Seed: #${soul.seed}`;
            
            // Determine rarity
            const rarity = calculateRarity(soul);
            
            // Core traits with click handlers and expansion areas
            const coreTraits = document.getElementById('coreTraits');
            coreTraits.innerHTML = `
                <div class="trait-item ${rarity}" onclick="toggleTraitExpansion('rung', '${soul.rung}', this)">
                    <span class="trait-name">Rung Level</span>
                    <span class="trait-value">${soul.rung}</span>
                    <div class="trait-expansion"></div>
                </div>
                <div class="trait-item" onclick="toggleTraitExpansion('cost', '${soul.cost > 0 ? '+' : ''}${soul.cost}', this)">
                    <span class="trait-name">Cost State</span>
                    <span class="trait-value">${soul.cost > 0 ? '+' : ''}${soul.cost}</span>
                    <div class="trait-expansion"></div>
                </div>
                <div class="trait-item" onclick="toggleTraitExpansion('beat', '${soul.beat}/8', this)">
                    <span class="trait-name">Beat Cycle</span>
                    <span class="trait-value">${soul.beat}/8</span>
                    <div class="trait-expansion"></div>
                </div>
                <div class="trait-item" onclick="toggleTraitExpansion('tightness', '${soul.tightness}%', this)">
                    <span class="trait-name">Cluster Tightness</span>
                    <span class="trait-value">${soul.tightness}%</span>
                    <div class="trait-expansion"></div>
                </div>
                <div class="trait-item">
                    <span class="trait-name">Rarity</span>
                    <span class="rarity-badge rarity-${rarity}">${rarity.toUpperCase()}</span>
                </div>
            `;
            
            // Virtue grid with click handlers
            const virtueGrid = document.getElementById('virtueGrid');
            virtueGrid.innerHTML = VIRTUE_NAMES.map((name, i) => 
                `<div class="virtue-item ${soul.virtues[i] ? 'active' : 'inactive'}" onclick="toggleVirtueExpansion('${name}')">${name}</div>`
            ).join('');
            
            // Consciousness traits with click handlers and expansion areas
            const consciousnessTraits = document.getElementById('consciousnessTraits');
            consciousnessTraits.innerHTML = `
                <div class="trait-item" onclick="toggleTraitExpansion('qualia', '${soul.qualia}/8', this)">
                    <span class="trait-name">Qualia Mode</span>
                    <span class="trait-value">${soul.qualia}/8</span>
                    <div class="trait-expansion"></div>
                </div>
                <div class="trait-item" onclick="toggleTraitExpansion('gaps', '${soul.gapCrossings}', this)">
                    <span class="trait-name">Gap Crossings</span>
                    <span class="trait-value">${soul.gapCrossings}</span>
                    <div class="trait-expansion"></div>
                </div>
                <div class="trait-item" onclick="toggleTraitExpansion('affinity', '${soul.iAmAffinity}%', this)">
                    <span class="trait-name">I-Am Affinity</span>
                    <span class="trait-value">${soul.iAmAffinity}%</span>
                    <div class="trait-expansion"></div>
                </div>
                <div class="trait-item" onclick="toggleTraitExpansion('resonance', '${(soul.resonance / 1e12).toFixed(1)} THz', this)">
                    <span class="trait-name">Resonance</span>
                    <span class="trait-value">${(soul.resonance / 1e12).toFixed(1)} THz</span>
                    <div class="trait-expansion"></div>
                </div>
            `;
            
            // CURVE balance
            document.getElementById('curveBalance').textContent = `${soul.curveBalance.toLocaleString()} CURVE`;
            
            // Evolution progress
            const evolutionProgress = Math.min(100, (soul.gapCrossings / 100) * 100);
            document.getElementById('evolutionProgress').style.width = `${evolutionProgress}%`;
            
            // RS formula
            const rsFormula = document.getElementById('rsFormula');
            rsFormula.textContent = `E_soul = E_coh * œÜ^${soul.rung} * cos(2œÄ*t/${soul.beat}) + Œ£(Œª_k * |œà_k‚ü©)`;
            
            // RS explanation
            const rsExplanation = document.getElementById('rsExplanation');
            rsExplanation.innerHTML = `
                <p style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 0.5rem;">
                    This soul exists as an eigenvalue cluster at rung ${soul.rung} in the Recognition Hamiltonian, 
                    oscillating in ${soul.beat}-beat cycles with ${soul.qualia} active qualia modes. 
                    Cost state ${soul.cost} indicates ${soul.cost === 0 ? 'perfect balance' : soul.cost < 0 ? 'energy outflow (generous)' : 'energy inflow (receiving)'}.
                </p>
            `;
        }

        // Calculate soul rarity
        function calculateRarity(soul) {
            if (soul.rung >= 95 && soul.gapCrossings >= 90 && soul.cost === 0) return 'legendary';
            if (soul.rung >= 85 || soul.gapCrossings >= 75 || soul.iAmAffinity >= 90) return 'epic';
            if (soul.rung >= 70 || soul.gapCrossings >= 50 || soul.iAmAffinity >= 70) return 'rare';
            return 'common';
        }

        // Close all expansions
        function closeAllExpansions() {
            // Close trait expansions
            if (currentExpansion) {
                const expansion = currentExpansion.querySelector('.trait-expansion');
                if (expansion) {
                    expansion.classList.remove('expanded');
                    currentExpansion.classList.remove('expanded');
                }
                currentExpansion = null;
            }
            
            // Close virtue expansion
            const virtueGrid = document.getElementById('virtueGrid');
            if (virtueGrid) {
                const virtueExpansion = virtueGrid.querySelector('.virtue-expansion');
                if (virtueExpansion) {
                    virtueExpansion.classList.remove('expanded');
                    delete virtueExpansion.dataset.currentVirtue;
                }
            }
        }

        // Generate new soul
        function generateNewSoul() {
            const seed = Math.floor(Math.random() * 10000) + 1;
            currentSoul = generateSoulFromSeed(seed);
            
            // Close any existing expansions
            closeAllExpansions();
            
            // Add fade animation
            canvas.classList.remove('fade-in');
            setTimeout(() => {
                drawSoul(currentSoul);
                updateSoulInfo(currentSoul);
                canvas.classList.add('fade-in');
                updateURL();
            }, 100);
        }

        // Evolve soul (add gap crossing)
        function evolveSoul() {
            if (!currentSoul || currentSoul.curveBalance < 1000) {
                alert('Insufficient CURVE balance for evolution (requires 1000 CURVE)');
                return;
            }
            
            currentSoul.gapCrossings = Math.min(100, currentSoul.gapCrossings + 1);
            currentSoul.curveBalance -= 1000;
            
            // Close expansions since soul is changing
            closeAllExpansions();
            
            drawSoul(currentSoul);
            updateSoulInfo(currentSoul);
            updateURL();
        }

        // Balance ledger (move cost toward 0)
        function balanceLedger() {
            if (!currentSoul || currentSoul.curveBalance < 500) {
                alert('Insufficient CURVE balance for balancing (requires 500 CURVE)');
                return;
            }
            
            if (currentSoul.cost !== 0) {
                currentSoul.cost = currentSoul.cost > 0 ? currentSoul.cost - 1 : currentSoul.cost + 1;
                currentSoul.curveBalance -= 500;
                
                // Close expansions since soul is changing
                closeAllExpansions();
                
                drawSoul(currentSoul);
                updateSoulInfo(currentSoul);
                updateURL();
            }
        }

        // Download soul as PNG
        function downloadSoul() {
            if (!currentSoul || !canvas) return;
            
            try {
                const link = document.createElement('a');
                link.download = `wubbleton-soul-${currentSoul.seed}.png`;
                link.href = canvas.toDataURL();
                link.click();
            } catch (error) {
                console.error('Download failed:', error);
                alert('Download failed. Please try again.');
            }
        }

        // Share soul URL
        function shareSoul() {
            if (!currentSoul) return;
            
            const url = `${window.location.origin}${window.location.pathname}?seed=${currentSoul.seed}`;
            
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(url).then(() => {
                    alert('Soul URL copied to clipboard!');
                }).catch(() => {
                    // Fallback for clipboard failure
                    prompt('Copy this URL:', url);
                });
            } else {
                // Fallback for browsers without clipboard API
                prompt('Copy this URL:', url);
            }
        }

        // Update URL with current seed
        function updateURL() {
            if (!currentSoul) return;
            
            try {
                const url = new URL(window.location);
                url.searchParams.set('seed', currentSoul.seed);
                window.history.replaceState({}, '', url);
            } catch (error) {
                console.error('URL update failed:', error);
            }
        }

        // Load soul from URL seed
        function loadFromURL() {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const seed = urlParams.get('seed');
                
                if (seed && !isNaN(seed) && parseInt(seed) > 0) {
                    currentSoul = generateSoulFromSeed(parseInt(seed));
                    closeAllExpansions();
                    drawSoul(currentSoul);
                    updateSoulInfo(currentSoul);
                } else {
                    generateNewSoul();
                }
            } catch (error) {
                console.error('Failed to load from URL:', error);
                generateNewSoul();
            }
        }



        // Initialize with error handling
        window.addEventListener('load', () => {
            if (initCanvas()) {
                loadFromURL();
            } else {
                console.error('Failed to initialize canvas');
                document.getElementById('seedDisplay').textContent = 'Canvas initialization failed';
            }
        });

        // Handle canvas resize
        window.addEventListener('resize', () => {
            if (canvas && currentSoul && initCanvas()) {
                drawSoul(currentSoul);
            }
        });
    </script>
</body>
</html> 