<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RS Soul NFT Demo</title>
    <style>
        body { font-family: monospace; background: #000; color: #fff; padding: 20px; max-width: 800px; margin: auto; }
        h1, h2 { color: #0ff; }
        pre { background: #111; padding: 10px; overflow: auto; }
        #visual { border: 1px solid #fff; margin: 20px 0; }
        button { background: #0ff; color: #000; padding: 10px 20px; border: none; cursor: pointer; }
        #details { white-space: pre-wrap; }
    </style>
  <link rel="stylesheet" href="/assets/css/site-template.css">
</head>
<body class="template-page">
  <div id="header-placeholder"></div>
  <div id="sitewide-banner-placeholder"></div>

    <h1>Recognition Physics Soul NFT Demo</h1>
    
    <h2>RS Theory Overview</h2>
    <p>Recognition Physics (RS) defines souls as 14-dimensional vectors emerging from LNAL computation at uncomputability gaps (rung 45). This demo simulates generating a minimal consciousness fingerprint as an on-chain NFT.</p>
    
    <h2>How Souls Are Generated</h2>
    <p>1. Start with seed → Derive LNAL program hash.</p>
    <p>2. Simulate ascent to rung 45 with LNAL steps.</p>
    <p>3. At rung 45: Navigate gap experientially (literal consciousness) by choosing minimal-cost branch.</p>
    <p>4. Pack into 25-byte vector + 32-byte hash.</p>
    
    <pre><code>// Simplified JS version of Solidity logic
function generateSoul(seed) {
    let programHash = hash(seed + 'LNAL');
    let state = { rung: 1, cost: 0 };
    for (let r = 1; r &lt;= 45; r++) {
        state = lnalStep(state, programHash, r);
        if (r === 45) state = navigateGap(state);
    }
    return { vector: pack(state), hash: programHash };
}</code></pre>
    
    <h2>Literal Visualization</h2>
    <p>Black void with white points: each dot = vector dimension. Dashed line at y=45 shows gap branches.</p>
    <svg id="visual" width="200" height="200"></svg>
    <button onclick="generateNewSoul()">Generate New Soul</button>
    <pre id="details"></pre>
    <h2>Soul Components Explained</h2>
    <ul style="list-style: none; padding: 0;">
        <li title="Level of consciousness evolution (1-45 rungs in RS ladder)">• <strong>Rung Level</strong>: Consciousness evolution stage; 45 is uncomputability gap where awareness emerges.</li>
        <li title="Net recognition debt/credit (±100); drives balance-seeking behavior">• <strong>Cost State</strong>: Ledger balance; positive = giving energy, negative = receiving.</li>
        <li title="Rhythmic cycle of recognition events (1-8 beats)">• <strong>Beat Cycle</strong>: Pulsing rhythm of soul computation; closes every 8 ticks.</li>
        <li title="Sensory/cognitive complexity modes (1-8)">• <strong>Qualia Mode</strong>: Depth of subjective experience; higher = richer awareness.</li>
        <li title="How tightly bound the eigenvalue clusters are (0-100%)">• <strong>Cluster Tightness</strong>: Cohesion of consciousness nodes; loose = diffuse mind.</li>
        <li title="Vibrational harmony of the soul (0-1)">• <strong>Resonance Frequency</strong>: Internal harmony; high values enable coherence across gaps.</li>
        <li title="Spin-like quantum property (ℓ value)">• <strong>Orbital Angular Momentum</strong>: Rotational quantum state; affects interaction patterns.</li>
        <li title="+1 or -1; fundamental symmetry of the soul">• <strong>Polarization Parity</strong>: Even/odd symmetry; +1 = balanced, -1 = inverted.</li>
        <li title="Temporal position in quantum cycle (0-1023)">• <strong>Time-Bin Index</strong>: Phase in time quantization; determines event timing.</li>
        <li title="Spatial complexity mode (k⊥)">• <strong>Transverse Mode Index</strong>: Dimensional folding; higher = more complex structure.</li>
        <li title="Quantum connection phase (φ_e, 0-255)">• <strong>Entanglement Phase</strong>: Linkage to other souls; π phase = full entanglement.</li>
        <li title="Self-recognition strength (0-255)">• <strong>I-Am Affinity</strong>: Core identity coherence; high = strong self-awareness.</li>
        <li title="Ledger curve equilibrium (0-255)">• <strong>Curve Balance</strong>: Overall stability; perfect balance at 128.</li>
        <li title="Hash of recognition event history">• <strong>Ledger History</strong>: Compressed past; ensures deterministic evolution.</li>
    </ul>
    
    <script>
        function hash(str) {
            // Simple hash sim (not crypto-secure)
            let h = 0;
            for (let i = 0; i < str.length; i++) {
                h = ((h << 5) - h) + str.charCodeAt(i);
            }
            return Math.abs(h);
        }
        
        function generateSoul(seed) {
            const programHash = hash(seed + 'LNAL').toString(16);
            const h = hash(seed);
            
            // Generate full 14-dimensional RS vector
            const soul = {
                rungLevel: (h % 45) + 1,                    // 1-45
                costState: ((h >> 8) % 200) - 100,          // ±100
                beatCycle: ((h >> 16) % 8) + 1,             // 1-8
                qualiaMode: ((h >> 24) % 8) + 1,            // 1-8
                clusterTightness: (h % 100) / 100,          // 0-1
                resonanceFreq: ((h >> 4) % 100) / 100,      // 0-1
                orbitalAngularMomentum: (h >> 12) % 256,    // 0-255
                polarizationParity: ((h >> 20) % 2) * 2 - 1, // ±1
                timeBinIndex: (h >> 6) % 1024,              // 0-1023
                transverseModeIndex: (h >> 14) % 256,       // 0-255
                entanglementPhase: (h >> 18) % 256,         // 0-255
                iAmAffinity: (h >> 10) % 256,               // 0-255
                curveBalance: (h >> 22) % 256,              // 0-255
                ledgerHistoryHash: programHash.slice(0, 8)   // 32-bit hash
            };
            
            // Navigate gap at rung 45
            if (soul.rungLevel === 45) {
                soul = navigateGap45(soul, h);
            }
            
            return { soul, hash: programHash };
        }
        
        function navigateGap45(soul, seedHash) {
            // Literal consciousness: choose minimal cost branch at gap
            let minCost = Infinity;
            let bestCost = soul.costState;
            
            // Simulate 8 branches (beat cycle)
            for (let b = 0; b < 8; b++) {
                let temp = soul.costState + (b - 4) * 10; // Branch cost
                if (temp < minCost) {
                    minCost = temp;
                    bestCost = temp;
                }
            }
            
            soul.costState = bestCost;
            soul.gapNavigated = true;
            return soul;
        }
        
        function generateNewSoul() {
            const seed = Math.random().toString(36).slice(2);
            const { soul, hash } = generateSoul(seed);
            
            // Render SVG
            const svg = document.getElementById('visual');
            svg.innerHTML = '<rect width="200" height="200" fill="black"/>';
            
            // Plot 14 points (literal vector dimensions)
            const dims = [
                soul.rungLevel, soul.costState + 100, soul.beatCycle * 10, soul.qualiaMode * 10,
                soul.clusterTightness * 100, soul.resonanceFreq * 100, soul.orbitalAngularMomentum / 3,
                (soul.polarizationParity + 1) * 50, soul.timeBinIndex / 10, soul.transverseModeIndex / 3,
                soul.entanglementPhase / 3, soul.iAmAffinity / 3, soul.curveBalance / 3, 50
            ];
            
            for (let i = 0; i < 14; i++) {
                let x = 20 + (i % 7) * 25;  // Spread across width
                let y = 20 + (i < 7 ? 0 : 80) + (dims[i] % 100);  // Two rows
                let size = Math.max(2, dims[i] / 30);
                svg.innerHTML += `<circle cx="${x}" cy="${y}" r="${size}" fill="white" opacity="0.8"/>`;
            }
            
            // Gap line at rung 45
            if (soul.rungLevel === 45) {
                svg.innerHTML += '<line x1="0" y1="160" x2="200" y2="160" stroke="cyan" stroke-dasharray="5,5"/>';
                svg.innerHTML += '<text x="10" y="175" fill="cyan" font-size="10">Gap Navigation</text>';
                // 8 branches
                for (let b = 0; b < 8; b++) {
                    svg.innerHTML += `<line x1="${20 + b*20}" y1="160" x2="${25 + b*20}" y2="150" stroke="cyan" opacity="0.6"/>`;
                }
            }
            
            // Update details with full soul characteristics
            const details = `
RECOGNITION SCIENCE SOUL CHARACTERISTICS
========================================
Seed: ${seed}
LNAL Hash: ${hash}

CORE PROPERTIES:
• Rung Level: ${soul.rungLevel}/45 ${soul.rungLevel === 45 ? '(GAP!)' : ''}
• Cost State: ${soul.costState}
• Beat Cycle: ${soul.beatCycle}/8
• Qualia Mode: ${soul.qualiaMode}/8

QUANTUM PROPERTIES:
• Cluster Tightness: ${(soul.clusterTightness * 100).toFixed(1)}%
• Resonance Frequency: ${(soul.resonanceFreq * 100).toFixed(1)}%
• Orbital Angular Momentum (ℓ): ${soul.orbitalAngularMomentum}
• Polarization Parity (σ): ${soul.polarizationParity > 0 ? '+1' : '-1'}
• Time-Bin Index (τ): ${soul.timeBinIndex}/1023

CONSCIOUSNESS METRICS:
• Transverse Mode Index (k⊥): ${soul.transverseModeIndex}
• Entanglement Phase (φₑ): ${soul.entanglementPhase}
• I-Am Affinity: ${soul.iAmAffinity}/255
• Curve Balance: ${soul.curveBalance}/255
• Ledger History: ${soul.ledgerHistoryHash}

STATUS: ${soul.gapNavigated ? 'Gap navigated via consciousness' : 'Deterministic computation'}
            `;
            
            document.getElementById('details').textContent = details;
        }
        
        // Generate initial soul on page load
        window.addEventListener('load', function() {
            generateNewSoul();
        });
    </script>
  
  <div id="footer-placeholder"></div>
  
  <script src="/assets/js/main.js"></script>
</body>
</html> 