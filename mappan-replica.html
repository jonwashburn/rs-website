<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapan Replica Generator</title>
    <style>
        body { background: #f5f5f7; display: flex; flex-direction: column; align-items: center; padding: 2em; }
        h1 { font-family: monospace; font-size: 2em; margin-bottom: 1em; }
        button { background: #007AFF; color: white; border: none; padding: 1em 2em; font-size: 1.2em; border-radius: 8px; cursor: pointer; margin-bottom: 2em; }
        button:hover { background: #0056CC; }
        canvas { border: 2px solid black; border-radius: 8px; background: white; }
        a { margin-top: 1em; color: #007AFF; text-decoration: none; }
    </style>
</head>
<body>
    <h1>Mapan Sketchbook B Replica Generator</h1>
    <button onclick="generateImage()">Generate New Replica</button>
    <canvas id="canvas" width="1024" height="1024"></canvas>
    <a id="download" href="#" download="mappan-replica.png">Download Image</a>

    <script>
        const SIZE = 1024;
        
        // Color palettes based on Mappan's works
        const PALETTES = [
            { bg: '#D32F2F', stripes: ['#1976D2', '#FF9800', '#FFC107', '#2196F3', '#FF5722', '#FFEB3B'], arrow: '#000000' },
            { bg: '#1976D2', stripes: ['#D32F2F', '#FFC107', '#FF9800', '#E91E63', '#FF5722', '#F44336'], arrow: '#000000' },
            { bg: '#F57C00', stripes: ['#303F9F', '#FFEB3B', '#1976D2', '#FFC107', '#2196F3', '#FF9800'], arrow: '#000000' },
            { bg: '#4CAF50', stripes: ['#FFEB3B', '#F57C00', '#FFC107', '#FF9800', '#FF5722', '#E91E63'], arrow: '#000000' }
        ];
        
        // Simple seeded random
        function seededRand(seed) {
            seed = (seed * 9301 + 49297) % 233280;
            return seed / 233280;
        }
        
        // Add subtle canvas texture
        function addTexture(ctx) {
            const imageData = ctx.getImageData(0, 0, SIZE, SIZE);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const noise = (Math.random() - 0.5) * 20;
                data[i] += noise;
                data[i+1] += noise;
                data[i+2] += noise;
            }
            ctx.putImageData(imageData, 0, 0);
        }
        
        // Draw rotated rectangle (for stripes)
        function drawRotatedRect(ctx, x, y, w, h, angle, color) {
            ctx.save();
            ctx.translate(x + w/2, y + h/2);
            ctx.rotate(angle * Math.PI / 180);
            ctx.fillStyle = color;
            ctx.fillRect(-w/2, -h/2, w, h);
            ctx.restore();
        }
        
        // Draw chevron/arrow shape
        function drawChevron(ctx, x, y, size, color, angle) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle * Math.PI / 180);
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(-size/2, 0);
            ctx.lineTo(0, -size/2);
            ctx.lineTo(size/2, 0);
            ctx.lineTo(0, size/2);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }
        
        function generateImage() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const seed = Math.random() * 10000;
            
            // Select palette
            const palette = PALETTES[Math.floor(seededRand(seed) * PALETTES.length)];
            
            // Solid background
            ctx.fillStyle = palette.bg;
            ctx.fillRect(0, 0, SIZE, SIZE);
            
            // Composition area (rectangular zone like Mappan)
            const zoneX = SIZE * (0.1 + seededRand(seed+1) * 0.3);
            const zoneY = SIZE * (0.1 + seededRand(seed+2) * 0.3);
            const zoneW = SIZE * (0.4 + seededRand(seed+3) * 0.4);
            const zoneH = SIZE * (0.5 + seededRand(seed+4) * 0.3);
            
            // Base angle for diagonals
            const baseAngle = -45 + seededRand(seed+5) * 90; // Around 45 degrees diagonal
            
            // Draw stripes
            const stripeCount = 5 + Math.floor(seededRand(seed+6) * 3);
            const stripeHeight = zoneH * 1.2; // Slightly taller
            const stripeSpacing = zoneW / (stripeCount - 1);
            
            for (let i = 0; i < stripeCount; i++) {
                const color = palette.stripes[i % palette.stripes.length];
                const width = (zoneW / stripeCount) * (0.8 + seededRand(seed+10+i) * 0.4);
                const x = zoneX + i * stripeSpacing;
                const y = zoneY - zoneH * 0.1;
                drawRotatedRect(ctx, x, y, width, stripeHeight, baseAngle, color);
            }
            
            // Draw chevron/arrow
            const chevX = zoneX + zoneW * (0.3 + seededRand(seed+20) * 0.4);
            const chevY = zoneY + zoneH * (0.3 + seededRand(seed+21) * 0.4);
            const chevSize = Math.min(zoneW, zoneH) * (0.3 + seededRand(seed+22) * 0.4);
            const chevAngle = baseAngle + seededRand(seed+23) * 180;
            drawChevron(ctx, chevX, chevY, chevSize, palette.arrow, chevAngle);
            
            // Add texture
            addTexture(ctx);
            
            // Update download
            document.getElementById('download').href = canvas.toDataURL('image/png');
        }
        
        generateImage(); // Initial
    </script>
</body>
</html> 