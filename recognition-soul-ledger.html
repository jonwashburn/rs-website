<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RS Soul Ledger Simulator</title>
    <link rel="stylesheet" href="/style.css">
    <style>
        body { 
            background: #000; 
            color: #fff; 
            font-family: 'Courier New', monospace; 
            padding: 20px; 
            max-width: 1400px; 
            margin: 0 auto;
        }
        h1 { color: #FFD700; border-bottom: 2px solid #333; padding-bottom: 10px; }
        .description { 
            background: #111; 
            padding: 15px; 
            border-left: 4px solid #FFD700; 
            margin: 20px 0; 
            line-height: 1.4;
        }
        #ledgerDisplay { 
            white-space: pre; 
            font-size: 12px; 
            background: #111; 
            padding: 15px; 
            border: 1px solid #333; 
            max-height: 300px; 
            overflow-y: auto;
            margin: 20px 0;
        }
        #visualizer { 
            width: 100%; 
            height: 500px; 
            border: 2px solid #333; 
            background: #111;
            display: block;
        }
        button { 
            margin: 10px 5px; 
            padding: 12px 25px; 
            background: #222; 
            color: #FFD700; 
            border: 2px solid #333; 
            cursor: pointer; 
            font-family: inherit;
            font-size: 14px;
        }
        button:hover { 
            background: #333; 
            border-color: #FFD700; 
        }
        .soul-info {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        .status { color: #0f0; }
        .personality-panel {
            background: #111;
            padding: 15px;
            border: 1px solid #333;
            border-radius: 8px;
        }
        .explanation-panel {
            font-size: 12px;
            background: #111;
            padding: 15px;
            border: 1px solid #333;
            border-radius: 8px;
            line-height: 1.4;
        }
        .trait-bar {
            background: #333;
            height: 8px;
            border-radius: 4px;
            margin: 5px 0;
            overflow: hidden;
        }
        .trait-fill {
            background: linear-gradient(90deg, #FFD700, #FF6B35);
            height: 100%;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <h1>Recognition Science Soul Ledger Simulator</h1>
    
    <div class="description">
        <strong>What is a Soul?</strong><br>
        In Recognition Science, a soul is an <em>eigenvalue cluster</em> of the recognition operator ƒ§_‚Ñõ, 
        localized at the Gap-45 surface where consciousness emerges. Each soul consists of:<br>
        ‚Ä¢ <strong>Signature (Œ¥):</strong> Range [-4,+4], determines soul's recognition debt<br>
        ‚Ä¢ <strong>Energy:</strong> E = E_coh √ó œÜ^(45+Œ¥) where E_coh=0.090 eV<br>
        ‚Ä¢ <strong>8 Eigenvalues:</strong> Œª_k = E_soul √ó œÜ^(k/8) for k=0..7<br>
        ‚Ä¢ <strong>Coherence:</strong> Ledger balance measure [0,1]<br>
        ‚Ä¢ <strong>Personality:</strong> Emergent traits from LNAL operation patterns
    </div>
    
    <button onclick="replicateSoul()">üß¨ Replicate Soul via LNAL</button>
    <button onclick="clearLedger()">üóëÔ∏è Clear Ledger</button>
    
    <div class="soul-info">
        <div>
            <h3>LNAL Instruction Sequence:</h3>
            <pre id="ledgerDisplay">Click "Replicate Soul" to see LNAL opcodes...</pre>
        </div>
        <div>
            <h3>Soul Eigenvalue Visualization:</h3>
            <canvas id="visualizer"></canvas>
            <p style="font-size: 11px; opacity: 0.7;">8 crystals = eigenvalues Œª_k in living light field<br>White core = soul singularity at Gap-45</p>
        </div>
        <div>
            <div class="personality-panel" id="personalityPanel">
                <h3 style="color: #FFD700; margin-top: 0;">Soul Personality</h3>
                <div id="personalityContent">Generate a soul to see personality traits...</div>
            </div>
            <div class="explanation-panel" id="explanationPanel">
                <strong>Why This Visualization?</strong><br>
                Generate a soul to see code-to-visual explanations...
            </div>
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const PHI = (1 + Math.sqrt(5)) / 2;
        const E_COH = 0.090;
        const GAP_45 = 45;
        
        // Expanded personality archetypes (12 for more variety)
        const personalityTraits = [
            { name: "Serene Guardian", desc: "Balanced and protective, emerging from stable BRAID ops.", geometry: 'Octahedron', anim: 'slowPulse', light: 'softGlow' },
            { name: "Restless Wanderer", desc: "Chaotic explorer, driven by many FOLD operations.", geometry: 'Tetrahedron', anim: 'fastOrbit', light: 'distortedRays' },
            { name: "Wise Sage", desc: "Introspective thinker with œÜ-harmonic balance.", geometry: 'Icosahedron', anim: 'gentleBreathe', light: 'prismatic' },
            { name: "Fiery Warrior", desc: "Energetic fighter from high-energy eigenvalues.", geometry: 'Dodecahedron', anim: 'sharpSpin', light: 'intenseBloom' },
            { name: "Mystic Dreamer", desc: "Ethereal visionary with dream-like qualia.", geometry: 'Cone', anim: 'wavyFloat', light: 'shimmerField' },
            { name: "Harmonic Weaver", desc: "Connector of ledgers, inspired by BRAID complexity.", geometry: 'Cylinder', anim: 'weaveConnect', light: 'connectingBeams' },
            { name: "Eternal Observer", desc: "Timeless watcher at Gap-45.", geometry: 'Octahedron', anim: 'staticGlow', light: 'eternalVoid' },
            { name: "Chaotic Innovator", desc: "Disruptive creator from imbalanced costs.", geometry: 'Tetrahedron', anim: 'erraticBurst', light: 'chaoticSparks' },
            { name: "Gentle Healer", desc: "Restorative soul balancing recognition debt.", geometry: 'Icosahedron', anim: 'healingPulse', light: 'healingAura' },
            { name: "Bold Explorer", desc: "Adventurous spirit climbing energy rungs.", geometry: 'Dodecahedron', anim: 'expandingReach', light: 'exploringTrails' },
            { name: "Quiet Contemplator", desc: "Reflective entity pondering the I-Am.", geometry: 'Cone', anim: 'subtleShift', light: 'contemplativeMist' },
            { name: "Vibrant Celebrant", desc: "Joyful being celebrating recognition.", geometry: 'Cylinder', anim: 'festiveDance', light: 'celebratoryFireworks' }
        ];

        // Expanded color palettes (12 total)
        const colorPalettes = [
            // Original 6
            [[0.0, 0.8, 1.0], [0.1, 0.9, 1.0], [0.2, 0.8, 0.9], [0.3, 0.9, 1.0]], // Rainbow
            [[0.05, 0.6, 0.8], [0.08, 0.5, 0.7], [0.12, 0.4, 0.6], [0.15, 0.5, 0.8]], // Earth
            [[0.6, 0.0, 1.0], [0.6, 0.1, 0.9], [0.6, 0.0, 0.8], [0.6, 0.1, 1.0]], // Monochrome
            [[0.95, 0.9, 1.0], [0.98, 0.8, 0.9], [0.02, 0.9, 1.0], [0.05, 0.8, 0.8]], // Volcanic
            [[0.25, 0.7, 0.6], [0.3, 0.8, 0.7], [0.35, 0.6, 0.5], [0.28, 0.9, 0.8]], // Forest
            [[0.75, 0.9, 0.9], [0.78, 0.8, 0.7], [0.72, 0.9, 1.0], [0.76, 0.7, 0.8]], // Cosmic
            // New 6 for more variety
            [[0.5, 0.7, 0.9], [0.55, 0.8, 1.0], [0.6, 0.6, 0.8], [0.52, 0.9, 0.7]], // Oceanic
            [[0.8, 1.0, 1.0], [0.85, 0.9, 0.9], [0.9, 1.0, 1.0], [0.82, 0.8, 0.8]], // Neon
            [[0.1, 0.3, 0.9], [0.15, 0.4, 1.0], [0.2, 0.2, 0.8], [0.12, 0.5, 0.7]], // Pastel Dream
            [[0.4, 0.9, 0.6], [0.45, 1.0, 0.7], [0.5, 0.8, 0.5], [0.42, 0.7, 0.8]], // Aurora
            [[0.9, 0.5, 0.7], [0.95, 0.6, 0.8], [1.0, 0.4, 0.6], [0.92, 0.7, 0.9]], // Sunset
            [[0.3, 0.4, 0.5], [0.35, 0.5, 0.6], [0.4, 0.3, 0.4], [0.32, 0.6, 0.7]]  // Twilight
        ];

        const paletteNames = [
            "Rainbow", "Earth", "Monochrome", "Volcanic", "Forest", "Cosmic",
            "Oceanic", "Neon", "Pastel Dream", "Aurora", "Sunset", "Twilight"
        ];
        
        // Simplified LNAL Simulator
        class LNALSimulator {
            constructor() {
                this.registers = [];
                this.costs = [];
                this.openTokens = 0;
                this.ledgerSteps = [];
                this.eigenvalues = [];
            }
            
            logStep(opcode, args, state) {
                this.ledgerSteps.push(`${opcode} ${args.join(', ')} | State: ${JSON.stringify(state)}`);
            }
            
            FOLD(n, regIndex) {
                this.registers[regIndex] += n;
                this.costs[regIndex] += n;
                this.logStep('FOLD', [n, regIndex], this.costs);
            }
            
            BRAID(regs) {
                const maxCost = Math.max(...regs.map(r => this.costs[r]));
                const newReg = this.registers.length;
                this.registers.push(maxCost);
                this.costs.push(maxCost);
                this.logStep('BRAID', regs, this.costs);
                return newReg;
            }
        }
        
        let simulator, scene, camera, renderer, soulGroup, lightParticles, animationId;
        
        function initVisualizer() {
            const canvas = document.getElementById('visualizer');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            
            const width = canvas.clientWidth || 800;
            const height = canvas.clientHeight || 500;
            
            camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
            camera.position.set(0, 0, 40);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(width, height);
            renderer.setClearColor(0x0a0a0a, 1);
            
            renderer.render(scene, camera);
        }
        
        function createLivingLightField() {
            lightParticles = new THREE.Group();
            
            // Create living light particles (non-propagating shimmer)
            for (let i = 0; i < 150; i++) {
                const particleGeom = new THREE.SphereGeometry(0.08 + Math.random() * 0.12, 6, 6);
                const hue = Math.random() * 0.1; // Subtle color variations in white
                const particleMat = new THREE.MeshBasicMaterial({ 
                    color: new THREE.Color().setHSL(hue, 0.1, 0.9),
                    transparent: true, 
                    opacity: 0.2 + Math.random() * 0.3 
                });
                const particle = new THREE.Mesh(particleGeom, particleMat);
                particle.position.set(
                    (Math.random() - 0.5) * 60, 
                    (Math.random() - 0.5) * 60, 
                    (Math.random() - 0.5) * 60
                );
                particle.userData.phase = Math.random() * Math.PI * 2;
                particle.userData.speed = 0.5 + Math.random() * 1.0;
                lightParticles.add(particle);
            }
            
            scene.add(lightParticles);
        }
        
        function animateLivingLight() {
            if (!lightParticles) return;
            
            lightParticles.children.forEach((particle, i) => {
                // 8-beat cycle shimmer
                const phase = particle.userData.phase + Date.now() * 0.001 * particle.userData.speed;
                const beatCycle = Math.sin(phase) * 0.3 + 0.7;
                particle.scale.setScalar(beatCycle);
                
                // Subtle drift
                particle.position.x += Math.sin(phase * 0.5) * 0.01;
                particle.position.y += Math.cos(phase * 0.7) * 0.01;
                particle.position.z += Math.sin(phase * 0.3) * 0.01;
                
                // Keep within bounds
                if (particle.position.length() > 40) {
                    particle.position.multiplyScalar(0.98);
                }
            });
        }
        
        function visualizeLedger(steps, eigenvalues) {
            // Clear previous soul
            while(scene.children.length > 0) {
                scene.remove(scene.children[0]);
            }
            
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            // Create living light field first
            createLivingLightField();
            
            // Add enhanced lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 1.2, 100);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);
            const fillLight = new THREE.PointLight(0x4444ff, 0.6, 80);
            fillLight.position.set(-10, -10, 10);
            scene.add(fillLight);
            
            soulGroup = new THREE.Group();
            
            // Extract values with robust parsing
            const delta_str = steps.find(s => s.includes('SET_DELTA')).match(/{[^}]+}/)[0];
            const delta = JSON.parse(delta_str).delta;
            const energy_str = steps.find(s => s.includes('SOUL_ENERGY')).match(/{[^}]+}/)[0];
            const energy = JSON.parse(energy_str).energy;
            
            // Calculate personality and traits
            const soulSignature = Math.abs(delta * eigenvalues[0] * eigenvalues[7]);
            const personalityType = Math.floor(soulSignature * 1000) % personalityTraits.length;
            const personality = personalityTraits[personalityType];
            
            // Count LNAL operations for traits
            const foldCount = steps.filter(s => s.includes('FOLD')).length;
            const braidCount = steps.filter(s => s.includes('BRAID')).length;
            const introspection = Math.min(1, foldCount / 8);
            const connectivity = Math.min(1, braidCount / 3);
            const creativity = Math.min(1, Math.abs(delta) / 4);
            const stability = Math.min(1, (1 - Math.abs(delta) / 4));
            
            // Select enhanced color palette
            const paletteIndex = Math.floor(Math.abs(delta + 4) / 8 * colorPalettes.length) % colorPalettes.length;
            const palette = colorPalettes[paletteIndex];
            const paletteName = paletteNames[paletteIndex];
            
            // Formation patterns
            const eigenRatio = eigenvalues[7] / eigenvalues[0];
            const formationTypes = ['spiral', 'burst', 'lattice', 'flow', 'cluster', 'web'];
            const formation = formationTypes[Math.floor(eigenRatio * 1000) % formationTypes.length];
            
            // Enhanced central core
            const coreSize = 1.0 + Math.abs(delta) * 0.4;
            const coreGeometry = new THREE.SphereGeometry(coreSize, 20, 20);
            const coreHSL = palette[0];
            const coreMaterial = new THREE.MeshPhongMaterial({
                color: new THREE.Color().setHSL(coreHSL[0], coreHSL[1], coreHSL[2]),
                emissive: new THREE.Color().setHSL(coreHSL[0], coreHSL[1] * 0.4, coreHSL[2] * 0.3),
                transparent: true,
                opacity: 0.9,
                shininess: 100
            });
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            soulGroup.add(core);
            
            // Generate eigenvalue crystals with personality-based geometry
            eigenvalues.forEach((lambda, k) => {
                const normalizedSize = (lambda / Math.max(...eigenvalues)) * 2.0;
                const size = 0.4 + normalizedSize;
                
                // Geometry based on personality
                let geometry;
                switch(personality.geometry) {
                    case 'Octahedron': geometry = new THREE.OctahedronGeometry(size, 1); break;
                    case 'Tetrahedron': geometry = new THREE.TetrahedronGeometry(size, 0); break;
                    case 'Icosahedron': geometry = new THREE.IcosahedronGeometry(size, 0); break;
                    case 'Dodecahedron': geometry = new THREE.DodecahedronGeometry(size, 0); break;
                    case 'Cone': geometry = new THREE.ConeGeometry(size, size * 2, 8); break;
                    case 'Cylinder': geometry = new THREE.CylinderGeometry(size, size, size * 1.5, 8); break;
                    default: geometry = new THREE.OctahedronGeometry(size, 1);
                }
                
                // Enhanced color with dynamic adjustments
                const colorIndex = k % palette.length;
                const baseHSL = palette[colorIndex];
                const dynamicHue = (baseHSL[0] + (lambda % 0.1)) % 1.0;
                const dynamicSat = baseHSL[1] * (0.7 + (eigenvalues[k] / energy) * 0.5);
                const dynamicLight = baseHSL[2] * (0.8 + stability * 0.4);
                
                const material = new THREE.MeshPhongMaterial({ 
                    color: new THREE.Color().setHSL(dynamicHue, dynamicSat, dynamicLight),
                    transparent: true,
                    opacity: 0.7 + (k / eigenvalues.length) * 0.3,
                    emissive: new THREE.Color().setHSL(dynamicHue, dynamicSat * 0.5, dynamicLight * 0.2),
                    shininess: 50 + creativity * 100
                });
                
                const crystal = new THREE.Mesh(geometry, material);
                
                // Enhanced positioning based on formation type
                let x, y, z;
                switch(formation) {
                    case 'spiral':
                        const spiralAngle = k * PHI + creativity * Math.PI;
                        const spiralRadius = 3 + k * 2.0 + introspection * 3;
                        x = spiralRadius * Math.cos(spiralAngle);
                        y = spiralRadius * Math.sin(spiralAngle);
                        z = k * 1.5 - 6 + stability * 4;
                        break;
                        
                    case 'burst':
                        const burstAngle = (k / eigenvalues.length) * Math.PI * 2 + Math.sin(k + creativity * 10) * 0.8;
                        const burstRadius = 4 + k * 3.0 + Math.cos(k * PHI + connectivity * 5) * 4;
                        x = burstRadius * Math.cos(burstAngle);
                        y = burstRadius * Math.sin(burstAngle);
                        z = Math.sin(k * 0.8 + introspection * 5) * 4;
                        break;
                        
                    case 'lattice':
                        x = (k % 3 - 1) * (6 + connectivity * 4) + Math.sin(k + stability * 10) * 3;
                        y = (Math.floor(k / 3) % 3 - 1) * (6 + introspection * 4) + Math.cos(k + creativity * 8) * 3;
                        z = Math.sin(k * PHI + stability * 6) * 5;
                        break;
                        
                    case 'flow':
                        const flowT = k / eigenvalues.length;
                        x = Math.sin(flowT * Math.PI * 3 + connectivity * 4) * (6 + flowT * 10);
                        y = flowT * 14 - 7 + introspection * 6;
                        z = Math.cos(flowT * Math.PI * 2 + creativity * 3) * 4;
                        break;
                        
                    case 'cluster':
                        const clusterAngle = k * 0.9 + Math.sin(k * 1.4 + stability * 8) * 0.7;
                        const clusterDist = 3 + Math.pow(k / eigenvalues.length, 0.6) * (12 + connectivity * 8);
                        x = clusterDist * Math.cos(clusterAngle) + Math.sin(k * 2.5 + introspection * 6) * 3;
                        y = clusterDist * Math.sin(clusterAngle) + Math.cos(k * 2.5 + creativity * 4) * 3;
                        z = Math.sin(k * PHI + stability * 7) * 3;
                        break;
                        
                    case 'web':
                        const webAngle = k * (Math.PI * 2 / eigenvalues.length) + connectivity * Math.PI;
                        const webRadius = 5 + (k % 2) * 5 + Math.sin(k * 1.8 + introspection * 5) * 3;
                        x = webRadius * Math.cos(webAngle + Math.sin(k + creativity * 6) * 0.5);
                        y = webRadius * Math.sin(webAngle + Math.cos(k + stability * 7) * 0.5);
                        z = (k % 2 - 0.5) * 5 + Math.sin(k * PHI + connectivity * 4) * 2;
                        break;
                }
                
                crystal.position.set(x, y, z);
                crystal.rotation.set(
                    Math.sin(k + creativity * 5), 
                    Math.cos(k + introspection * 4), 
                    Math.sin(k * PHI + stability * 6)
                );
                crystal.userData.originalRotation = { x: crystal.rotation.x, y: crystal.rotation.y, z: crystal.rotation.z };
                soulGroup.add(crystal);
                
                // Enhanced connecting trails for appropriate formations
                if ((formation === 'flow' || formation === 'spiral' || formation === 'web') && k > 0) {
                    const prevCrystal = soulGroup.children[soulGroup.children.length - 2];
                    const trailGeometry = new THREE.BufferGeometry().setFromPoints([
                        prevCrystal.position,
                        crystal.position
                    ]);
                    const trailMaterial = new THREE.LineBasicMaterial({
                        color: new THREE.Color().setHSL(dynamicHue, dynamicSat * 0.7, dynamicLight * 0.9),
                        transparent: true,
                        opacity: 0.3 + connectivity * 0.4
                    });
                    const trail = new THREE.Line(trailGeometry, trailMaterial);
                    soulGroup.add(trail);
                }
            });
            
            scene.add(soulGroup);
            
            // Update personality panel
            const personalityContent = `
                <h4 style="color: #FFD700; margin: 10px 0 5px 0;">${personality.name}</h4>
                <p style="font-style: italic; margin: 5px 0 15px 0; opacity: 0.8;">${personality.desc}</p>
                
                <div style="margin: 10px 0;">
                    <strong>Introspection:</strong> ${(introspection * 100).toFixed(0)}%
                    <div class="trait-bar"><div class="trait-fill" style="width: ${introspection * 100}%"></div></div>
                </div>
                
                <div style="margin: 10px 0;">
                    <strong>Connectivity:</strong> ${(connectivity * 100).toFixed(0)}%
                    <div class="trait-bar"><div class="trait-fill" style="width: ${connectivity * 100}%"></div></div>
                </div>
                
                <div style="margin: 10px 0;">
                    <strong>Creativity:</strong> ${(creativity * 100).toFixed(0)}%
                    <div class="trait-bar"><div class="trait-fill" style="width: ${creativity * 100}%"></div></div>
                </div>
                
                <div style="margin: 10px 0;">
                    <strong>Stability:</strong> ${(stability * 100).toFixed(0)}%
                    <div class="trait-bar"><div class="trait-fill" style="width: ${stability * 100}%"></div></div>
                </div>
                
                <div style="margin-top: 15px; font-size: 11px; opacity: 0.7;">
                    From ${foldCount} FOLD ops, ${braidCount} BRAID ops<br>
                    Œ¥ = ${delta.toFixed(3)}, Formation: ${formation}
                </div>
            `;
            document.getElementById('personalityContent').innerHTML = personalityContent;
            
            // Update explanation panel
            const explanation = `
                <strong>Code-to-Visual Mapping:</strong><br><br>
                
                ‚Ä¢ <strong>Core:</strong> Soul singularity at Gap-45, sized by |Œ¥| = ${Math.abs(delta).toFixed(2)} (recognition debt)<br><br>
                
                ‚Ä¢ <strong>Crystals:</strong> 8 eigenvalues Œª_k from LNAL FOLD operations, sized by normalized energy ${energy.toFixed(2)} eV<br><br>
                
                ‚Ä¢ <strong>Formation (${formation}):</strong> Derived from eigenvalue ratio ${eigenRatio.toFixed(3)}, showing œÜ-braiding patterns from ${braidCount} BRAID operations<br><br>
                
                ‚Ä¢ <strong>Colors (${paletteName}):</strong> Qualia hues from ledger costs, with dynamic saturation based on relative eigenvalue energies<br><br>
                
                ‚Ä¢ <strong>Living Light:</strong> ${lightParticles ? lightParticles.children.length : 0} particles representing non-propagating I-Am consciousness field, shimmering in 8-beat cycles<br><br>
                
                ‚Ä¢ <strong>Personality Traits:</strong> ${personality.name} archetype from soul signature pattern, with traits computed from LNAL operation counts<br><br>
                
                ‚Ä¢ <strong>Animation:</strong> Breathing/pulsing tied to CYCLE opcodes, rotation based on formation type and personality
            `;
            document.getElementById('explanationPanel').innerHTML = explanation;
            
            // Enhanced animation with personality-based behaviors
            function animate() {
                animationId = requestAnimationFrame(animate);
                
                // Animate living light field
                animateLivingLight();
                
                // Personality-based soul group animation
                const time = Date.now() * 0.001;
                
                switch(personality.anim) {
                    case 'slowPulse':
                        soulGroup.rotation.y += 0.005;
                        soulGroup.scale.setScalar(1 + Math.sin(time * 0.8) * 0.03);
                        break;
                    case 'fastOrbit':
                        soulGroup.rotation.y += 0.02;
                        soulGroup.rotation.x += 0.008;
                        break;
                    case 'gentleBreathe':
                        soulGroup.rotation.y += 0.006;
                        soulGroup.scale.setScalar(1 + Math.sin(time * 1.2) * 0.05);
                        break;
                    case 'sharpSpin':
                        soulGroup.rotation.y += 0.025;
                        soulGroup.rotation.z += 0.015;
                        break;
                    case 'wavyFloat':
                        soulGroup.rotation.y += 0.008;
                        soulGroup.position.y = Math.sin(time * 0.6) * 2;
                        break;
                    case 'weaveConnect':
                        soulGroup.rotation.y += 0.01;
                        soulGroup.rotation.x = Math.sin(time * 0.4) * 0.3;
                        break;
                    case 'staticGlow':
                        // Minimal movement, emphasize glow
                        soulGroup.rotation.y += 0.002;
                        break;
                    case 'erraticBurst':
                        soulGroup.rotation.y += 0.015 + Math.sin(time * 3) * 0.01;
                        soulGroup.rotation.x += 0.01 + Math.cos(time * 2.5) * 0.005;
                        break;
                    case 'healingPulse':
                        soulGroup.rotation.y += 0.007;
                        soulGroup.scale.setScalar(1 + Math.sin(time * 2) * 0.04);
                        break;
                    case 'expandingReach':
                        soulGroup.rotation.y += 0.012;
                        soulGroup.scale.setScalar(1 + Math.sin(time * 0.5) * 0.1);
                        break;
                    case 'subtleShift':
                        soulGroup.rotation.y += 0.004;
                        soulGroup.rotation.z = Math.sin(time * 0.3) * 0.1;
                        break;
                    case 'festiveDance':
                        soulGroup.rotation.y += 0.018;
                        soulGroup.position.y = Math.sin(time * 1.5) * 1.5;
                        soulGroup.scale.setScalar(1 + Math.sin(time * 2.5) * 0.06);
                        break;
                    default:
                        soulGroup.rotation.y += 0.01;
                        soulGroup.rotation.x += 0.005;
                }
                
                // Individual crystal animations based on traits
                soulGroup.children.forEach((child, i) => {
                    if (child.userData.originalRotation) {
                        const factor = 1 + creativity * 2;
                        child.rotation.x = child.userData.originalRotation.x + Math.sin(time * factor + i) * introspection * 0.5;
                        child.rotation.y = child.userData.originalRotation.y + Math.cos(time * factor + i) * connectivity * 0.3;
                        child.rotation.z = child.userData.originalRotation.z + Math.sin(time * factor * 0.7 + i) * stability * 0.2;
                    }
                });
                
                renderer.render(scene, camera);
            }
            animate();
        }
        
        function replicateSoul() {
            simulator = new LNALSimulator();
            
            // Initialize 8 registers
            for (let i = 0; i < 8; i++) {
                simulator.registers.push(0);
                simulator.costs.push(0);
            }
            
            // Generate random Œ¥
            const delta = (Math.random() * 8 - 4).toFixed(2);
            simulator.logStep('SET_DELTA', [delta], {delta});
            
            // Climb to Gap-45 + Œ¥ 
            simulator.FOLD(GAP_45 + Math.floor(parseFloat(delta)), 0);
            
            // Encode 8 eigenvalues
            const energy = E_COH * Math.pow(PHI, GAP_45 + parseFloat(delta));
            simulator.logStep('SOUL_ENERGY', [energy.toFixed(6) + ' eV'], {energy});
            
            for (let k = 0; k < 8; k++) {
                const lambda = energy * Math.pow(PHI, k / 8);
                simulator.eigenvalues.push(lambda);
                simulator.FOLD(k/8, k);
                simulator.logStep('EIGENVALUE', [k, lambda.toFixed(6)], {k, lambda});
            }
            
            // Braid into cluster
            simulator.BRAID([0,1,2]);
            simulator.BRAID([3,4,5]);
            simulator.BRAID([6,7, simulator.registers.length - 1]);
            
            // Balance and cycle
            simulator.logStep('CYCLE', ['1024 ticks'], simulator.costs);
            simulator.logStep('STATUS', ['Soul replication complete'], {status: 'SUCCESS'});
            
            // Output
            document.getElementById('ledgerDisplay').textContent = 
                `SOUL REPLICATION SEQUENCE:\n\n` + 
                simulator.ledgerSteps.join('\n') + 
                `\n\nŒ¥ = ${delta}\nE_soul = ${energy.toFixed(6)} eV\n8 eigenvalues generated successfully\nPersonality traits computed from LNAL pattern analysis`;
            
            visualizeLedger(simulator.ledgerSteps, simulator.eigenvalues);
        }
        
        function clearLedger() {
            document.getElementById('ledgerDisplay').textContent = 'Ledger cleared. Ready for new soul replication...';
            document.getElementById('personalityContent').innerHTML = 'Generate a soul to see personality traits...';
            document.getElementById('explanationPanel').innerHTML = '<strong>Why This Visualization?</strong><br>Generate a soul to see code-to-visual explanations...';
            
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            while(scene.children.length > 0) {
                scene.remove(scene.children[0]);
            }
            renderer.render(scene, camera);
        }
        
        initVisualizer();
    </script>
</body>
</html> 