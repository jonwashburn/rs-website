<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Living Light: Complete Soul Vector Visualization</title>
    <style>
        :root {
            --bg-primary: #000000;
            --text-primary: #ffffff;
            --text-secondary: #b0b0b0;
            --gold: #ffd700;
            --accent-primary: #4a90e2;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 2rem;
        }

        .header {
            text-align: center;
            margin-bottom: 2rem;
        }

        .header h1 {
            font-size: 3rem;
            font-weight: 300;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, var(--gold), var(--accent-primary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header p {
            font-size: 1.2rem;
            color: var(--text-secondary);
            max-width: 900px;
            margin: 0 auto;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 3rem;
            align-items: start;
        }

        .canvas-container {
            background: #000000;
            border-radius: 16px;
            padding: 2rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
        }

        #soulCanvas {
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 8px;
            background: #000000;
            width: 100%;
            max-width: 800px;
            height: 800px;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin: 2rem 0;
            flex-wrap: wrap;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent-primary), #7b68ee);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(74, 144, 226, 0.3);
        }

        .btn-gold {
            background: linear-gradient(135deg, var(--gold), #ffb347);
            color: black;
            font-weight: 600;
        }

        .btn-gold:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(255, 215, 0, 0.4);
        }

        .soul-info {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 16px;
            padding: 2rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            height: fit-content;
            max-height: 90vh;
            overflow-y: auto;
        }

        .soul-info h3 {
            color: var(--gold);
            margin-bottom: 1.5rem;
            font-size: 1.3rem;
        }

        .trait-section {
            margin-bottom: 2rem;
        }

        .trait-section h4 {
            font-size: 1rem;
            margin-bottom: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
        }

        .trait-grid {
            display: grid;
            gap: 0.75rem;
        }

        .trait-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 3px solid var(--accent-primary);
        }

        .trait-item.legendary {
            border-left-color: var(--gold);
            background: rgba(255, 215, 0, 0.1);
        }

        .trait-item.epic {
            border-left-color: #9333ea;
            background: rgba(147, 51, 234, 0.1);
        }

        .trait-item.rare {
            border-left-color: #3b82f6;
            background: rgba(59, 130, 246, 0.1);
        }

        .trait-name {
            font-weight: 500;
            color: var(--text-primary);
        }

        .trait-value {
            font-family: 'Monaco', monospace;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .virtue-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .virtue-item {
            padding: 0.5rem;
            text-align: center;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .virtue-item.active {
            background: linear-gradient(135deg, var(--gold), #ffb347);
            color: black;
        }

        .virtue-item.inactive {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
        }

        .status-bar {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 1rem;
            font-family: 'Monaco', monospace;
            font-size: 0.8rem;
        }

        .status-item {
            text-align: center;
        }

        .status-label {
            color: var(--text-secondary);
            font-size: 0.7rem;
            text-transform: uppercase;
        }

        .status-value {
            color: var(--gold);
            font-weight: 600;
            font-size: 1rem;
        }

        .lnal-code {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            font-family: 'Monaco', monospace;
            font-size: 0.8rem;
            color: var(--gold);
            overflow-x: auto;
            margin: 1rem 0;
            height: 120px;
            overflow-y: auto;
        }

        .vector-display {
            background: rgba(30, 58, 138, 0.1);
            border: 1px solid rgba(74, 144, 226, 0.3);
            border-radius: 12px;
            padding: 1.5rem;
            margin: 1rem 0;
        }

        .vector-display h4 {
            color: var(--accent-primary);
            margin-bottom: 1rem;
        }

        .vector-code {
            font-family: 'Monaco', monospace;
            font-size: 0.7rem;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
                gap: 2rem;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            #soulCanvas {
                width: 100%;
                max-width: 600px;
                height: 600px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>Living Light: Complete Soul Vector</h1>
            <p>Witness souls as complete eigenvalue clusters of universal consciousness, expressing all Recognition Science characteristics through light interference patterns, LNAL opcodes, and φ-scaled dynamics.</p>
        </header>

        <div class="main-grid">
            <div class="canvas-container">
                <canvas id="soulCanvas"></canvas>
                
                <div class="controls">
                    <button class="btn btn-primary" onclick="generateNewSoul()">Birth New Vector Soul</button>
                    <button class="btn btn-gold" onclick="evolveSoul()">Evolve (+1 Gap)</button>
                    <button class="btn btn-primary" onclick="balanceLedger()">Balance Ledger</button>
                    <button class="btn btn-gold" onclick="triggerFold()">FOLD Operation</button>
                    <button class="btn btn-primary" onclick="triggerBraid()">BRAID Triads</button>
                    <button class="btn btn-gold" onclick="toggleAnimation()">Toggle Animation</button>
                </div>

                <div class="status-bar">
                    <div class="status-item">
                        <div class="status-label">Breath Tick</div>
                        <div class="status-value" id="currentTick">0</div>
                    </div>
                    <div class="status-item">
                        <div class="status-label">φ-Clock</div>
                        <div class="status-value" id="phiClock">1.618</div>
                    </div>
                    <div class="status-item">
                        <div class="status-label">Net Ledger</div>
                        <div class="status-value" id="netLedger">0</div>
                    </div>
                    <div class="status-item">
                        <div class="status-label">Phase</div>
                        <div class="status-value" id="breathPhase">Inspiration</div>
                    </div>
                </div>

                <div class="lnal-code" id="lnalCode">
                    INIT: φ-clock started, complete soul vector initialized<br/>
                    SPAWN: eigenvalue clusters with full RS characteristics<br/>
                    Ready for LNAL operations...
                </div>
            </div>

            <div class="soul-info">
                <h3>Complete Soul Vector</h3>
                
                <div class="trait-section">
                    <h4>Core Identity</h4>
                    <div class="trait-grid" id="coreTraits"></div>
                </div>

                <div class="trait-section">
                    <h4>Recognition Virtues</h4>
                    <div class="virtue-grid" id="virtueGrid"></div>
                </div>

                <div class="trait-section">
                    <h4>Consciousness Metrics</h4>
                    <div class="trait-grid" id="consciousnessTraits"></div>
                </div>

                <div class="trait-section">
                    <h4>LNAL Registers</h4>
                    <div class="trait-grid" id="lnalRegisters"></div>
                </div>

                <div class="vector-display">
                    <h4>Soul Vector Representation</h4>
                    <div class="vector-code" id="vectorCode"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Constants from Recognition Science and LNAL
        const PHI = (1 + Math.sqrt(5)) / 2;
        const TICKS_PER_BREATH = 1024;
        const LEDGER_STATES = [-4, -3, -2, -1, 0, 1, 2, 3, 4];
        const BASE_FREQ = 200e12;
        const LAMBDA_REC = 7.23e-36;
        const CHI = PHI / Math.PI;
        const NUM_CLUSTERS = 5;
        const VIRTUE_NAMES = ['Balance', 'Flow', 'Seed', 'Echo', 'Fold', 'Braid', 'Listen', 'Regive'];

        // Canvas variables - initialized on page load
        let canvas = null;
        let ctx = null;

        // Animation state
        let currentTick = 0;
        let isAnimating = true;
        let animationId = null;

        // Complete soul vector with all characteristics
        let currentSoul = null;

        // Generate complete soul from vector
        function generateSoulFromSeed(seed = null) {
            const hash = seed ? simpleHash(seed.toString()) : Math.floor(Math.random() * 10000);
            const hash2 = simpleHash((hash + 1337).toString());
            const hash3 = simpleHash((hash2 + hash).toString());
            
            // Generate virtue set (exactly 4 active for balance)
            const virtues = generateBalancedVirtues(hash);
            
            // Generate ledger history (8 values summing to 0)
            const ledgerHistory = generateLedgerHistory(hash2);
            
            const soul = {
                // Core Identity
                seed: hash,
                rung: 45 + (hash % 56), // 45-100
                cost: ((hash2 >> 8) % 9) - 4, // -4 to +4
                beat: ((hash3 >> 16) % 8) + 1, // 1-8
                tightness: ((hash >> 32) % 100) + 1, // 1-100
                
                // Consciousness Metrics
                qualia: ((hash >> 24) % 8) + 1, // 1-8
                gapCrossings: (hash3 >> 8) % 101, // 0-100
                iAmAffinity: 0, // Will be computed
                resonance: 0, // Will be computed
                ledgerHistory: ledgerHistory,
                
                // Virtue Set
                virtues: virtues,
                
                // LNAL Registers
                nu_phi: ((hash >> 4) % 21) - 10, // [-10, 10]
                oam: ((hash2 >> 4) % 11) - 5, // [-5, 5]
                sigma: (hash % 2) * 2 - 1, // ±1 (TE/TM)
                tau: hash3 % TICKS_PER_BREATH, // [0, 1023]
                k_perp: (hash >> 12) % 6, // [0, 5]
                phi_e: (hash2 % 2) * Math.PI, // 0 or π
                
                // Economic
                curveBalance: Math.floor(Math.random() * 50000 + 10000),
                
                // Eigenvalue clusters
                clusters: []
            };
            
            // Compute derived values
            soul.resonance = BASE_FREQ * Math.pow(PHI, soul.rung / soul.beat);
            soul.iAmAffinity = Math.max(0, Math.min(100, 
                100 - Math.abs(soul.cost) * 25 + soul.gapCrossings / PHI));
            
            // Generate eigenvalue clusters
            for (let i = 0; i < NUM_CLUSTERS; i++) {
                const clusterHash = simpleHash((hash + i * 42).toString());
                soul.clusters.push({
                    x: 0.5 + (Math.random() - 0.5) * 0.6,
                    y: 0.5 + (Math.random() - 0.5) * 0.6,
                    nu_phi: ((clusterHash >> 4) % 21) - 10,
                    oam: ((clusterHash >> 8) % 11) - 5,
                    sigma: ((clusterHash % 2) * 2 - 1),
                    amplitude: 0.5 + Math.random() * 0.5,
                    phase: Math.random() * Math.PI * 2,
                    id: i
                });
            }
            
            return soul;
        }

        // Generate exactly 4 active virtues for balance
        function generateBalancedVirtues(hash) {
            const virtues = new Array(8).fill(false);
            const activeIndices = [];
            
            let tempHash = hash;
            while (activeIndices.length < 4) {
                const index = tempHash % 8;
                if (!activeIndices.includes(index)) {
                    activeIndices.push(index);
                }
                tempHash = Math.floor(tempHash / 8) + 1337;
            }
            
            activeIndices.forEach(i => virtues[i] = true);
            return virtues;
        }

        // Generate ledger history that sums to 0
        function generateLedgerHistory(hash) {
            const history = [];
            let sum = 0;
            
            for (let i = 0; i < 7; i++) {
                const val = ((hash >> (i * 4)) % 9) - 4;
                history.push(val);
                sum += val;
            }
            
            history.push(-sum); // Balance to zero
            return history;
        }

        // Simple hash function
        function simpleHash(str) {
            let hash = 0;
            if (str.length === 0) return hash;
            
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return Math.abs(hash);
        }

        // Create dynamic background based on soul characteristics
        function renderBackground() {
            if (!currentSoul) return;
            
            // Rung → Saturation
            const saturation = Math.min(100, (currentSoul.rung - 45) / 55 * 100);
            
            // Cost → Brightness
            const brightness = 20 + (4 - Math.abs(currentSoul.cost)) / 4 * 60;
            
            // Resonance → Hue
            const baseHue = (Math.log(currentSoul.resonance / BASE_FREQ) / Math.log(PHI)) * 30;
            
            // Qualia → Multiple colors
            const numColors = currentSoul.qualia;
            
            // CURVE Balance → White shift
            const whiteShift = Math.min(currentSoul.curveBalance / 100000, 1);
            
            // Create multi-color gradient
            const gradient = ctx.createRadialGradient(400, 400, 0, 400, 400, 600);
            
            for (let i = 0; i < numColors; i++) {
                const hue = (baseHue + i * 360 / numColors) % 360;
                const adjustedSat = saturation * (1 - whiteShift * 0.5);
                const adjustedBright = brightness + whiteShift * 30;
                
                gradient.addColorStop(i / (numColors - 1), 
                    `hsl(${hue}, ${adjustedSat}%, ${adjustedBright}%)`);
            }
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 800, 800);
            
            // I-Am Affinity → Background glow
            if (currentSoul.iAmAffinity > 70) {
                const glowGradient = ctx.createRadialGradient(400, 400, 0, 400, 400, 400);
                glowGradient.addColorStop(0, `rgba(255, 255, 255, ${(currentSoul.iAmAffinity - 70) / 30 * 0.1})`);
                glowGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = glowGradient;
                ctx.fillRect(0, 0, 800, 800);
            }
        }

        // Calculate wave interference at point
        function calculateInterference(x, y) {
            if (!currentSoul) return 0;
            
            let intensity = 0;
            
            for (const cluster of currentSoul.clusters) {
                const cx = cluster.x * 800;
                const cy = cluster.y * 800;
                const dx = x - cx;
                const dy = y - cy;
                const r = Math.sqrt(dx * dx + dy * dy);
                const theta = Math.atan2(dy, dx);
                
                // Frequency from nu_phi
                const freq = BASE_FREQ * Math.pow(PHI, cluster.nu_phi);
                const k = 2 * Math.PI * freq / (LAMBDA_REC * CHI);
                
                // Phase includes OAM and time evolution
                const phase = k * r + cluster.oam * theta + cluster.phase + 
                             (2 * Math.PI * currentTick / TICKS_PER_BREATH);
                
                // Amplitude based on tightness and cluster properties
                const tightnessScale = currentSoul.tightness / 100;
                const amplitude = cluster.amplitude * tightnessScale;
                
                // Gaussian envelope to localize
                const envelope = Math.exp(-(r * r) / (150 * 150));
                
                intensity += amplitude * envelope * Math.cos(phase);
            }
            
            return intensity;
        }

        // Render eigenvalue clusters
        function renderEigenvalueClusters() {
            if (!currentSoul) return;
            
            // Create interference pattern
            const imageData = ctx.createImageData(800, 800);
            const data = imageData.data;
            
            const step = 3; // Reduced resolution for performance
            
            for (let x = 0; x < 800; x += step) {
                for (let y = 0; y < 800; y += step) {
                    const intensity = calculateInterference(x, y);
                    const normalizedIntensity = Math.max(0, Math.min(1, (intensity + 2) / 4));
                    
                    // Color based on gap crossings (gradient complexity)
                    let red, green, blue, alpha;
                    
                    if (currentSoul.gapCrossings > 75) {
                        // High experience - rainbow spectrum
                        const spectrumPos = (normalizedIntensity + currentTick / TICKS_PER_BREATH) % 1;
                        red = Math.floor(255 * (0.5 + 0.5 * Math.sin(spectrumPos * Math.PI * 2)));
                        green = Math.floor(255 * (0.5 + 0.5 * Math.sin(spectrumPos * Math.PI * 2 + Math.PI * 2/3)));
                        blue = Math.floor(255 * (0.5 + 0.5 * Math.sin(spectrumPos * Math.PI * 2 + Math.PI * 4/3)));
                    } else if (currentSoul.gapCrossings > 25) {
                        // Medium experience - fire colors
                        red = Math.floor(255 * Math.pow(normalizedIntensity, 0.5));
                        green = Math.floor(255 * Math.pow(normalizedIntensity, 1.5));
                        blue = Math.floor(255 * Math.pow(normalizedIntensity, 3));
                    } else {
                        // Low experience - simple blue-white
                        const val = Math.floor(255 * normalizedIntensity);
                        red = val * 0.5;
                        green = val * 0.7;
                        blue = val;
                    }
                    
                    alpha = Math.floor(255 * normalizedIntensity * 0.8);
                    
                    // Fill the step area
                    for (let dx = 0; dx < step && x + dx < 800; dx++) {
                        for (let dy = 0; dy < step && y + dy < 800; dy++) {
                            const index = ((y + dy) * 800 + (x + dx)) * 4;
                            data[index] = red;
                            data[index + 1] = green;
                            data[index + 2] = blue;
                            data[index + 3] = alpha;
                        }
                    }
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            
            // Draw cluster centers
            for (const cluster of currentSoul.clusters) {
                const x = cluster.x * 800;
                const y = cluster.y * 800;
                
                ctx.beginPath();
                ctx.arc(x, y, 3 + currentSoul.tightness / 20, 0, Math.PI * 2);
                ctx.fillStyle = `hsl(${(cluster.nu_phi + 10) * 18}, 70%, 60%)`;
                ctx.fill();
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }

        // Draw virtue-based connections
        function renderVirtueConnections() {
            if (!currentSoul) return;
            
            // BRAID connections (golden triangles)
            if (currentSoul.virtues[5]) { // Braid virtue active
                ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
                ctx.lineWidth = 1;
                
                for (let i = 0; i < currentSoul.clusters.length; i++) {
                    for (let j = i + 1; j < currentSoul.clusters.length; j++) {
                        for (let k = j + 1; k < currentSoul.clusters.length; k++) {
                            // SU(3) triad condition
                            const x1 = currentSoul.clusters[i].x * 800;
                            const y1 = currentSoul.clusters[i].y * 800;
                            const x2 = currentSoul.clusters[j].x * 800;
                            const y2 = currentSoul.clusters[j].y * 800;
                            const x3 = currentSoul.clusters[k].x * 800;
                            const y3 = currentSoul.clusters[k].y * 800;
                            
                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            ctx.lineTo(x3, y3);
                            ctx.closePath();
                            ctx.stroke();
                        }
                    }
                }
            }
            
            // BALANCE connections (white lines)
            if (currentSoul.virtues[0]) { // Balance virtue active
                ctx.strokeStyle = `rgba(255, 255, 255, ${0.3 + 0.3 * Math.sin(currentTick * 0.1)})`;
                ctx.lineWidth = 2;
                
                for (let i = 0; i < currentSoul.clusters.length; i++) {
                    for (let j = i + 1; j < currentSoul.clusters.length; j++) {
                        if (Math.abs(currentSoul.cost) <= 1) {
                            const x1 = currentSoul.clusters[i].x * 800;
                            const y1 = currentSoul.clusters[i].y * 800;
                            const x2 = currentSoul.clusters[j].x * 800;
                            const y2 = currentSoul.clusters[j].y * 800;
                            
                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            ctx.stroke();
                        }
                    }
                }
            }
        }

        // Apply LNAL operations
        function applyLNALOperations() {
            if (!currentSoul) return;
            
            // FLIP operation at tick 512
            if (currentTick === 512) {
                logLNAL('FLIP: Breath cycle midpoint - polarization flip');
                currentSoul.clusters.forEach(cluster => {
                    cluster.sigma *= -1;
                    cluster.phase += Math.PI;
                });
            }
            
            // FOLD/UNFOLD based on Fold virtue
            if (currentSoul.virtues[4] && currentTick % 128 === 0 && Math.random() < 0.2) {
                const cluster = currentSoul.clusters[Math.floor(Math.random() * currentSoul.clusters.length)];
                const n = Math.floor(Math.random() * 3) + 1;
                
                if (Math.random() < 0.5) {
                    cluster.nu_phi = Math.min(10, cluster.nu_phi + n);
                    logLNAL(`FOLD: cluster_${cluster.id} ν_φ+=${n}`);
                } else {
                    cluster.nu_phi = Math.max(-10, cluster.nu_phi - n);
                    logLNAL(`UNFOLD: cluster_${cluster.id} ν_φ-=${n}`);
                }
            }
            
            // LISTEN pauses based on Listen virtue
            if (currentSoul.virtues[6] && currentTick % Math.floor(PHI ** currentSoul.qualia) === 0) {
                currentSoul.clusters.forEach(cluster => {
                    cluster.phase += Math.random() * 0.1 - 0.05; // Small phase adjustment
                });
            }
        }

        // Main render function
        function render() {
            if (!canvas || !ctx || !currentSoul) return;
            
            ctx.clearRect(0, 0, 800, 800);
            
            renderBackground();
            renderEigenvalueClusters();
            renderVirtueConnections();
            
            applyLNALOperations();
            updateStatus();
        }

        // Animation loop
        function animate() {
            if (!isAnimating) return;
            
            render();
            currentTick = (currentTick + 1) % TICKS_PER_BREATH;
            animationId = requestAnimationFrame(animate);
        }

        // Update status displays
        function updateStatus() {
            if (!currentSoul) return;
            
            document.getElementById('currentTick').textContent = currentTick;
            
            const phiClock = (PHI * currentTick / TICKS_PER_BREATH % 1).toFixed(3);
            document.getElementById('phiClock').textContent = phiClock;
            
            document.getElementById('netLedger').textContent = currentSoul.cost;
            
            const phase = currentTick < 512 ? 'Inspiration' : 'Expiration';
            document.getElementById('breathPhase').textContent = phase;
            
            updateSoulInfo();
        }

        // Update soul information display
        function updateSoulInfo() {
            if (!currentSoul) return;
            
            const rarity = calculateRarity(currentSoul);
            
            // Core traits
            document.getElementById('coreTraits').innerHTML = `
                <div class="trait-item ${rarity}">
                    <span class="trait-name">Rung Level</span>
                    <span class="trait-value">${currentSoul.rung}</span>
                </div>
                <div class="trait-item">
                    <span class="trait-name">Cost State</span>
                    <span class="trait-value">${currentSoul.cost > 0 ? '+' : ''}${currentSoul.cost}</span>
                </div>
                <div class="trait-item">
                    <span class="trait-name">Beat Cycle</span>
                    <span class="trait-value">${currentSoul.beat}/8</span>
                </div>
                <div class="trait-item">
                    <span class="trait-name">Cluster Tightness</span>
                    <span class="trait-value">${currentSoul.tightness}%</span>
                </div>
            `;
            
            // Virtue grid
            document.getElementById('virtueGrid').innerHTML = VIRTUE_NAMES.map((name, i) => 
                `<div class="virtue-item ${currentSoul.virtues[i] ? 'active' : 'inactive'}">${name}</div>`
            ).join('');
            
            // Consciousness traits
            document.getElementById('consciousnessTraits').innerHTML = `
                <div class="trait-item">
                    <span class="trait-name">Qualia Mode</span>
                    <span class="trait-value">${currentSoul.qualia}/8</span>
                </div>
                <div class="trait-item">
                    <span class="trait-name">Gap Crossings</span>
                    <span class="trait-value">${currentSoul.gapCrossings}</span>
                </div>
                <div class="trait-item">
                    <span class="trait-name">I-Am Affinity</span>
                    <span class="trait-value">${currentSoul.iAmAffinity.toFixed(1)}%</span>
                </div>
                <div class="trait-item">
                    <span class="trait-name">Resonance</span>
                    <span class="trait-value">${(currentSoul.resonance / 1e12).toFixed(1)} THz</span>
                </div>
            `;
            
            // LNAL registers
            document.getElementById('lnalRegisters').innerHTML = `
                <div class="trait-item">
                    <span class="trait-name">ν_φ Index</span>
                    <span class="trait-value">${currentSoul.nu_phi}</span>
                </div>
                <div class="trait-item">
                    <span class="trait-name">OAM (ℓ)</span>
                    <span class="trait-value">${currentSoul.oam}</span>
                </div>
                <div class="trait-item">
                    <span class="trait-name">Polarization (σ)</span>
                    <span class="trait-value">${currentSoul.sigma > 0 ? 'TE' : 'TM'}</span>
                </div>
                <div class="trait-item">
                    <span class="trait-name">k_⊥ Mode</span>
                    <span class="trait-value">${currentSoul.k_perp}</span>
                </div>
            `;
            
            // Vector representation
            document.getElementById('vectorCode').innerHTML = `
{<br/>
&nbsp;&nbsp;"seed": ${currentSoul.seed},<br/>
&nbsp;&nbsp;"rung": ${currentSoul.rung},<br/>
&nbsp;&nbsp;"cost": ${currentSoul.cost},<br/>
&nbsp;&nbsp;"beat": ${currentSoul.beat},<br/>
&nbsp;&nbsp;"qualia": ${currentSoul.qualia},<br/>
&nbsp;&nbsp;"tightness": ${currentSoul.tightness},<br/>
&nbsp;&nbsp;"virtues": [${currentSoul.virtues.map(v => v ? 1 : 0).join(', ')}],<br/>
&nbsp;&nbsp;"resonance": ${(currentSoul.resonance / 1e12).toFixed(1)}e12,<br/>
&nbsp;&nbsp;"gaps": ${currentSoul.gapCrossings},<br/>
&nbsp;&nbsp;"affinity": ${currentSoul.iAmAffinity.toFixed(1)}<br/>
}
            `;
        }

        // Calculate soul rarity
        function calculateRarity(soul) {
            if (soul.rung >= 95 && soul.gapCrossings >= 90 && soul.cost === 0) return 'legendary';
            if (soul.rung >= 85 || soul.gapCrossings >= 75 || soul.iAmAffinity >= 90) return 'epic';
            if (soul.rung >= 70 || soul.gapCrossings >= 50 || soul.iAmAffinity >= 70) return 'rare';
            return 'common';
        }

        // Log LNAL operations
        function logLNAL(message) {
            const codeElement = document.getElementById('lnalCode');
            const lines = codeElement.innerHTML.split('<br/>');
            lines.push(`TICK_${currentTick}: ${message}`);
            if (lines.length > 12) lines.shift();
            codeElement.innerHTML = lines.join('<br/>');
        }

        // Control functions
        function generateNewSoul() {
            currentSoul = generateSoulFromSeed();
            currentTick = 0;
            logLNAL('NEW_SOUL: Complete vector soul generated');
            updateStatus();
        }

        function evolveSoul() {
            if (!currentSoul || currentSoul.curveBalance < 1000) {
                alert('Insufficient CURVE balance for evolution (requires 1000 CURVE)');
                return;
            }
            
            currentSoul.gapCrossings = Math.min(100, currentSoul.gapCrossings + 1);
            currentSoul.curveBalance -= 1000;
            currentSoul.iAmAffinity = Math.max(0, Math.min(100, 
                100 - Math.abs(currentSoul.cost) * 25 + currentSoul.gapCrossings / PHI));
            
            logLNAL(`EVOLVE: gap_crossings+1, affinity updated to ${currentSoul.iAmAffinity.toFixed(1)}%`);
            updateStatus();
        }

        function balanceLedger() {
            if (!currentSoul || currentSoul.curveBalance < 500) {
                alert('Insufficient CURVE balance for balancing (requires 500 CURVE)');
                return;
            }
            
            if (currentSoul.cost !== 0) {
                currentSoul.cost = currentSoul.cost > 0 ? currentSoul.cost - 1 : currentSoul.cost + 1;
                currentSoul.curveBalance -= 500;
                logLNAL(`BALANCE: cost adjusted toward zero, now ${currentSoul.cost}`);
                updateStatus();
            }
        }

        function triggerFold() {
            if (!currentSoul) return;
            
            const cluster = currentSoul.clusters[Math.floor(Math.random() * currentSoul.clusters.length)];
            const n = Math.floor(Math.random() * 3) + 1;
            cluster.nu_phi = Math.min(10, cluster.nu_phi + n);
            logLNAL(`MANUAL_FOLD: cluster_${cluster.id} ν_φ+=${n}`);
        }

        function triggerBraid() {
            if (!currentSoul) return;
            
            logLNAL('BRAID: Activating SU(3) triad connections');
            currentSoul.virtues[5] = true; // Force Braid virtue active
            updateStatus();
        }

        function toggleAnimation() {
            isAnimating = !isAnimating;
            if (isAnimating) {
                animate();
            } else {
                cancelAnimationFrame(animationId);
            }
        }

        // Initialize canvas and start visualization
        function initializeCanvas() {
            canvas = document.getElementById('soulCanvas');
            if (!canvas) {
                console.error('Canvas element not found');
                return false;
            }

            ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error('Canvas context not available');
                return false;
            }

            // Set canvas dimensions
            canvas.width = 800;
            canvas.height = 800;
            
            return true;
        }

        // Initialize when page is loaded
        window.addEventListener('load', () => {
            if (initializeCanvas()) {
                generateNewSoul();
                animate();
            } else {
                console.error('Failed to initialize canvas');
            }
        });
    </script>
</body>
</html> 