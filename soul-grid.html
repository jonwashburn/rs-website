<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soul Grid V2 - Recognition Science Pixel Souls</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a0a, #1a1a2e);
            color: #e0e0e0;
            min-height: 100vh;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #ffd700;
            font-size: 2.5em;
            margin: 0;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .header p {
            color: #b0b0b0;
            font-size: 1.1em;
            margin: 10px 0;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }

        .main-container {
            display: flex;
            gap: 30px;
            max-width: 1400px;
            margin: 0 auto;
            flex-wrap: wrap;
        }

        .grid-container {
            flex: 1;
            min-width: 400px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #soulGrid {
            background: #000;
            border: 2px solid #333;
            border-radius: 8px;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.3);
        }

        .info-panel {
            flex: 1;
            min-width: 300px;
            background: rgba(20, 20, 40, 0.8);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 20px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .trait-section {
            margin-bottom: 25px;
            border-bottom: 1px solid #333;
            padding-bottom: 15px;
        }

        .trait-section h3 {
            color: #ffd700;
            margin: 0 0 15px 0;
            font-size: 1.2em;
        }

        .trait-item {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 0.9em;
        }

        .trait-label {
            color: #b0b0b0;
            flex: 1;
        }

        .trait-value {
            color: #fff;
            font-weight: bold;
            text-align: right;
        }

        .controls {
            text-align: center;
            margin-top: 20px;
        }

        .generate-btn {
            background: linear-gradient(45deg, #ffd700, #ffaa00);
            color: #000;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            font-size: 1.1em;
            transition: all 0.3s ease;
        }

        .generate-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .animation-status {
            color: #ff6b6b;
            font-weight: bold;
            text-align: center;
            margin: 10px 0;
        }

        .animation-status.animated {
            color: #4ecdc4;
        }

        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
            }
            .grid-container, .info-panel {
                min-width: unset;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Soul Grid V2</h1>
        <p>Recognition Science pixel souls inspired by Ed Manning's 1976 digital art, with flowing curves from Fidenza and connection patterns from Ringers. Each grid represents a complete soul vector with characteristics mapped to visual properties.</p>
    </div>

    <div class="main-container">
        <div class="grid-container">
            <canvas id="soulGrid" width="500" height="500"></canvas>
        </div>

        <div class="info-panel">
            <div class="animation-status" id="animationStatus">Static Soul</div>
            
            <div class="trait-section">
                <h3>Core Identity</h3>
                <div class="trait-item">
                    <span class="trait-label">Soul Hash:</span>
                    <span class="trait-value" id="soulHash">-</span>
                </div>
                <div class="trait-item">
                    <span class="trait-label">Grid Size:</span>
                    <span class="trait-value" id="gridSize">-</span>
                </div>
                <div class="trait-item">
                    <span class="trait-label">Rung Level:</span>
                    <span class="trait-value" id="rungLevel">-</span>
                </div>
                <div class="trait-item">
                    <span class="trait-label">Cost State:</span>
                    <span class="trait-value" id="costState">-</span>
                </div>
                <div class="trait-item">
                    <span class="trait-label">Beat Cycle:</span>
                    <span class="trait-value" id="beatCycle">-</span>
                </div>
            </div>

            <div class="trait-section">
                <h3>Visual Properties</h3>
                <div class="trait-item">
                    <span class="trait-label">Animation Type:</span>
                    <span class="trait-value" id="animationType">-</span>
                </div>
                <div class="trait-item">
                    <span class="trait-label">Connection Style:</span>
                    <span class="trait-value" id="connectionStyle">-</span>
                </div>
                <div class="trait-item">
                    <span class="trait-label">Flow Pattern:</span>
                    <span class="trait-value" id="flowPattern">-</span>
                </div>
                <div class="trait-item">
                    <span class="trait-label">Color Palette:</span>
                    <span class="trait-value" id="colorPalette">-</span>
                </div>
                <div class="trait-item">
                    <span class="trait-label">Texture Style:</span>
                    <span class="trait-value" id="textureStyle">-</span>
                </div>
            </div>

            <div class="trait-section">
                <h3>Virtues (Active)</h3>
                <div id="virtuesActive">-</div>
            </div>

            <div class="trait-section">
                <h3>Consciousness Metrics</h3>
                <div class="trait-item">
                    <span class="trait-label">Qualia Mode:</span>
                    <span class="trait-value" id="qualiaMode">-</span>
                </div>
                <div class="trait-item">
                    <span class="trait-label">Cluster Tightness:</span>
                    <span class="trait-value" id="clusterTightness">-</span>
                </div>
                <div class="trait-item">
                    <span class="trait-label">Resonance Freq:</span>
                    <span class="trait-value" id="resonanceFreq">-</span>
                </div>
                <div class="trait-item">
                    <span class="trait-label">I-Am Affinity:</span>
                    <span class="trait-value" id="iAmAffinity">-</span>
                </div>
            </div>

            <div class="controls">
                <button class="generate-btn" onclick="generateNewSoul()">Generate New Soul</button>
            </div>
        </div>
    </div>

    <script>
        // Recognition Science Constants
        const PHI = (1 + Math.sqrt(5)) / 2;
        const VIRTUE_NAMES = ['Balance', 'Flow', 'Seed', 'Echo', 'Fold', 'Braid', 'Listen', 'Regive'];
        
        // Animation state
        let currentSoul = null;
        let animationFrame = 0;
        let isAnimating = false;
        let canvas = null;
        let ctx = null;

        // Enhanced visual constants
        const GRID_SIZES = [4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 16];
        const CONNECTION_STYLES = ['Ringers', 'Web', 'Radial', 'Flow', 'Minimal'];
        const FLOW_PATTERNS = ['Fidenza', 'Organic', 'Geometric', 'Spiral', 'Linear'];
        const TEXTURE_STYLES = ['Smooth', 'Granular', 'Flowing', 'Blocky', 'Ethereal'];

        function simpleHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return Math.abs(hash);
        }

        function seedRandom(seed) {
            let x = Math.sin(seed) * 10000;
            return x - Math.floor(x);
        }

        function generateSoul() {
            const seed = Math.floor(Math.random() * 1000000);
            const hash = simpleHash(seed.toString());
            
            // Core RS characteristics
            const rungLevel = Math.floor(seedRandom(hash + 1) * 45) + 1;
            const costState = Math.floor((seedRandom(hash + 2) - 0.5) * 200);
            const beatCycle = Math.floor(seedRandom(hash + 3) * 8) + 1;
            
            // Grid size based on consciousness complexity
            const gridComplexity = (rungLevel / 45) * 0.7 + (Math.abs(costState) / 100) * 0.3;
            const gridSizeIndex = Math.floor(gridComplexity * GRID_SIZES.length);
            const gridSize = GRID_SIZES[Math.min(gridSizeIndex, GRID_SIZES.length - 1)];
            
            // Visual properties
            const qualiaMode = Math.floor(seedRandom(hash + 4) * 8) + 1;
            const clusterTightness = seedRandom(hash + 5);
            const resonanceFreq = seedRandom(hash + 6);
            const iAmAffinity = seedRandom(hash + 7);
            
            // Enhanced properties inspired by Fidenza & Ringers
            const connectionStyle = CONNECTION_STYLES[Math.floor(seedRandom(hash + 8) * CONNECTION_STYLES.length)];
            const flowPattern = FLOW_PATTERNS[Math.floor(seedRandom(hash + 9) * FLOW_PATTERNS.length)];
            const textureStyle = TEXTURE_STYLES[Math.floor(seedRandom(hash + 10) * TEXTURE_STYLES.length)];
            
            // Rare animations (1 in 10 chance)
            const hasAnimation = seedRandom(hash + 11) < 0.1;
            const animationType = hasAnimation ? 
                ['Pulse', 'Flow', 'Rotate', 'Breathe'][Math.floor(seedRandom(hash + 12) * 4)] : 
                'Static';
            
            // Generate balanced virtues
            const virtues = generateBalancedVirtues(hash);
            
            // Color palette based on qualia mode
            const palette = generateColorPalette(qualiaMode, resonanceFreq, hash);
            
            return {
                seed,
                hash: hash.toString(16).substr(0, 8),
                gridSize,
                rungLevel,
                costState,
                beatCycle,
                qualiaMode,
                clusterTightness,
                resonanceFreq,
                iAmAffinity,
                connectionStyle,
                flowPattern,
                textureStyle,
                hasAnimation,
                animationType,
                virtues,
                palette
            };
        }

        function generateBalancedVirtues(hash) {
            const virtues = {};
            let totalActive = 0;
            
            VIRTUE_NAMES.forEach((virtue, i) => {
                const strength = seedRandom(hash + 100 + i);
                const isActive = strength > 0.6; // 40% chance active
                virtues[virtue] = { active: isActive, strength };
                if (isActive) totalActive++;
            });
            
            // Ensure at least 2 virtues are active
            if (totalActive < 2) {
                const inactiveVirtues = VIRTUE_NAMES.filter(v => !virtues[v].active);
                const toActivate = inactiveVirtues.slice(0, 2 - totalActive);
                toActivate.forEach(v => virtues[v].active = true);
            }
            
            return virtues;
        }

        function generateColorPalette(qualiaMode, resonanceFreq, hash) {
            const baseHue = seedRandom(hash + 200) * 360;
            const saturation = 60 + (resonanceFreq * 40);
            const lightness = 45 + (resonanceFreq * 30);
            
            const colors = [];
            for (let i = 0; i < qualiaMode; i++) {
                const hue = (baseHue + (i * 360 / qualiaMode)) % 360;
                colors.push(`hsl(${hue}, ${saturation}%, ${lightness}%)`);
            }
            
            return colors;
        }

        function renderSoulGrid(soul) {
            if (!ctx) return;
            
            const canvasSize = 500;
            const margin = 50;
            const gridArea = canvasSize - (margin * 2);
            const cellSize = gridArea / soul.gridSize;
            
            // Clear canvas with subtle background
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvasSize, canvasSize);
            
            // Add subtle background texture
            renderBackgroundTexture(soul, canvasSize);
            
            // Render Ringers-inspired connections first (behind grid)
            renderConnections(soul, margin, cellSize);
            
            // Render main grid with Fidenza-inspired flowing elements
            renderGrid(soul, margin, cellSize);
            
            // Add Fidenza-inspired flowing overlays
            renderFlowingElements(soul, margin, gridArea);
        }

        function renderBackgroundTexture(soul, canvasSize) {
            const gradient = ctx.createRadialGradient(
                canvasSize/2, canvasSize/2, 0,
                canvasSize/2, canvasSize/2, canvasSize/2
            );
            
            const bgIntensity = soul.rungLevel / 45 * 0.3;
            gradient.addColorStop(0, `rgba(${soul.palette[0].match(/\d+/g).join(',')}, ${bgIntensity})`);
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvasSize, canvasSize);
        }

        function renderConnections(soul, margin, cellSize) {
            if (soul.connectionStyle === 'Minimal') return;
            
            ctx.strokeStyle = soul.palette[0];
            ctx.globalAlpha = 0.3;
            ctx.lineWidth = 1;
            
            const centers = [];
            for (let row = 0; row < soul.gridSize; row++) {
                for (let col = 0; col < soul.gridSize; col++) {
                    centers.push({
                        x: margin + col * cellSize + cellSize/2,
                        y: margin + row * cellSize + cellSize/2
                    });
                }
            }
            
            switch (soul.connectionStyle) {
                case 'Ringers':
                    renderRingersConnections(centers, soul);
                    break;
                case 'Web':
                    renderWebConnections(centers, soul);
                    break;
                case 'Radial':
                    renderRadialConnections(centers, soul);
                    break;
                case 'Flow':
                    renderFlowConnections(centers, soul);
                    break;
            }
            
            ctx.globalAlpha = 1;
        }

        function renderRingersConnections(centers, soul) {
            // Inspired by Ringers - string wrapping patterns
            const step = Math.max(1, Math.floor(soul.gridSize / 3));
            for (let i = 0; i < centers.length; i += step) {
                const start = centers[i];
                const end = centers[(i + step * 2) % centers.length];
                
                ctx.beginPath();
                ctx.moveTo(start.x, start.y);
                
                // Create curved path like string tension
                const midX = (start.x + end.x) / 2 + (seedRandom(soul.hash + i) - 0.5) * 50;
                const midY = (start.y + end.y) / 2 + (seedRandom(soul.hash + i + 100) - 0.5) * 50;
                
                ctx.quadraticCurveTo(midX, midY, end.x, end.y);
                ctx.stroke();
            }
        }

        function renderWebConnections(centers, soul) {
            // Connect each point to nearby points
            centers.forEach((center, i) => {
                centers.slice(i + 1).forEach((other, j) => {
                    const dist = Math.sqrt((center.x - other.x)**2 + (center.y - other.y)**2);
                    if (dist < 80 * soul.clusterTightness) {
                        ctx.beginPath();
                        ctx.moveTo(center.x, center.y);
                        ctx.lineTo(other.x, other.y);
                        ctx.stroke();
                    }
                });
            });
        }

        function renderRadialConnections(centers, soul) {
            const centerPoint = centers[Math.floor(centers.length / 2)];
            centers.forEach(point => {
                if (point !== centerPoint) {
                    ctx.beginPath();
                    ctx.moveTo(centerPoint.x, centerPoint.y);
                    ctx.lineTo(point.x, point.y);
                    ctx.stroke();
                }
            });
        }

        function renderFlowConnections(centers, soul) {
            // Flowing connections based on beat cycle
            const phase = soul.hasAnimation ? (animationFrame * 0.1) : 0;
            for (let i = 0; i < centers.length - 1; i++) {
                const start = centers[i];
                const end = centers[i + 1];
                const flow = Math.sin(phase + i * 0.5) * 0.5 + 0.5;
                
                ctx.globalAlpha = 0.2 + flow * 0.3;
                ctx.beginPath();
                ctx.moveTo(start.x, start.y);
                ctx.lineTo(end.x, end.y);
                ctx.stroke();
            }
        }

        function renderGrid(soul, margin, cellSize) {
            for (let row = 0; row < soul.gridSize; row++) {
                for (let col = 0; col < soul.gridSize; col++) {
                    const x = margin + col * cellSize;
                    const y = margin + row * cellSize;
                    const index = row * soul.gridSize + col;
                    
                    renderGridCell(soul, x, y, cellSize, index, row, col);
                }
            }
        }

        function renderGridCell(soul, x, y, size, index, row, col) {
            // Color from palette based on position and traits
            const colorIndex = index % soul.palette.length;
            const baseColor = soul.palette[colorIndex];
            
            // Cost state affects brightness
            const costFactor = soul.costState / 100;
            const brightness = 0.5 + costFactor * 0.3;
            
            // Tightness affects position variation
            const posVariation = (1 - soul.clusterTightness) * 10;
            const offsetX = (seedRandom(soul.hash + index * 3) - 0.5) * posVariation;
            const offsetY = (seedRandom(soul.hash + index * 5) - 0.5) * posVariation;
            
            // Size variation based on resonance
            const sizeVariation = soul.resonanceFreq * 0.4;
            const actualSize = size * (0.8 + sizeVariation);
            
            // Animation effects
            let animScale = 1;
            let animRotation = 0;
            
            if (soul.hasAnimation) {
                const phase = animationFrame * 0.1 + index * 0.1;
                switch (soul.animationType) {
                    case 'Pulse':
                        animScale = 1 + Math.sin(phase) * 0.2;
                        break;
                    case 'Rotate':
                        animRotation = phase;
                        break;
                    case 'Breathe':
                        animScale = 1 + Math.sin(phase * 0.5) * 0.1;
                        break;
                }
            }
            
            ctx.save();
            ctx.translate(x + size/2 + offsetX, y + size/2 + offsetY);
            ctx.rotate(animRotation);
            ctx.scale(animScale, animScale);
            
            // Render cell based on texture style
            ctx.fillStyle = baseColor;
            ctx.globalAlpha = brightness;
            
            switch (soul.textureStyle) {
                case 'Smooth':
                    ctx.fillRect(-actualSize/2, -actualSize/2, actualSize, actualSize);
                    break;
                case 'Flowing':
                    renderFlowingCell(actualSize);
                    break;
                case 'Granular':
                    renderGranularCell(actualSize, soul, index);
                    break;
                default:
                    ctx.fillRect(-actualSize/2, -actualSize/2, actualSize, actualSize);
            }
            
            ctx.restore();
        }

        function renderFlowingCell(size) {
            // Fidenza-inspired flowing shapes
            ctx.beginPath();
            const points = 8;
            for (let i = 0; i < points; i++) {
                const angle = (i / points) * Math.PI * 2;
                const radius = size/2 * (0.8 + Math.sin(angle * 3) * 0.2);
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
        }

        function renderGranularCell(size, soul, index) {
            // Multiple small rectangles for granular texture
            const grains = 4;
            const grainSize = size / grains;
            
            for (let i = 0; i < grains; i++) {
                for (let j = 0; j < grains; j++) {
                    const gx = -size/2 + i * grainSize;
                    const gy = -size/2 + j * grainSize;
                    const variation = seedRandom(soul.hash + index + i + j) * 0.5 + 0.5;
                    
                    ctx.globalAlpha *= variation;
                    ctx.fillRect(gx, gy, grainSize * 0.8, grainSize * 0.8);
                }
            }
        }

        function renderFlowingElements(soul, margin, gridArea) {
            if (soul.flowPattern === 'Minimal') return;
            
            ctx.globalAlpha = 0.1;
            ctx.strokeStyle = soul.palette[soul.palette.length - 1];
            ctx.lineWidth = 2;
            
            // Add Fidenza-inspired flowing curves
            const curves = 3 + Math.floor(soul.iAmAffinity * 5);
            for (let i = 0; i < curves; i++) {
                const startX = margin + seedRandom(soul.hash + i * 20) * gridArea;
                const startY = margin + seedRandom(soul.hash + i * 21) * gridArea;
                const endX = margin + seedRandom(soul.hash + i * 22) * gridArea;
                const endY = margin + seedRandom(soul.hash + i * 23) * gridArea;
                
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                
                // Create flowing curve
                const steps = 20;
                for (let step = 0; step <= steps; step++) {
                    const t = step / steps;
                    const x = startX + (endX - startX) * t;
                    const y = startY + (endY - startY) * t;
                    
                    // Add flowing variation
                    const flowOffset = Math.sin(t * Math.PI * 4 + i) * 20 * soul.resonanceFreq;
                    const perpX = -(endY - startY) / gridArea * flowOffset;
                    const perpY = (endX - startX) / gridArea * flowOffset;
                    
                    ctx.lineTo(x + perpX, y + perpY);
                }
                
                ctx.stroke();
            }
            
            ctx.globalAlpha = 1;
        }

        function updateInfo(soul) {
            document.getElementById('soulHash').textContent = soul.hash;
            document.getElementById('gridSize').textContent = `${soul.gridSize}×${soul.gridSize}`;
            document.getElementById('rungLevel').textContent = `${soul.rungLevel}/45`;
            document.getElementById('costState').textContent = soul.costState;
            document.getElementById('beatCycle').textContent = `${soul.beatCycle}/8`;
            
            document.getElementById('animationType').textContent = soul.animationType;
            document.getElementById('connectionStyle').textContent = soul.connectionStyle;
            document.getElementById('flowPattern').textContent = soul.flowPattern;
            document.getElementById('colorPalette').textContent = `${soul.palette.length} colors`;
            document.getElementById('textureStyle').textContent = soul.textureStyle;
            
            document.getElementById('qualiaMode').textContent = `${soul.qualiaMode}/8`;
            document.getElementById('clusterTightness').textContent = (soul.clusterTightness * 100).toFixed(1) + '%';
            document.getElementById('resonanceFreq').textContent = (soul.resonanceFreq * 100).toFixed(1) + '%';
            document.getElementById('iAmAffinity').textContent = (soul.iAmAffinity * 100).toFixed(1) + '%';
            
            // Update virtues
            const activeVirtues = Object.entries(soul.virtues)
                .filter(([_, data]) => data.active)
                .map(([name, _]) => name);
            
            document.getElementById('virtuesActive').textContent = 
                activeVirtues.length > 0 ? activeVirtues.join(', ') : 'None active';
            
            // Update animation status
            const statusEl = document.getElementById('animationStatus');
            if (soul.hasAnimation) {
                statusEl.textContent = `Animated (${soul.animationType})`;
                statusEl.className = 'animation-status animated';
            } else {
                statusEl.textContent = 'Static Soul';
                statusEl.className = 'animation-status';
            }
        }

        function animate() {
            if (!currentSoul || !currentSoul.hasAnimation) return;
            
            animationFrame++;
            renderSoulGrid(currentSoul);
            requestAnimationFrame(animate);
        }

        function generateNewSoul() {
            // Stop current animation
            isAnimating = false;
            
            // Generate new soul
            currentSoul = generateSoul();
            updateInfo(currentSoul);
            renderSoulGrid(currentSoul);
            
            // Start animation if soul is animated
            if (currentSoul.hasAnimation) {
                isAnimating = true;
                animationFrame = 0;
                animate();
            }
        }

        function init() {
            canvas = document.getElementById('soulGrid');
            ctx = canvas.getContext('2d');
            
            if (!canvas || !ctx) {
                console.error('Failed to initialize canvas');
                return;
            }
            
            // Generate initial soul
            generateNewSoul();
        }

        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html> 