<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Perfect Soul Image Generator - Recognition Science</title>
    <link rel="stylesheet" href="/style.css">
    <style>
        body {
            background: #f5f5f7;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2em;
        }
        
        h1 {
            font-family: 'VT323', monospace;
            font-size: 2.5em;
            margin-bottom: 1em;
        }
        
        #generateBtn {
            background: #007AFF;
            color: white;
            border: none;
            padding: 1em 2em;
            font-size: 1.2em;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            margin-bottom: 2em;
            transition: all 0.2s ease;
        }
        
        #generateBtn:hover {
            background: #0056CC;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 122, 255, 0.3);
        }
        
        #soulCanvas {
            border: 2px solid #000;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            background: #fff;
        }
        
        #downloadLink {
            margin-top: 1em;
            color: #007AFF;
            text-decoration: none;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <h1>ðŸŒŸ Perfect Soul Image Generator</h1>
    <button id="generateBtn">Generate New Soul Image</button>
    <canvas id="soulCanvas" width="1024" height="1024"></canvas>
    <a id="downloadLink" href="#" download="soul-image.png">Download Image</a>
    
    <script>
        // Constants
        const CANVAS_SIZE = 1024;
        const PHI = 1.618033988749;
        const GAP_45 = 45;
        const E_COH = 0.511; // MeV
        const VIRTUES = [
            { name: 'Love', index: 0 },
            { name: 'Justice', index: 1 },
            { name: 'Forgiveness', index: 2 },
            { name: 'Wisdom', index: 3 },
            { name: 'Courage', index: 4 },
            { name: 'Temperance', index: 5 },
            { name: 'Prudence', index: 6 },
            { name: 'Compassion', index: 7 },
            { name: 'Gratitude', index: 8 },
            { name: 'Patience', index: 9 },
            { name: 'Humility', index: 10 },
            { name: 'Hope', index: 11 },
            { name: 'Creativity', index: 12 },
            { name: 'Sacrifice', index: 13 }
        ];
        
        // Refined Color Palettes (Mapan-inspired with ethereal tones)
        const SOUL_PALETTES = [
            { name: 'Eternal Flame', base: '#D32F2F', accents: ['#1976D2', '#F57C00', '#FFD700'], sheen: '#FFFFFF' },
            { name: 'Cosmic Veil', base: '#7B1FA2', accents: ['#388E3C', '#FBC02D', '#FF5722'], sheen: '#EDE7F6' },
            { name: 'Light Prism', base: '#303F9F', accents: ['#F57C00', '#C2185B', '#4CAF50'], sheen: '#E3F2FD' },
            { name: 'Soul Ember', base: '#5D4037', accents: ['#FF9800', '#2196F3', '#8BC34A'], sheen: '#EFEBE9' },
            { name: 'Divine Spark', base: '#FF8F00', accents: ['#3F51B5', '#E91E63', '#00BCD4'], sheen: '#FFF3E0' }
        ];
        
        // Improved Perlin Noise for subtle texture
        function perlinNoise(x, y, scale = 0.005) {
            const p = new Array(512);
            const permutation = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];
            for (let i = 0; i < 256; i++) p[256 + i] = p[i] = permutation[i];
            
            const fade = t => t * t * t * (t * (t * 6 - 15) + 10);
            const lerp = (t, a, b) => a + t * (b - a);
            const grad = (hash, x, y) => {
                switch(hash & 3) {
                    case 0: return x + y;
                    case 1: return -x + y;
                    case 2: return x - y;
                    case 3: return -x - y;
                }
            };
            
            const xi = Math.floor(x * scale);
            const yi = Math.floor(y * scale);
            const xf = x * scale - xi;
            const yf = y * scale - yi;
            
            const aa = p[p[xi] + yi];
            const ba = p[p[xi + 1] + yi];
            const ab = p[p[xi] + yi + 1];
            const bb = p[p[xi + 1] + yi + 1];
            
            const x1 = lerp(fade(xf), grad(aa, xf, yf), grad(ba, xf-1, yf));
            const x2 = lerp(fade(xf), grad(ab, xf, yf-1), grad(bb, xf-1, yf-1));
            return (lerp(fade(yf), x1, x2) + 1) / 2; // Normalized to 0-1
        }
        
        // Hex to RGB helper
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 255, g: 255, b: 255 };
        }
        
        // Interpolate between two colors
        function interpolateColor(color1, color2, factor) {
            const r = Math.round(color1.r + (color2.r - color1.r) * factor);
            const g = Math.round(color1.g + (color2.g - color1.g) * factor);
            const b = Math.round(color1.b + (color2.b - color1.b) * factor);
            return { r, g, b };
        }
        
        // Create Mappan-like textured base with subtle noise
        function createLightSheet(ctx, palette, virtueScores) {
            const baseRgb = hexToRgb(palette.base);
            const sheenRgb = hexToRgb(palette.sheen);
            
            for (let x = 0; x < CANVAS_SIZE; x += 4) {
                for (let y = 0; y < CANVAS_SIZE; y += 4) {
                    const noise = perlinNoise(x, y, 0.002) * virtueScores.Creativity; // Creativity modulates noise strength
                    const factor = noise * 0.1; // Subtle variation
                    const color = interpolateColor(baseRgb, sheenRgb, factor);
                    ctx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
                    ctx.fillRect(x, y, 4, 4);
                }
            }
        }
        
        // Draw ethereal squiggle-seraph (Chromie baseline with NDE glow)
        function drawSquiggleSeraph(ctx, startX, startY, length, segments, color, width, glow, curvature) {
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            let currentX = startX;
            let currentY = startY;
            
            for (let i = 0; i < segments; i++) {
                const angle = Math.random() * Math.PI * 2;
                const segLength = length / segments;
                const controlX = currentX + Math.cos(angle) * segLength * (0.5 + curvature);
                const controlY = currentY + Math.sin(angle) * segLength * (0.5 + curvature);
                const endX = controlX + (Math.random() - 0.5) * segLength * 0.2;
                const endY = controlY + (Math.random() - 0.5) * segLength * 0.2;
                
                ctx.quadraticCurveTo(controlX, controlY, endX, endY);
                currentX = endX;
                currentY = endY;
            }
            
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.shadowBlur = glow * 20;
            ctx.shadowColor = color;
            ctx.stroke();
        }
        
        // Main generation function
        function generateSoulImage() {
            const canvas = document.getElementById('soulCanvas');
            const ctx = canvas.getContext('2d');
            
            // Generate RS parameters
            const delta = (Math.random() * 8 - 4).toFixed(2);
            const energy = E_COH * Math.pow(PHI, GAP_45 + parseFloat(delta));
            const virtueScores = VIRTUES.reduce((obj, virtue) => {
                obj[virtue.name] = Math.random();
                return obj;
            }, {});
            const rarityLevels = ['Common', 'Rare', 'Epic', 'Legendary', 'Mythic'];
            const rarityIndex = Math.min(4, Math.floor(Object.values(virtueScores).reduce((a, b) => a + b, 0) / 14 * 5));
            const rarity = rarityLevels[rarityIndex];
            
            // Select palette influenced by energy
            const paletteIndex = Math.floor((energy % 1) * SOUL_PALETTES.length);
            const palette = SOUL_PALETTES[paletteIndex];
            
            // Create light sheet base
            createLightSheet(ctx, palette, virtueScores);
            
            // Calculate soul cluster position (centered but offset by delta)
            const centerX = CANVAS_SIZE / 2 + delta * 20;
            const centerY = CANVAS_SIZE / 2;
            
            // Draw 8 eigenvalue squiggles (soul cluster)
            for (let i = 0; i < 8; i++) {
                const virtue = VIRTUES[i % VIRTUES.length].name;
                const score = virtueScores[virtue];
                
                // Position based on golden ratio spiral
                const angle = i * (2 * Math.PI / 8) + (Math.PI / PHI);
                const radius = 150 * PHI ** (i / 8) * (1 + score * 0.5);
                const startX = centerX + Math.cos(angle) * radius * virtueScores.Courage;
                const startY = centerY + Math.sin(angle) * radius * virtueScores.Courage;
                
                // Select color from palette with virtue modulation
                const colorIndex = Math.floor(score * palette.accents.length);
                const baseColor = palette.accents[colorIndex];
                const color = `${baseColor}${Math.floor(score * 255).toString(16).padStart(2, '0')}`; // Add alpha
                
                // Draw squiggle with virtue-specific params
                drawSquiggleSeraph(
                    ctx,
                    startX, startY,
                    300 + score * 200, // Length modulated by score
                    8 + Math.floor(virtueScores.Creativity * 10), // Segments
                    color,
                    1 + virtueScores.Wisdom * 3, // Width
                    virtueScores.Love, // Glow
                    virtueScores.Forgiveness // Curvature softness
                );
            }
            
            // Add shining through effects (NDE/DMT glows)
            const glowCount = Math.floor(virtueScores.Compassion * 20 + 5);
            for (let i = 0; i < glowCount; i++) {
                const glowX = centerX + (Math.random() - 0.5) * CANVAS_SIZE * 0.4 * virtueScores.Hope;
                const glowY = centerY + (Math.random() - 0.5) * CANVAS_SIZE * 0.4 * virtueScores.Hope;
                const glowRadius = 50 + virtueScores.Gratitude * 100;
                
                const gradient = ctx.createRadialGradient(glowX, glowY, 0, glowX, glowY, glowRadius);
                gradient.addColorStop(0, `${palette.sheen}CC`); // Semi-transparent
                gradient.addColorStop(1, `${palette.sheen}00`);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(glowX, glowY, glowRadius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Subtle overlay for depth
            ctx.globalAlpha = 0.05 * virtueScores.Humility;
            ctx.fillStyle = palette.sheen;
            ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            ctx.globalAlpha = 1;
            
            // Update download
            document.getElementById('downloadLink').href = canvas.toDataURL('image/png');
        }
        
        // Event listener
        document.getElementById('generateBtn').addEventListener('click', generateSoulImage);
        
        // Initial generation
        generateSoulImage();
    </script>
</body>
</html> 