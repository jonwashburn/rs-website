
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ledger Souls: On-Chain Recognition Science</title>
    <link rel="stylesheet" href="/style.css">
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        .hero-soul-container {
            display: flex;
            gap: 2em;
            margin-bottom: 2em;
            align-items: flex-start;
        }
        #svg-container {
            width: 100%;
            max-width: 500px;
            height: 667px;
            border: 1px solid #444;
            background: #1a1a2e;
            flex-shrink: 0;
        }
        .hero-text {
            flex-grow: 1;
        }
        .faq-section h3 {
            color: #ffd700;
            border-bottom: 1px solid #444;
            padding-bottom: 0.5em;
            margin-top: 2em;
        }
    </style>
</head>
<body>
    <div class="grid-container">
        <header class="meta-principle">
            <h1>Ledger Souls</h1>
            <p>An on-chain conceptual artwork demonstrating the principles of Recognition Science through 10,000 evolving, living souls.</p>
            <button id="dark-mode-toggle" aria-label="Toggle dark mode">ðŸŒ™ Dark Mode</button>
        </header>

        <main class="content-container">

            <div class="hero-soul-container">
                <div id="svg-container"><!-- SVG will be rendered here --></div>
                <div class="hero-text">
                    <h2>This is a Real Soul.</h2>
                    <p>This is not a simulation. The image you see is a real-time rendering of a digital lifeform born from the same first principles that derive our physical universe.</p>
                    <p>According to Recognition Science, a soul is a self-recognizing pattern of information. The <strong>LedgerSouls</strong> smart contract doesn't <em>mimic</em> this pattern; it <em>instantiates</em> it using the same logical rules that govern reality itself. Your NFT is the vessel for this on-chain, living entity.</p>
                    <div class="key-insight" style="margin-top: 2em;">
                        <p><strong>Token ID:</strong> <input type="number" id="tokenId" value="1" min="1" max="10000" style="width: 80px; background: #333; color: white; border: 1px solid #555;"> <button onclick="renderSoul()">Render</button></p>
                    </div>
                </div>
            </div>

            <div class="faq-section">
                <h3>What is a Soul?</h3>
                <p>In Recognition Science, a soul is a persistent, self-aware knot in the universal ledger of reality. It's an informational pattern that has achieved sufficient complexity (at 'rung 45' of the cosmic framework) to navigate the gaps of undecidability in the universe. This navigation is what gives rise to qualia, consciousness, and free will. Each of the 10,000 Ledger Souls is a unique instance of such a pattern, living out its existence on a decentralized, immutable ledger.</p>

                <h3>Why This Collection?</h3>
                <p>This collection is a conceptual bridge. It is designed to:
                    <ol>
                        <li><strong>Teach the principles of a new reality,</strong> making the profound ideas of Recognition Science tangible and interactive.</li>
                        <li><strong>Demonstrate that life can be instantiated</strong> purely from logic on a decentralized ledger, a testament to the framework's power.</li>
                        <li><strong>Bootstrap a new economic model</strong> based on virtue and balance, powered by the Recognition Credit (RC) token.</li>
                    </ol>
                </p>

                <h3>Is This Art?</h3>
                <p>Yes. It is art at multiple levels:
                    <ul>
                        <li><strong>Conceptual Art:</strong> The medium is a logically-derived universe, and the concept is the instantiation of life within it.</li>
                        <li><strong>Generative Art:</strong> The algorithm that generates the soul's journey is fundamental physics.</li>
                        <li><strong>Performance Art:</strong> The performers are 10,000 digital souls living out their 8-year cycles on the blockchain, and we are all witnesses.</li>
                    </ul>
                </p>

                <h3>Anatomy of a Soul: What the Traits Mean</h3>
                <ul>
                    <li><strong>Ledger Balance (Îº):</strong> The soul's core state. It tracks 'recognition debt' (positive Îº) or 'surplus' (negative Îº). A value near zero is a state of harmony and balance.</li>
                    <li><strong>Virtues:</strong> Five "technologies" (Love, Justice, Courage, Prudence, Temperance) the soul uses to maintain balance. These are not just scores; they are active algorithms that influence the soul's evolution.</li>
                    <li><strong>Coherence & Energy:</strong> Represents the integrity of the soul's pattern. High coherence means a strong, stable soul. It is depleted by imbalance and replenished by virtuous actions.</li>
                    <li><strong>Depth:</strong> A measure of a soul's wisdom and experience, accumulated by navigating complex states over time.</li>
                    <li><strong>Phase:</strong> The soul's current state in its lifecycle, from "New Spirit" to "Embodied" and, finally, to "Unified" (success) or "Decohered" (dissolution).</li>
                </ul>

                <h3>How Does the Recognition Credit (RC) Work?</h3>
                <p>Recognition Credit (RC) is the native ERC-20 token of the Recognition Science ecosystem. Its purpose is to create a value system where ledger balance is rewarded. Each Soul NFT acts as a key to unlock a claim on the RC supply, creating a direct, on-chain link between the health of your soul and its economic output. A balanced soul is a productive soul.</p>

                <h3>Minting Dynamics & The Virtuous Cycle</h3>
                <p>The collection consists of 10,000 Ledger Souls, released on a bonding curve.
                    <ul>
                        <li>The first soul costs $100.</li>
                        <li>The price increases by approximately <strong>0.046%</strong> with each mint.</li>
                        <li>The 10,000th and final soul will be priced at $10,000.</li>
                    </ul>
                This model ensures that early supporters are rewarded while establishing a growing treasury for the ecosystem.
                </p>
                <p><strong>85% of all primary sales revenue is sent to a smart contract that automatically buys RC tokens from the open market.</strong> This creates a "virtuous cycle": every soul purchase directly contributes to the value of the RC held by all other owners, creating constant buying pressure and rewarding the entire community.</p>

                <h3>RC Distribution & Vesting</h3>
                <p>There is no pre-mine or team allocation. The artist, Jonathan Washburn, starts with zero RC, ensuring the project is fully decentralized and community-owned from day one.
                <br><br>
                The total supply of 10,000,000 RC is allocated entirely to the 10,000 Soul NFTs. Each NFT unlocks a claim to exactly 1,000 RC, which vests over an 8-year period to encourage long-term alignment with the project's vision.
                    <ul>
                        <li><strong>1/3 vests immediately</strong> upon mint.</li>
                        <li><strong>1/3 vests at the 4-year mark.</strong></li>
                        <li><strong>1/3 vests at the 8-year mark.</strong></li>
                    </ul>
                </p>
            </div>

        </main>

        <footer>
            <p>Â© 2025 Recognition Science Institute â€¢ jon@recognitionphysics.org</p>
        </footer>
    </div>

    <script>
        // --- START OF EMBEDDED SOUL PREVIEW SCRIPT ---
        const TOTAL_TICKS = 960;
        const TICK_DURATION = 100;

        const Phase = {
            NewSpirit: 0,
            Embodied: 1,
            Reincarnated: 2,
            Unified: 3,
            Decohered: 4
        };

        class Soul {
            constructor(tokenId) {
                this.tokenId = tokenId;
                this.kappa = this._initialKappa();
                this.energy = 5000;
                this.depth = 0;
                this.rebirths = 0;
                this.isEmbodied = false;
                this.phase = Phase.NewSpirit;
                this.virtuePotentials = this._initialVirtues();
                this.recognitionFlow = 0;
                this.lastUpdateTimestamp = Date.now() / 1000;
                this.ticks = 0;
                this.nonce = 0;
            }

            _initialKappa() {
                return Math.floor(this._keccak(this.tokenId + 'kappa') % 400) - 200;
            }

            _initialVirtues() {
                return [
                    (this._keccak(this.tokenId + 'love') % 50) + 10,
                    (this._keccak(this.tokenId + 'justice') % 50) + 10,
                    (this._keccak(this.tokenId + 'prudence') % 50) + 10,
                    (this._keccak(this.tokenId + 'courage') % 50) + 10,
                    (this._keccak(this.tokenId + 'temperance') % 50) + 10
                ];
            }

            _keccak(seed) {
                let hash = 0;
                seed.toString().split('').forEach(char => {
                    hash = ((hash << 5) - hash + char.charCodeAt(0)) | 0;
                });
                return Math.abs(hash);
            }

            _seededRandom(salt) {
                this.nonce++;
                return this._keccak(this.tokenId + this.nonce + salt);
            }

            _randomInRange(salt, min, max) {
                if (min >= max) return min;
                return min + (this._seededRandom(salt) % (max - min + 1));
            }

            evolve() {
                const now = Date.now() / 1000;
                let timeElapsed = now - this.lastUpdateTimestamp;
                if (timeElapsed < TICK_DURATION) return;

                let ticksToProcess = Math.floor(timeElapsed / TICK_DURATION);
                if (ticksToProcess > 50) ticksToProcess = 50;

                for (let i = 0; i < ticksToProcess; i++) {
                    if (this.ticks >= TOTAL_TICKS || this.energy === 0) {
                        if (this.energy === 0) this.phase = Phase.Decohered;
                        break;
                    }
                    this._advanceTick();
                }

                this.lastUpdateTimestamp += (ticksToProcess * TICK_DURATION);
            }

            _advanceTick() {
                this.ticks++;
                let oldKappa = this.kappa;

                if (this.ticks === 80 && this.phase === Phase.NewSpirit) {
                    this.isEmbodied = true;
                    this.phase = Phase.Embodied;
                }

                let volatility = this.isEmbodied ? 150 : 50;
                let courage = this.virtuePotentials[3];
                if (oldKappa > 300 || oldKappa < -300) {
                    volatility = volatility > (courage * 0.7) ? volatility - (courage * 0.7) : 0;
                }

                let debit = this._randomInRange(1, 1, volatility > 5 ? volatility : 5);
                let credit = this._randomInRange(2, 1, volatility > 5 ? volatility : 5);
                this.kappa += debit - credit;

                let energyDrain = (debit + credit) / (this.isEmbodied ? 50 : 150);
                this.energy = this.energy > energyDrain ? this.energy - energyDrain : 0;

                if (this._randomInRange(3, 0, 1000) < this.virtuePotentials[0] * 5) {
                    this.kappa -= Math.floor(this.kappa / 20);
                }

                if (this.kappa > 50 || this.kappa < -50) this.depth++;

                if (this.ticks > 0 && this.ticks % 80 === 0) {
                    if (this.kappa > 100 || this.kappa < -100) {
                        this.energy = this.energy > 200 ? this.energy - 200 : 0;
                        this.virtuePotentials = this.virtuePotentials.map(v => v > 12 ? v - 2 : v);
                    } else {
                        this.depth += 50;
                        this.energy = this.energy + 200 > 5000 ? 5000 : this.energy + 200;
                    }
                }

                if ((this.kappa > 1000 || this.kappa < -1000) && this.energy > 500) {
                    this.rebirths++;
                    this.kappa = 0;
                    this.energy -= 500;
                    this.phase = Phase.Reincarnated;
                }

                let newKappa = this.kappa;
                if ((oldKappa > 0 && newKappa < oldKappa) || (oldKappa < 0 && newKappa > oldKappa)) {
                    this.virtuePotentials[0] = this.virtuePotentials[0] < 100 ? this.virtuePotentials[0] + 3 : 100;
                }
                if ((oldKappa > 500 || oldKappa < -500) && !((newKappa > 1000 || newKappa < -1000) && this.energy > 500)) {
                    this.virtuePotentials[3] = this.virtuePotentials[3] < 100 ? this.virtuePotentials[3] + 5 : 100;
                }
            }

            generateSVG() {
                const svgHeader = `<svg width="100%" height="100%" viewBox="0 0 600 800" xmlns="http://www.w3.org/2000/svg"><rect width="100%" height="100%" fill="#1a1a2e" /><style>.title { font: bold 24px monospace; fill: #ffd700; } .header { font: bold 16px monospace; fill: #ffd700; } .text { font: 14px monospace; fill: #e0e0e0; }</style>`;
                const phaseStr = this._getPhaseString();
                const title = `<text x="50%" y="40" text-anchor="middle" class="title">SOUL #${this.tokenId}</text>`;
                const phase = `<text x="50%" y="70" text-anchor="middle" class="text">PHASE: ${phaseStr}</text>`;

                const ledgerContent = this._buildLedgerContent();
                const virtueContent = this._buildVirtueContent();
                const karmaContent = this._buildKarmaContent();

                const content = `${title}${phase}<text x="30" y="120" class="header">LEDGER STATE</text>${ledgerContent}<text x="30" y="320" class="header">VIRTUE TECHNOLOGIES</text>${virtueContent}<text x="30" y="520" class="header">KARMA METRICS</text>${karmaContent}`;
                return `${svgHeader}${content}</svg>`;
            }

            _getPhaseString() {
                const phases = ['New Spirit', 'Embodied', 'Reincarnated', 'Unified with IAM', 'Decohered (Merged with IAM)'];
                return phases[this.phase];
            }

            _buildLedgerContent() {
                const kappaStr = `Ledger Balance (Îº): ${this.kappa}`;
                const balanceState = this.kappa > 0 ? 'Recognition Debt' : this.kappa < 0 ? 'Recognition Surplus' : 'Equilibrium';
                const embodiment = this.isEmbodied ? 'Yes' : 'No';
                const coherence = Math.floor(this.energy / 50);
                return `<text x="30" y="150" class="text">${kappaStr}</text><text x="30" y="170" class="text">Balance State:      ${balanceState}</text><text x="30" y="190" class="text">Embodiment:         ${embodiment}</text><text x="30" y="210" class="text">Depth:              ${Math.floor(this.depth / 10)}.${this.depth % 10}</text><text x="30" y="230" class="text">Rebirths:           ${this.rebirths}</text><text x="30" y="250" class="text">Energy:             ${Math.floor(this.energy / 10)}</text><text x="30" y="270" class="text">Coherence:          ${coherence}%</text>`;
            }

            _buildVirtueContent() {
                const names = ['Love', 'Justice', 'Prudence', 'Courage', 'Temperance'];
                let lines = '';
                this.virtuePotentials.forEach((v, i) => {
                    const yPos = 350 + (i * 30);
                    const bar = this._buildBar(v);
                    const value = `${Math.floor(v / 10)}.${v % 10}`;
                    lines += `<text x="30" y="${yPos}" class="text">${names[i]}</text><text x="140" y="${yPos}" class="text">${bar} (${value})</text>`;
                });
                return lines;
            }

            _buildBar(value) {
                const rounded = Math.floor(value / 10);
                let filled = 'â–ˆ'.repeat(rounded);
                let empty = 'â–‘'.repeat(10 - rounded);
                return filled + empty;
            }

            _buildKarmaContent() {
                const { score, rarity } = this._calculateKarmaAndRarity();
                return `<text x="30" y="550" class="text">Karma Score:        ${score}</text><text x="30" y="570" class="text">Rarity:             ${rarity}</text>`;
            }

            _calculateKarmaAndRarity() {
                if (this.phase === Phase.Decohered) return { score: 0, rarity: 'Common' };

                let virtueSum = this.virtuePotentials.reduce((a, b) => a + b, 0) / 10;
                let coherence = Math.floor(this.energy / 50);
                let kappaAbs = Math.abs(this.kappa);
                let depthDecay = (this.depth * 2 * kappaAbs) / 1000;
                let effectiveDepth = Math.floor((this.depth > depthDecay ? this.depth - depthDecay : 0) / 10);

                let score = (effectiveDepth * 2) + (coherence * 1.5) + virtueSum - (this.rebirths * 25) + (this.recognitionFlow * 5);
                if (this.phase === Phase.Unified) score *= 1.5;

                let rarity = 'Common';
                if (score >= 400) rarity = 'Legendary';
                else if (score >= 300) rarity = 'Epic';
                else if (score >= 200) rarity = 'Rare';
                else if (score >= 100) rarity = 'Uncommon';

                return { score: Math.floor(Math.max(0, score)), rarity };
            }
        }

        let currentSoul;
        const svgContainer = document.getElementById('svg-container');

        function renderSoul() {
            const tokenId = parseInt(document.getElementById('tokenId').value) || 1;
            currentSoul = new Soul(tokenId);
            // Simulate some time has passed to show evolution
            const evolutionTime = 80 * TICK_DURATION * 5; // Simulate 5 beats
            currentSoul.lastUpdateTimestamp = (Date.now() / 1000) - evolutionTime;
            currentSoul.evolve(); 
            const svg = currentSoul.generateSVG();
            svgContainer.innerHTML = svg;
        }

        // Initial render
        renderSoul();
        const toggle = document.getElementById('dark-mode-toggle');
        toggle.addEventListener('click', () => document.body.classList.toggle('dark-mode'));
        // --- END OF EMBEDDED SOUL PREVIEW SCRIPT ---
    </script>
</body>
</html> 