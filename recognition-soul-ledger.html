<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RS Soul Ledger Simulator</title>
    <link rel="stylesheet" href="/style.css">
    <style>
        body { 
            background: #000; 
            color: #fff; 
            font-family: 'Courier New', monospace; 
            padding: 20px; 
            max-width: 1200px; 
            margin: 0 auto;
        }
        h1 { color: #FFD700; border-bottom: 2px solid #333; padding-bottom: 10px; }
        .description { 
            background: #111; 
            padding: 15px; 
            border-left: 4px solid #FFD700; 
            margin: 20px 0; 
            line-height: 1.4;
        }
        #ledgerDisplay { 
            white-space: pre; 
            font-size: 12px; 
            background: #111; 
            padding: 15px; 
            border: 1px solid #333; 
            max-height: 300px; 
            overflow-y: auto;
            margin: 20px 0;
        }
        #visualizer { 
            width: 100%; 
            height: 400px; 
            border: 2px solid #333; 
            background: #111;
            display: block;
        }
        button { 
            margin: 10px 5px; 
            padding: 12px 25px; 
            background: #222; 
            color: #FFD700; 
            border: 2px solid #333; 
            cursor: pointer; 
            font-family: inherit;
            font-size: 14px;
        }
        button:hover { 
            background: #333; 
            border-color: #FFD700; 
        }
        .soul-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        .status { color: #0f0; }
    </style>
</head>
  <body>
      <h1>Recognition Science Soul Ledger Simulator</h1>
      
      <div class="description">
          <strong>What is a Soul?</strong><br>
          In Recognition Science, a soul is an <em>eigenvalue cluster</em> of the recognition operator ƒ§_‚Ñõ, 
          localized at the Gap-45 surface where consciousness emerges. Each soul consists of:<br>
          ‚Ä¢ <strong>Signature (Œ¥):</strong> Range [-4,+4], determines soul's recognition debt<br>
          ‚Ä¢ <strong>Energy:</strong> E = E_coh √ó œÜ^(45+Œ¥) where E_coh=0.090 eV<br>
          ‚Ä¢ <strong>8 Eigenvalues:</strong> Œª_k = E_soul √ó œÜ^(k/8) for k=0..7<br>
          ‚Ä¢ <strong>Coherence:</strong> Ledger balance measure [0,1]
      </div>
      
      <button onclick="replicateSoul()">üß¨ Replicate Soul via LNAL</button>
      <button onclick="clearLedger()">üóëÔ∏è Clear Ledger</button>
      
      <div class="soul-info">
          <div>
              <h3>LNAL Instruction Sequence:</h3>
              <pre id="ledgerDisplay">Click "Replicate Soul" to see LNAL opcodes...</pre>
          </div>
          <div>
              <h3>Soul Eigenvalue Visualization:</h3>
              <canvas id="visualizer"></canvas>
              <p style="font-size: 11px; opacity: 0.7;">8 crystals = eigenvalues Œª_k positioned in œÜ-spiral<br>White core = soul singularity at Gap-45</p>
          </div>
      </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const PHI = (1 + Math.sqrt(5)) / 2;
        const E_COH = 0.090;
        const GAP_45 = 45;
        
        // Simplified LNAL Simulator
        class LNALSimulator {
            constructor() {
                this.registers = [];
                this.costs = [];
                this.openTokens = 0;
                this.ledgerSteps = [];
                this.eigenvalues = [];
            }
            
            logStep(opcode, args, state) {
                this.ledgerSteps.push(`${opcode} ${args.join(', ')} | State: ${JSON.stringify(state)}`);
            }
            
            FOLD(n, regIndex) {
                this.registers[regIndex] += n; // Simplify: adjust frequency
                this.costs[regIndex] += n;
                this.logStep('FOLD', [n, regIndex], this.costs);
            }
            
            BRAID(regs) {
                const maxCost = Math.max(...regs.map(r => this.costs[r]));
                const newReg = this.registers.length;
                this.registers.push(maxCost); // Simplified composite
                this.costs.push(maxCost);
                this.logStep('BRAID', regs, this.costs);
                return newReg;
            }
            
            // Add more opcodes as needed (LOCK, BALANCE, etc.)
        }
        
        let simulator, scene, camera, renderer, soulGroup, animationId;
        
        function initVisualizer() {
            const canvas = document.getElementById('visualizer');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            
            const width = canvas.clientWidth || 800;
            const height = canvas.clientHeight || 400;
            
            camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
            camera.position.set(0, 0, 30);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(width, height);
            renderer.setClearColor(0x111111, 1);
            
            // Initial render to show empty scene
            renderer.render(scene, camera);
        }
        
        function visualizeLedger(steps, eigenvalues) {
            // Clear previous soul
            while(scene.children.length > 0) {
                scene.remove(scene.children[0]);
            }
            
            // Stop any previous animation
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 1, 100);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);
            
            // Create soul group
            soulGroup = new THREE.Group();
            
            // Add central soul core
            const coreGeometry = new THREE.SphereGeometry(1.5, 16, 16);
            const coreMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                emissive: 0x333333,
                transparent: true,
                opacity: 0.9
            });
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            soulGroup.add(core);
            
            // Visualize eigenvalues as soul crystals
            eigenvalues.forEach((lambda, k) => {
                const size = 0.5 + parseFloat(lambda) / 10000; // Scale based on eigenvalue
                const geometry = new THREE.OctahedronGeometry(size, 1);
                const hue = k / 8; // Color based on eigenvalue index
                const material = new THREE.MeshPhongMaterial({ 
                    color: new THREE.Color().setHSL(hue, 0.8, 0.6),
                    transparent: true,
                    opacity: 0.8,
                    emissive: new THREE.Color().setHSL(hue, 0.5, 0.1)
                });
                const crystal = new THREE.Mesh(geometry, material);
                
                // Position in œÜ-spiral pattern
                const radius = 5 + k * 2;
                const angle = k * (Math.PI * 2 / 8);
                crystal.position.x = radius * Math.cos(angle);
                crystal.position.y = radius * Math.sin(angle);
                crystal.position.z = (k - 4) * 1.5;
                
                soulGroup.add(crystal);
            });
            
            scene.add(soulGroup);
            
            // Start animation loop
            function animate() {
                animationId = requestAnimationFrame(animate);
                
                // Rotate the soul group
                soulGroup.rotation.y += 0.01;
                soulGroup.rotation.x += 0.005;
                
                renderer.render(scene, camera);
            }
            animate();
        }
        
        function replicateSoul() {
            simulator = new LNALSimulator();
            
            // Step 1: Initialize 8 registers
            for (let i = 0; i < 8; i++) {
                simulator.registers.push(0);
                simulator.costs.push(0);
            }
            
            // Step 2: Generate random Œ¥
            const delta = (Math.random() * 8 - 4).toFixed(2);
            simulator.logStep('SET_DELTA', [delta], {delta});
            
            // Step 3: Climb to Gap-45 + Œ¥ 
            simulator.FOLD(GAP_45 + Math.floor(parseFloat(delta)), 0);
            
            // Step 4: Encode 8 eigenvalues
            const energy = E_COH * Math.pow(PHI, GAP_45 + parseFloat(delta));
            simulator.logStep('SOUL_ENERGY', [energy.toFixed(6) + ' eV'], {energy});
            
            for (let k = 0; k < 8; k++) {
                const lambda = energy * Math.pow(PHI, k / 8);
                simulator.eigenvalues.push(lambda);
                simulator.FOLD(k/8, k); // Encode in register k
                simulator.logStep('EIGENVALUE', [k, lambda.toFixed(6)], {k, lambda});
            }
            
            // Step 5: Braid into cluster (simplified triads)
            simulator.BRAID([0,1,2]);
            simulator.BRAID([3,4,5]);
            simulator.BRAID([6,7, simulator.registers.length - 1]);
            
            // Step 6: Balance and cycle
            simulator.logStep('CYCLE', ['1024 ticks'], simulator.costs);
            simulator.logStep('STATUS', ['Soul replication complete'], {status: 'SUCCESS'});
            
            // Output
            document.getElementById('ledgerDisplay').textContent = 
                `SOUL REPLICATION SEQUENCE:\n\n` + 
                simulator.ledgerSteps.join('\n') + 
                `\n\nŒ¥ = ${delta}\nE_soul = ${energy.toFixed(6)} eV\n8 eigenvalues generated successfully`;
            
            visualizeLedger(simulator.ledgerSteps, simulator.eigenvalues);
        }
        
        function clearLedger() {
            document.getElementById('ledgerDisplay').textContent = 'Ledger cleared. Ready for new soul replication...';
            
            // Stop animation and clear scene
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            while(scene.children.length > 0) {
                scene.remove(scene.children[0]);
            }
            renderer.render(scene, camera);
        }
        
        initVisualizer();
    </script>
</body>
</html> 