<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fresh Soul Image Generator - Recognition Science</title>
    <link rel="stylesheet" href="/style.css">
    <style>
        body {
            background: #f5f5f7;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2em;
        }
        
        h1 {
            font-family: 'VT323', monospace;
            font-size: 2.5em;
            margin-bottom: 1em;
        }
        
        #generateBtn {
            background: #007AFF;
            color: white;
            border: none;
            padding: 1em 2em;
            font-size: 1.2em;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            margin-bottom: 2em;
            transition: all 0.2s ease;
        }
        
        #generateBtn:hover {
            background: #0056CC;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 122, 255, 0.3);
        }
        
        #soulCanvas {
            border: 2px solid #000;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            background: #fff;
        }
        
        #downloadLink {
            margin-top: 1em;
            color: #007AFF;
            text-decoration: none;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <h1>ðŸŒŸ Fresh Soul Image Generator</h1>
    <button id="generateBtn">Generate New Soul Image</button>
    <canvas id="soulCanvas" width="1024" height="1024"></canvas>
    <a id="downloadLink" href="#" download="soul-image.png">Download Image</a>
    
    <script>
        // Core Constants
        const CANVAS_SIZE = 1024;
        const PHI = (1 + Math.sqrt(5)) / 2;
        const VIRTUES = [
            "Love", "Justice", "Forgiveness", "Wisdom", "Courage", 
            "Temperance", "Prudence", "Compassion", "Gratitude", 
            "Patience", "Humility", "Hope", "Creativity", "Sacrifice"
        ];
        
        // Sophisticated Color Systems (inspired by Mappan palettes with ethereal gradients)
        const COLOR_SYSTEMS = [
            {
                base: { r: 211, g: 47, b: 47 }, // Deep red
                accents: [
                    { r: 25, g: 118, b: 210 }, // Blue
                    { r: 245, g: 124, b: 0 }, // Orange
                    { r: 255, g: 215, b: 0 } // Gold
                ],
                sheen: { r: 255, g: 255, b: 255, a: 0.1 }
            },
            {
                base: { r: 123, g: 31, b: 162 }, // Purple
                accents: [
                    { r: 56, g: 142, b: 60 }, // Green
                    { r: 251, g: 192, b: 45 }, // Yellow
                    { r: 255, g: 87, b: 34 } // Deep orange
                ],
                sheen: { r: 237, g: 231, b: 246, a: 0.1 }
            },
            // Add more systems as needed for variety
        ];
        
        // Simple noise function for subtle textures
        function noise(x, y, scale) {
            const sinX = Math.sin(x * scale) * 0.5 + 0.5;
            const sinY = Math.sin(y * scale) * 0.5 + 0.5;
            return (sinX + sinY) / 2;
        }
        
        // Color interpolation
        function lerpColor(c1, c2, t) {
            return {
                r: Math.floor(c1.r + (c2.r - c1.r) * t),
                g: Math.floor(c1.g + (c2.g - c1.g) * t),
                b: Math.floor(c1.b + (c2.b - c1.b) * t)
            };
        }
        
        // Draw smooth gradient band
        function drawGradientBand(ctx, x1, y1, x2, y2, colors, width, opacity) {
            ctx.globalAlpha = opacity;
            const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
            colors.forEach((color, index) => {
                gradient.addColorStop(index / (colors.length - 1), `rgb(${color.r},${color.g},${color.b})`);
            });
            ctx.strokeStyle = gradient;
            ctx.lineWidth = width;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            ctx.globalAlpha = 1;
        }
        
        // Generate fresh soul image
        function generateSoulImage() {
            const canvas = document.getElementById('soulCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            
            // Random parameters
            const system = COLOR_SYSTEMS[Math.floor(Math.random() * COLOR_SYSTEMS.length)];
            const virtueValues = VIRTUES.map(() => Math.random() * 0.5 + 0.5); // Biased towards higher values for beauty
            const delta = Math.random() * 2 - 1;
            
            // Create base sheet (subtle textured background)
            for (let x = 0; x < CANVAS_SIZE; x += 1) {
                for (let y = 0; y < CANVAS_SIZE; y += 1) {
                    const n = noise(x, y, 0.01) * 0.05;
                    const color = lerpColor(system.base, system.sheen, n);
                    ctx.fillStyle = `rgba(${color.r},${color.g},${color.b},${system.sheen.a + n})`;
                    ctx.fillRect(x, y, 1, 1);
                }
            }
            
            // Central convergence point (soul core)
            const centerX = CANVAS_SIZE * (0.3 + delta * 0.1);
            const centerY = CANVAS_SIZE / 2;
            
            // Draw converging gradient bands (shining through)
            const bandCount = 8 + Math.floor(virtueValues[3] * 4); // Wisdom increases complexity
            const maxLength = CANVAS_SIZE * (0.4 + virtueValues[4] * 0.3); // Courage extends reach
            
            for (let i = 0; i < bandCount; i++) {
                const angle = (i / bandCount) * Math.PI * 2 + virtueValues[1] * Math.PI; // Justice symmetrizes
                const startX = centerX + Math.cos(angle) * maxLength;
                const startY = centerY + Math.sin(angle) * maxLength * (1 - virtueValues[11] * 0.5); // Hope pulls upward
                
                // Select colors with virtue influence
                const bandColors = [
                    lerpColor(system.accents[0], system.accents[1], virtueValues[i % 14]),
                    lerpColor(system.accents[1], system.accents[2], virtueValues[(i+1) % 14]),
                    lerpColor(system.accents[2], system.base, virtueValues[(i+2) % 14])
                ];
                
                // Draw band with glow
                ctx.shadowBlur = 10 + virtueValues[0] * 20; // Love increases glow
                ctx.shadowColor = `rgba(255,255,255,${virtueValues[7] * 0.3})`; // Compassion adds white sheen
                
                drawGradientBand(
                    ctx,
                    startX, startY,
                    centerX, centerY,
                    bandColors,
                    20 + virtueValues[5] * 30, // Temperance controls width
                    0.7 + virtueValues[2] * 0.3 // Forgiveness softens opacity
                );
            }
            
            // Add subtle fractal echoes (DMT-inspired)
            if (virtueValues[12] > 0.7) { // High Creativity
                const echoCount = Math.floor(virtueValues[12] * 3);
                for (let e = 0; e < echoCount; e++) {
                    const scale = 0.6 - e * 0.2;
                    const offsetX = centerX * (1 - scale);
                    const offsetY = centerY * (1 - scale);
                    ctx.globalAlpha = 0.2 * virtueValues[13]; // Sacrifice fades echoes
                    ctx.drawImage(canvas, offsetX, offsetY, CANVAS_SIZE * scale, CANVAS_SIZE * scale);
                    ctx.globalAlpha = 1;
                }
            }
            
            // Final sheen overlay
            const sheenGradient = ctx.createLinearGradient(0, 0, 0, CANVAS_SIZE);
            sheenGradient.addColorStop(0, `rgba(255,255,255,${virtueValues[8] * 0.1})`); // Gratitude adds top sheen
            sheenGradient.addColorStop(1, 'transparent');
            ctx.fillStyle = sheenGradient;
            ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            
            // Update download
            document.getElementById('downloadLink').href = canvas.toDataURL('image/png');
        }
        
        // Event listener
        document.getElementById('generateBtn').addEventListener('click', generateSoulImage);
        
        // Initial generation
        generateSoulImage();
    </script>
</body>
</html> 