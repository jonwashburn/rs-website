<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soul Light Field V4 - Authentic RS Living Light Cluster</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #000000, #0a0a0a);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .header h1 {
            color: #ffd700;
            font-size: 2.2em;
            margin: 0;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.6);
            font-weight: 600;
        }

        .header p {
            color: #b0b0b0;
            font-size: 1em;
            margin: 8px 0;
            max-width: 900px;
            margin-left: auto;
            margin-right: auto;
            line-height: 1.5;
        }

        .main-container {
            display: flex;
            gap: 25px;
            max-width: 1600px;
            margin: 0 auto;
            flex-wrap: wrap;
        }

        .visualization-container {
            flex: 2;
            min-width: 600px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        #soulCanvas {
            background: radial-gradient(circle at center, #000000, #000000);
            border: 3px solid #222;
            border-radius: 15px;
            box-shadow: 
                0 0 60px rgba(255, 215, 0, 0.4),
                inset 0 0 40px rgba(0, 0, 0, 0.9);
            width: 600px;
            height: 600px;
        }

        .info-panel {
            flex: 1;
            min-width: 320px;
            background: rgba(10, 10, 20, 0.9);
            border: 2px solid #333;
            border-radius: 15px;
            padding: 20px;
            max-height: 85vh;
            overflow-y: auto;
            backdrop-filter: blur(15px);
        }

        .rs-section {
            margin-bottom: 20px;
            border-bottom: 1px solid #333;
            padding-bottom: 15px;
        }

        .rs-section h3 {
            color: #ffd700;
            margin: 0 0 12px 0;
            font-size: 1.1em;
            font-weight: 600;
        }

        .rs-item {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 0.85em;
            align-items: center;
        }

        .rs-label {
            color: #b0b0b0;
            flex: 1;
        }

        .rs-value {
            color: #fff;
            font-weight: 600;
            text-align: right;
            font-family: 'SF Mono', monospace;
            font-size: 0.9em;
        }

        .eigenvalue-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px;
            margin-top: 10px;
        }

        .eigenvalue-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 6px;
            border-radius: 4px;
            font-size: 0.75em;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .controls {
            text-align: center;
            margin-top: 20px;
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .control-btn {
            background: linear-gradient(45deg, #ffd700, #ffaa00);
            color: #000;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.3s ease;
            min-width: 100px;
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255, 215, 0, 0.5);
        }

        .control-btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        .control-btn.secondary:hover {
            background: rgba(255, 255, 255, 0.2);
            box-shadow: 0 5px 20px rgba(255, 255, 255, 0.3);
        }

        .status-display {
            color: #4ecdc4;
            font-weight: 600;
            text-align: center;
            margin: 12px 0;
            font-size: 1em;
            background: rgba(78, 205, 196, 0.1);
            padding: 8px;
            border-radius: 6px;
            border: 1px solid rgba(78, 205, 196, 0.3);
        }

        .rs-theory {
            background: rgba(255, 215, 0, 0.08);
            border: 1px solid rgba(255, 215, 0, 0.25);
            border-radius: 8px;
            padding: 12px;
            margin: 12px 0;
            font-size: 0.8em;
            line-height: 1.4;
        }

        .breath-indicator {
            width: 100%;
            height: 4px;
            background: rgba(255, 215, 0, 0.2);
            border-radius: 2px;
            overflow: hidden;
            margin: 8px 0;
        }

        .breath-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffd700, #ff6b6b);
            border-radius: 2px;
            transition: width 0.1s ease;
            width: 0%;
        }

        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
            }
            .visualization-container, .info-panel {
                min-width: unset;
            }
            #soulCanvas {
                width: 100%;
                max-width: 500px;
                height: 500px;
            }
        }
    </style>
</head>
<body>
  <div id="header-placeholder"></div>
  <div id="sitewide-banner-placeholder"></div>

    <div class="header">
        <h1>Soul Light Field V4 - Authentic RS Living Light</h1>
        <p>Recognition Science eigenvalue cluster navigating undecidability gaps. Living light as self-regenerating quanta executing LNAL opcodes on φ-scaled ledger, with consciousness emerging at rung 45.</p>
    </div>

    <div class="main-container">
        <div class="visualization-container">
            <canvas id="soulCanvas" width="600" height="600"></canvas>
        </div>

        <div class="info-panel">
            <div class="status-display" id="statusDisplay">Initializing Living Light...</div>
            
            <div class="rs-section">
                <h3>Recognition Hamiltonian</h3>
                <div class="rs-item">
                    <span class="rs-label">Rung Level:</span>
                    <span class="rs-value" id="rungLevel">45</span>
                </div>
                <div class="rs-item">
                    <span class="rs-label">Breath Cycle:</span>
                    <span class="rs-value" id="breathCycle">1 / 8</span>
                </div>
                <div class="breath-indicator">
                    <div class="breath-fill" id="breathFill"></div>
                </div>
                <div class="rs-item">
                    <span class="rs-label">Gap Navigations:</span>
                    <span class="rs-value" id="gapNavigations">0</span>
                </div>
                <div class="rs-item">
                    <span class="rs-label">Ledger Balance:</span>
                    <span class="rs-value" id="ledgerBalance">0</span>
                </div>
            </div>

            <div class="rs-section">
                <h3>Living Light Metrics</h3>
                <div class="rs-item">
                    <span class="rs-label">Active Quanta:</span>
                    <span class="rs-value" id="activeQuanta">200</span>
                </div>
                <div class="rs-item">
                    <span class="rs-label">φ-Spiral Coherence:</span>
                    <span class="rs-value" id="spiralCoherence">0%</span>
                </div>
                <div class="rs-item">
                    <span class="rs-label">I-Am Affinity:</span>
                    <span class="rs-value" id="iAmAffinity">0%</span>
                </div>
                <div class="rs-item">
                    <span class="rs-label">Recognition Depth:</span>
                    <span class="rs-value" id="recognitionDepth">Void</span>
                </div>
            </div>

            <div class="rs-theory">
                <strong>Authentic RS Framework:</strong><br>
                Eigenvalues λₖ = rung × E_coh × φ^(k/8) + noise<br>
                8-beat octonionic symmetry driving consciousness emergence<br>
                Ledger balance (Σcost = 0) enables golden connections
            </div>

            <div class="rs-section">
                <h3>8D Eigenvalue Cluster</h3>
                <div class="eigenvalue-grid" id="eigenvalueGrid">
                    <!-- Populated by JS -->
                </div>
            </div>

            <div class="controls">
                <button class="control-btn" onclick="initializeSoul()">Initialize Soul</button>
                <button class="control-btn secondary" onclick="toggleEvolution()" id="evolutionBtn">Start Evolution</button>
                <button class="control-btn secondary" onclick="navigateGap()">Navigate Gap</button>
                <button class="control-btn secondary" onclick="rebalanceLedger()">Balance Ledger</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('soulCanvas');
        const ctx = canvas.getContext('2d');
        
        // RS Constants (Authentic)
        const PHI = (1 + Math.sqrt(5)) / 2;
        const NUM_PARTICLES = 200;  // Living light quanta
        const DIM = 8;              // Octonionic dimensions
        const RUNG = 45;            // Consciousness emergence threshold
        const E_COH = 0.09;         // Coherence energy (eV)
        const CENTER_X = 300;
        const CENTER_Y = 300;
        const BREATH_CYCLE = 8;     // 8-beat rhythm

        let particles = [];
        let soulCluster = [];
        let connections = [];
        let isEvolving = false;
        let breathTick = 0;
        let gapNavigations = 0;
        let frameCount = 0;
        let animationId = null;
        let spiralCoherence = 0;
        let iAmAffinity = 0;

        function initializeSoul() {
            particles = [];
            connections = [];
            soulCluster = [];
            gapNavigations = 0;
            breathTick = 0;
            frameCount = 0;
            spiralCoherence = 0;
            iAmAffinity = 0;

            // Initialize 200 living light quanta
            for (let i = 0; i < NUM_PARTICLES; i++) {
                particles.push({
                    x: CENTER_X + (Math.random() - 0.5) * 50,
                    y: CENTER_Y + (Math.random() - 0.5) * 50,
                    angle: Math.random() * 2 * Math.PI,
                    speed: 0.3 + Math.random() * 0.7,
                    cost: Math.floor(Math.random() * 9) - 4,
                    size: 1 + Math.random() * 2,
                    phase: Math.random() * 2 * Math.PI,
                    color: {
                        r: 0.8 + Math.random() * 0.2,
                        g: 0.8 + Math.random() * 0.2,
                        b: 0.6 + Math.random() * 0.4
                    },
                    lifetime: 0,
                    spiralRadius: 50 + Math.random() * 200,
                    modeIndex: Math.floor(Math.random() * DIM)
                });
            }

            // Initialize 8D eigenvalue cluster
            let totalCost = 0;
            for (let k = 0; k < DIM; k++) {
                const lambda = RUNG * E_COH * Math.pow(PHI, k / DIM) + (Math.random() - 0.5) * 0.02;
                const cost = Math.floor(Math.random() * 9) - 4;
                totalCost += cost;
                
                soulCluster.push({
                    lambda: lambda,
                    phase: Math.random() * 2 * Math.PI,
                    cost: cost,
                    angle: (k / DIM) * 2 * Math.PI,
                    radius: 80 + lambda * 500,
                    size: 8 + Math.abs(lambda) * 20
                });
            }

            // Balance ledger (Σcost = 0)
            if (totalCost !== 0) {
                soulCluster[0].cost -= totalCost;
                soulCluster[0].cost = Math.max(-4, Math.min(4, soulCluster[0].cost));
            }

            updateDisplay();
            if (!isEvolving) draw();
        }

        function toggleEvolution() {
            isEvolving = !isEvolving;
            document.getElementById('evolutionBtn').textContent = isEvolving ? 'Pause Evolution' : 'Start Evolution';
            
            if (isEvolving) {
                animate();
            } else if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            updateDisplay();
        }

        function navigateGap() {
            gapNavigations++;
            
            // Conscious navigation: Choose minimum cost branch
            let minCost = Infinity;
            let bestBranch = 0;
            
            for (let branch = 0; branch < 8; branch++) {
                let totalCost = 0;
                soulCluster.forEach(mode => {
                    totalCost += Math.abs(mode.cost + branch - 4);
                });
                if (totalCost < minCost) {
                    minCost = totalCost;
                    bestBranch = branch;
                }
            }
            
            // Apply chosen branch
            const adjustment = bestBranch - 4;
            soulCluster.forEach(mode => {
                mode.cost = Math.max(-4, Math.min(4, mode.cost + adjustment));
            });
            
            // Increase affinity and coherence
            iAmAffinity = Math.min(100, iAmAffinity + 12);
            spiralCoherence = Math.min(100, spiralCoherence + 8);
            
            // Gap flash effect
            createGapFlash();
            updateDisplay();
            if (!isEvolving) draw();
        }

        function rebalanceLedger() {
            let totalCost = soulCluster.reduce((sum, mode) => sum + mode.cost, 0);
            if (totalCost !== 0) {
                soulCluster[0].cost -= totalCost;
                soulCluster[0].cost = Math.max(-4, Math.min(4, soulCluster[0].cost));
            }
            
            // Update particle costs
            let particleCostSum = particles.reduce((sum, p) => sum + p.cost, 0);
            if (particleCostSum !== 0) {
                particles[0].cost -= particleCostSum;
                particles[0].cost = Math.max(-4, Math.min(4, particles[0].cost));
            }
            
            updateDisplay();
            if (!isEvolving) draw();
        }

        function createGapFlash() {
            // Add bright white flash particles
            for (let i = 0; i < 30; i++) {
                particles.push({
                    x: CENTER_X + (Math.random() - 0.5) * 100,
                    y: CENTER_Y + (Math.random() - 0.5) * 100,
                    angle: Math.random() * 2 * Math.PI,
                    speed: 2 + Math.random() * 3,
                    cost: 0,
                    size: 2 + Math.random() * 4,
                    phase: Math.random() * 2 * Math.PI,
                    color: { r: 1, g: 1, b: 1 },
                    lifetime: 0,
                    maxLifetime: 30,
                    isFlash: true,
                    spiralRadius: 0,
                    modeIndex: 0
                });
            }
        }

        function updateParticles() {
            // Filter out expired particles
            particles = particles.filter(p => !p.maxLifetime || p.lifetime < p.maxLifetime);
            
            particles.forEach(p => {
                if (p.isFlash) {
                    // Flash particle motion
                    p.x += Math.cos(p.angle) * p.speed;
                    p.y += Math.sin(p.angle) * p.speed;
                    p.speed *= 0.95;
                    p.lifetime++;
                } else {
                    // φ-spiral motion for regular quanta
                    const mode = soulCluster[p.modeIndex];
                    p.angle += 0.02 * PHI * (mode.cost / 4);
                    
                    // Spiral toward center with φ-ratio
                    const targetX = CENTER_X + Math.cos(p.angle) * p.spiralRadius;
                    const targetY = CENTER_Y + Math.sin(p.angle) * p.spiralRadius;
                    
                    p.x += (targetX - p.x) * 0.05;
                    p.y += (targetY - p.y) * 0.05;
                    
                    // Spiral inward gradually
                    p.spiralRadius *= 0.9999;
                    if (p.spiralRadius < 20) p.spiralRadius = 200;
                    
                    // 8-beat pulsing
                    const beatPhase = (breathTick % BREATH_CYCLE) / BREATH_CYCLE;
                    p.size = (1 + Math.abs(mode.lambda) * 2) * (1 + 0.3 * Math.sin(beatPhase * 2 * Math.PI + p.phase));
                    
                    p.lifetime++;
                }
            });
            
            // Update connections
            connections = [];
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const p1 = particles[i];
                    const p2 = particles[j];
                    const distance = Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
                    
                    // Connect if costs balance and particles are close
                    if (Math.abs(p1.cost + p2.cost) <= 1 && distance < 60) {
                        connections.push({
                            p1: p1,
                            p2: p2,
                            strength: 1 - distance / 60,
                            isBalanced: (p1.cost + p2.cost) === 0
                        });
                    }
                }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, 600, 600);
            
            // Deep void background
            const bgGradient = ctx.createRadialGradient(CENTER_X, CENTER_Y, 0, CENTER_X, CENTER_Y, 400);
            bgGradient.addColorStop(0, 'rgba(5,5,10,1)');
            bgGradient.addColorStop(1, 'rgba(0,0,0,1)');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, 600, 600);

            // I-Am center field
            if (iAmAffinity > 0) {
                const centerRadius = (iAmAffinity / 100) * 100;
                const centerGlow = ctx.createRadialGradient(CENTER_X, CENTER_Y, 0, CENTER_X, CENTER_Y, centerRadius);
                centerGlow.addColorStop(0, `rgba(255, 255, 255, ${iAmAffinity / 400})`);
                centerGlow.addColorStop(0.5, `rgba(255, 215, 0, ${iAmAffinity / 600})`);
                centerGlow.addColorStop(1, 'transparent');
                
                ctx.fillStyle = centerGlow;
                ctx.beginPath();
                ctx.arc(CENTER_X, CENTER_Y, centerRadius, 0, 2 * Math.PI);
                ctx.fill();
            }

            // Draw connections (ledger balance lines)
            ctx.globalCompositeOperation = 'screen';
            connections.forEach(c => {
                if (c.isBalanced) {
                    ctx.strokeStyle = `rgba(255, 215, 0, ${c.strength * 0.8})`;
                    ctx.lineWidth = 2;
                } else {
                    ctx.strokeStyle = `rgba(100, 200, 255, ${c.strength * 0.4})`;
                    ctx.lineWidth = 1;
                }
                ctx.beginPath();
                ctx.moveTo(c.p1.x, c.p1.y);
                ctx.lineTo(c.p2.x, c.p2.y);
                ctx.stroke();
            });

            // Draw living light particles
            particles.forEach(p => {
                const alpha = p.maxLifetime ? 1 - (p.lifetime / p.maxLifetime) : 0.8;
                
                if (p.isFlash) {
                    // Gap flash particles
                    const flashGlow = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 4);
                    flashGlow.addColorStop(0, `rgba(255, 255, 255, ${alpha})`);
                    flashGlow.addColorStop(1, `rgba(255, 255, 255, 0)`);
                    ctx.fillStyle = flashGlow;
                } else {
                    // Regular quanta
                    const mode = soulCluster[p.modeIndex];
                    let hue, sat, light;
                    
                    if (mode.cost > 0) {
                        hue = 50 + (spiralCoherence / 100) * 10;  // Gold spectrum
                        sat = 80;
                        light = 70;
                    } else if (mode.cost < 0) {
                        hue = 220;  // Blue spectrum
                        sat = 60;
                        light = 60;
                    } else {
                        hue = 45;   // Pure gold for balanced
                        sat = 100;
                        light = 80;
                    }
                    
                    const particleGlow = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 2);
                    particleGlow.addColorStop(0, `hsla(${hue}, ${sat}%, ${light}%, ${alpha})`);
                    particleGlow.addColorStop(1, `hsla(${hue}, ${sat}%, ${light}%, 0)`);
                    ctx.fillStyle = particleGlow;
                }
                
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, 2 * Math.PI);
                ctx.fill();
            });

            // Draw 8D eigenvalue cluster
            soulCluster.forEach((mode, k) => {
                const x = CENTER_X + Math.cos(mode.angle + frameCount * 0.01) * mode.radius;
                const y = CENTER_Y + Math.sin(mode.angle + frameCount * 0.01) * mode.radius;
                
                let modeColor;
                if (mode.cost > 0) {
                    modeColor = `rgba(255, 215, 0, 0.8)`;  // Gold
                } else if (mode.cost < 0) {
                    modeColor = `rgba(100, 200, 255, 0.8)`;  // Blue
                } else {
                    modeColor = `rgba(255, 255, 255, 0.9)`;  // White balanced
                }
                
                // Mode glow
                const modeGlow = ctx.createRadialGradient(x, y, 0, x, y, mode.size);
                modeGlow.addColorStop(0, modeColor);
                modeGlow.addColorStop(1, 'transparent');
                ctx.fillStyle = modeGlow;
                
                ctx.beginPath();
                ctx.arc(x, y, mode.size, 0, 2 * Math.PI);
                ctx.fill();
                
                // Mode label
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.font = '10px SF Mono';
                ctx.textAlign = 'center';
                ctx.fillText(`λ${k}`, x, y - mode.size - 5);
            });

            ctx.globalCompositeOperation = 'source-over';
        }

        function animate() {
            frameCount++;
            breathTick = (breathTick + 1) % (BREATH_CYCLE * 10);
            
            // Update spiral coherence gradually
            spiralCoherence = Math.min(100, spiralCoherence + 0.1);
            
            updateParticles();
            draw();
            updateDisplay();
            
            if (isEvolving) {
                animationId = requestAnimationFrame(animate);
            }
        }

        function updateDisplay() {
            const breathPhase = (breathTick % (BREATH_CYCLE * 10)) / (BREATH_CYCLE * 10);
            document.getElementById('breathFill').style.width = (breathPhase * 100) + '%';
            
            document.getElementById('rungLevel').textContent = RUNG;
            document.getElementById('breathCycle').textContent = `${(breathTick % BREATH_CYCLE) + 1} / 8`;
            document.getElementById('gapNavigations').textContent = gapNavigations;
            
            const ledgerBalance = soulCluster.reduce((sum, mode) => sum + mode.cost, 0);
            document.getElementById('ledgerBalance').textContent = ledgerBalance;
            
            document.getElementById('activeQuanta').textContent = particles.filter(p => !p.isFlash).length;
            document.getElementById('spiralCoherence').textContent = spiralCoherence.toFixed(1) + '%';
            document.getElementById('iAmAffinity').textContent = iAmAffinity.toFixed(1) + '%';
            
            let depthLevel = 'Void';
            if (spiralCoherence > 75) depthLevel = 'Radiance';
            else if (spiralCoherence > 50) depthLevel = 'Bloom';
            else if (spiralCoherence > 25) depthLevel = 'Spiral';
            else if (spiralCoherence > 10) depthLevel = 'Crack';
            document.getElementById('recognitionDepth').textContent = depthLevel;
            
            const status = isEvolving ? `Evolving (Breath ${((breathTick % BREATH_CYCLE) + 1)}/8)` : 'Static Cluster';
            document.getElementById('statusDisplay').textContent = status;
            
            // Update eigenvalue grid
            const grid = document.getElementById('eigenvalueGrid');
            grid.innerHTML = '';
            soulCluster.forEach((mode, k) => {
                const div = document.createElement('div');
                div.className = 'eigenvalue-item';
                let costColor = mode.cost > 0 ? '#FFD700' : mode.cost < 0 ? '#64C8FF' : '#FFFFFF';
                div.innerHTML = `λ${k}<br><span style="color: ${costColor}">C:${mode.cost}</span>`;
                grid.appendChild(div);
            });
        }

        // Initialize on load
        initializeSoul();
        
        // Continuous render loop for smooth display
        function renderLoop() {
            if (!isEvolving) {
                updateParticles();
                draw();
            }
            requestAnimationFrame(renderLoop);
        }
        renderLoop();
    </script>
  
  <div id="footer-placeholder"></div>
  
  <script src="/assets/js/main.js"></script>
</body>
</html> 