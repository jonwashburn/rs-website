<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Indisputable Chain (Lean) - Recognition Science</title>
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="stylesheet" href="/assets/css/site-template.css">
    <meta name="description" content="Formal, machine-checkable proofs of the Recognition Science foundation. Interactive Lean code explorer.">
    <style>
        /* Code viewer styles */
        .code-viewer-section {
            background: #f8f9fa;
            padding: 2rem 0;
            margin: 2rem 0;
        }

        .viewer-grid {
            display: grid;
            grid-template-columns: 1fr 280px;
            gap: 2rem;
            max-width: 1400px;
            margin: 0 auto;
        }

        .code-wrap {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            background: #0a0e1a;
            color: white;
            font-size: 0.875rem;
        }

        .code-header #status {
            color: #64748b;
            font-size: 0.75rem;
        }

        .code-body {
            background: #0a0e1a;
            padding: 1.5rem;
            overflow-x: auto;
            font-family: var(--font-mono);
            font-size: 0.875rem;
            line-height: 1.6;
            color: #a8b9cc;
            max-height: 600px;
            overflow-y: auto;
        }

        .code-line {
            display: flex;
            transition: all 0.15s ease;
            cursor: default;
            padding: 0.125rem 0;
        }

        .code-line:hover {
            background: rgba(59, 130, 246, 0.05);
        }

        .code-line.hotspot {
            cursor: pointer;
        }

        .code-line.hotspot:hover {
            background: rgba(255, 0, 110, 0.1);
        }

        .code-line.active {
            background: rgba(255, 0, 110, 0.15);
        }

        .ln {
            color: #475569;
            width: 3em;
            text-align: right;
            margin-right: 1.5rem;
            user-select: none;
            flex-shrink: 0;
        }

        .code-text {
            flex: 1;
            white-space: pre;
            overflow-wrap: anywhere;
        }

        /* Quick index sidebar */
        .quick-index {
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            position: sticky;
            top: 2rem;
            max-height: calc(100vh - 4rem);
            overflow-y: auto;
        }

        .quick-index h3 {
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--color-text-muted);
            margin-bottom: 1rem;
        }

        .quick-index ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .quick-index li {
            margin: 0;
        }

        .quick-index a {
            display: block;
            padding: 0.5rem 0;
            color: var(--color-text-body);
            text-decoration: none;
            font-size: 0.875rem;
            transition: all 0.15s ease;
            border-left: 2px solid transparent;
            padding-left: 0.75rem;
            margin-left: -0.75rem;
        }

        .quick-index a:hover {
            color: var(--color-accent);
            border-left-color: var(--color-accent);
        }

        /* Expansion styles */
        .expansion {
            padding: 1rem 1.5rem;
            background: #0b1220;
            border-left: 3px solid var(--color-accent);
            margin: 0.5rem 0 0.5rem 4.5rem;
            font-size: 0.75rem; /* smaller than code font */
            color: #e2e8f0;
            line-height: 1.6;
            border-radius: 0 4px 4px 0;
        }

        .expansion p {
            margin: 0.5rem 0;
            color: #e2e8f0;
        }

        .expansion strong {
            color: #ffffff;
            font-weight: 600;
        }

        .expansion h4 {
            margin: 0.25rem 0 0.25rem 0;
            color: var(--color-accent);
            font-size: 0.85em;
            letter-spacing: 0.02em;
        }

        .expansion .badge {
            display: inline-block;
            background: var(--color-accent);
            color: #fff;
            font-size: 0.65rem;
            padding: 0.1rem 0.5rem;
            border-radius: 999px;
            margin-right: 0.4rem;
        }

        .expansion .tag {
            display: inline-block;
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.15);
            color: #e2e8f0;
            font-size: 0.65rem;
            padding: 0.08rem 0.4rem;
            border-radius: 6px;
            margin-right: 0.25rem;
        }

        .expansion .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 0.75rem;
            margin-top: 0.5rem;
        }

        .expansion .card {
            background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 8px;
            padding: 0.6rem 0.75rem;
        }

        .expansion a {
            color: var(--color-accent-light);
            text-decoration: none;
        }

        .expansion a:hover {
            text-decoration: underline;
        }

        /* Reading tips */
        .reading-tip {
            background: var(--color-bg-subtle);
            border-left: 3px solid var(--color-primary);
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
            font-size: 0.95rem;
            color: var(--color-text-body);
            border-radius: 0 4px 4px 0;
        }

        .reading-tip strong {
            color: var(--color-primary);
        }

        /* Mobile adjustments */
        @media (max-width: 968px) {
            .viewer-grid {
                grid-template-columns: 1fr;
            }

            .quick-index {
                position: static;
                margin-top: 2rem;
            }

            .code-body {
                font-size: 0.75rem;
                padding: 1rem;
                max-width: 100%;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            .expansion {
                margin-left: 0;
                font-size: 0.7rem;
            }

            .code-text {
                white-space: pre-wrap; /* allow wrapping on mobile to avoid bleed */
                word-break: break-word;
                overflow-wrap: anywhere;
            }
        }
    </style>
</head>
<body class="template-page">
    <div id="header-placeholder"></div>

    <!-- Hero -->
    <section class="template-hero template-hero-framed">
        <div class="template-hero-content">
            <p class="template-hero-badge">FORMAL PROOFS</p>
            <h1 class="template-hero-title">The <span class="template-accent-text">Indisputable</span> Chain</h1>
            <p class="template-hero-lead">
                Machine-checkable Lean proofs from pure logic to physical constants
            </p>
        </div>
    </section>

    <!-- Introduction -->
    <section class="template-section">
        <div class="template-container">
            <div class="template-reading">
                <p class="lead-text">
                    This page presents the complete formal proof chain of Recognition Science, written in Lean 4. 
                    Every theorem is machine-verified, starting from pure logic and building to physical predictions.
                    <strong>No axioms are assumed</strong>—everything follows from logical necessity alone.
                </p>
            </div>

            <div class="reading-tip">
                <strong>Scientist's reading tip:</strong> Read the code as you would a short paper. Every highlighted line is interactive—click 
                to see what that snippet proves, how it connects, and why it's necessary. The proofs build sequentially: 
                each theorem uses only what came before.
            </div>
        </div>
    </section>

    <!-- Code Viewer -->
    <section class="code-viewer-section">
        <div class="template-container" style="max-width: 1400px;">
            <div class="viewer-grid">
                <div>
                    <div class="code-wrap" id="viewer">
                        <div class="code-header">
                            <div>Chain.lean — complete proof chain</div>
                            <div id="status" aria-live="polite"></div>
                        </div>
                        <div class="code-body" id="code"></div>
                    </div>
                </div>
                <aside class="quick-index">
                    <h3>Quick Index</h3>
                    <ul id="quick-index">
                        <li><a href="#" data-jump="MetaPrinciple">Meta‑Principle</a></li>
                        <li><a href="#" data-jump="RecognitionStructure">Recognition structure</a></li>
                        <li><a href="#" data-jump="Ledger">Ledger necessity</a></li>
                        <li><a href="#" data-jump="J_def">Unique cost J</a></li>
                        <li><a href="#" data-jump="φ_def">Golden ratio φ</a></li>
                        <li><a href="#" data-jump="k_equals_one">k = 1 minimal</a></li>
                        <li><a href="#" data-jump="period_exactly_8">8‑tick period</a></li>
                        <li><a href="#" data-jump="Chain">Final theorem</a></li>
                    </ul>
                </aside>
            </div>
        </div>
    </section>

    <!-- Key Insights -->
    <section class="template-section">
        <div class="template-container">
            <h2 class="template-section-title">Key Insights from the Proof</h2>
            
            <div class="insights-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.5rem; margin-top: 2rem;">
                <div class="template-reading">
                    <h3 style="color: var(--color-primary); margin-bottom: 0.75rem;">No Free Parameters</h3>
                    <p>Every constant emerges from logical constraints. The golden ratio φ appears as the unique self-similar fixed point. The 8-tick period follows from 3D completeness.</p>
                </div>

                <div class="template-reading">
                    <h3 style="color: var(--color-primary); margin-bottom: 0.75rem;">Ledger Uniqueness</h3>
                    <p>The double-entry ledger structure is <span class="template-accent-text">mathematically necessary</span>, not chosen. Any consistent accounting of recognition must take this form.</p>
                </div>

                <div class="template-reading">
                    <h3 style="color: var(--color-primary); margin-bottom: 0.75rem;">Cost Function J</h3>
                    <p>The function J(x) = ½(x + 1/x) - 1 is the <span class="template-accent-text">only</span> cost satisfying symmetry, convexity, and normalization. No alternatives exist.</p>
                </div>
            </div>
        </div>
    </section>

    <!-- Connection to Physics -->
    <section class="template-section">
        <div class="template-container">
            <div class="template-accent-bar"></div>
            <h2 class="template-section-title">From Logic to Physics</h2>
            
            <div class="template-reading template-reading-warm">
                <p>
                    The proof chain establishes that physical constants aren't arbitrary—they're the unique values 
                    that allow a self-consistent universe to exist. The Meta-Principle (nothing cannot recognize itself) 
                    forces the existence of a ledger, which must have specific mathematical properties. These properties 
                    determine all physical constants with no freedom to adjust.
                </p>
                
                <p style="margin-top: 1rem;">
                    This is why the framework makes precise, falsifiable predictions: change any assumption and the 
                    entire structure collapses. There are no knobs to turn, no parameters to fit. Either the logic 
                    holds and matches reality exactly, or it doesn't work at all.
                </p>
            </div>

            <div style="text-align: center; margin-top: 2rem;">
                <a href="/IndisputableMonolith.lean" class="template-btn" download>
                    Download IndisputableMonolith.lean
                </a>
            </div>
        </div>
    </section>

    <div id="footer-placeholder"></div>
    <script src="/assets/js/main.js"></script>

    <!-- Embedded fallback source -->
    <script type="text/plain" id="embedded-lean">/-!
  # The Indisputable Chain: Recognition Science from Pure Logic

  AXIOM-FREE: All claims are now theorems or definitions.

  Every line here is either:
  1. A definition (needs no proof)
  2. A theorem (proven from logic alone)
  3. A necessity claim (shows exactly what breaks without it)

  NO AXIOMS. NO HAND-WAVING. NO ALTERNATIVES. PURE LOGICAL NECESSITY.
  -/</script>

    <!-- Interactive code viewer script -->
    <script>
        // Markers: key snippets to annotate (pattern → key)
        const markers = [
            { key: 'imports', pattern: 'import Mathlib.Data.Real.Basic' },
            { key: 'symmetric_as_sum_function', pattern: 'lemma symmetric_as_sum_function' },
            { key: 'bounded_symmetric_is_linear', pattern: 'lemma bounded_symmetric_is_linear' },
            { key: 'CostUniqueness', pattern: 'theorem CostUniqueness' },
            { key: 'MetaPrinciple', pattern: 'theorem MetaPrinciple' },
            { key: 'RecognitionStructure', pattern: 'structure RecognitionStructure where' },
            { key: 'must_be_well_founded', pattern: 'theorem must_be_well_founded' },
            { key: 'Ledger', pattern: 'structure Ledger (M : RecognitionStructure) where' },
            { key: 'constructLedger', pattern: 'def constructLedger' },
            { key: 'ledger_exists', pattern: 'theorem ledger_exists' },
            { key: 'ledger_unique', pattern: 'theorem ledger_unique' },
            { key: 'ledger_delta_rigid', pattern: 'theorem ledger_delta_rigid' },
            { key: 'ledger_necessity_strong', pattern: 'theorem ledger_necessity_strong' },
            { key: 'must_have_atomic_unit', pattern: 'theorem must_have_atomic_unit' },
            { key: 'J_def', pattern: 'def J (x : ℝ) : ℝ' },
            { key: 'CostRequirements', pattern: 'structure CostRequirements (F : ℝ → ℝ)' },
            { key: 'J_works', pattern: 'theorem J_works' },
            { key: 'J_unique', pattern: 'theorem J_unique' },
            { key: 'φ_def', pattern: 'def φ : ℝ' },
            { key: 'φ_is_fixed_point', pattern: 'theorem φ_is_fixed_point' },
            { key: 'TickModel', pattern: 'structure TickModel where' },
            { key: 'no_fractional_k', pattern: 'theorem no_fractional_k' },
            { key: 'k_equals_one', pattern: 'theorem k_equals_one' },
            { key: 'Cube_def', pattern: 'def Cube := Fin 2 × Fin 2 × Fin 2' },
            { key: 'Adj_def', pattern: 'def Adj (u v : Cube) : Prop' },
            { key: 'HamWalk', pattern: 'structure HamWalk where' },
            { key: 'CompleteWalk', pattern: 'structure CompleteWalk where' },
            { key: 'period_at_least_8', pattern: 'theorem period_at_least_8' },
            { key: 'gray_ham', pattern: 'theorem gray_ham' },
            { key: 'period_exactly_8', pattern: 'theorem period_exactly_8' },
            { key: 'Chain', pattern: 'theorem Chain' },
        ];

        // Scientist-facing explanations
        const explain = {
            imports: `<p><strong>Context:</strong> Pulls standard real analysis, convexity, and tactics from mathlib. Nothing bespoke—only mainstream Lean libraries.</p>`,
            symmetric_as_sum_function: `<p><strong>Idea:</strong> Any cost symmetric under x↔1/x can be written as G(x+1/x). This reduces symmetry to a single even argument t=x+1/x—key to deriving J.</p>`,
            bounded_symmetric_is_linear: `<p><strong>Claim:</strong> With symmetry, convexity in log-scale, and a mild growth bound, costs must be linear in x+1/x: c(x+1/x)+d. This pins the functional form up to two constants.</p>`,
            CostUniqueness: `<p><strong>Uniqueness:</strong> Normalizing F(1)=0 and the sharp bound sets c=1/2, d=−1, yielding J(x)=½(x+1/x)−1. This is the unique admissible cost.</p>`,
            MetaPrinciple: `<p><strong>Tautology:</strong> "Nothing cannot recognize itself" as Empty has no inhabitants. Forces minimal existence of a recognizer/recognized relation.</p>`,
            RecognitionStructure: `<p><strong>Structure:</strong> What recognition must be to avoid paradox: nontriviality, well‑foundedness (no infinite regress), and local finiteness so counts are finite per node.</p>`,
            must_be_well_founded: `<p><strong>Necessity:</strong> Infinite ascending chains break auditing. Well‑foundedness is required to prevent contradictions.</p>`,
            Ledger: `<p><strong>Ledger:</strong> The only consistent accounting: double‑entry with atomic unit δ & conservation. Implemented as an ordered abelian group (ℤ in the canonical model).</p>`,
            constructLedger: `<p><strong>Construction:</strong> Builds the ledger concretely with integer counts: incoming/outgoing edges, δ=1. Shows existence.</p>`,
            ledger_exists: `<p><strong>Existence:</strong> Every recognition structure admits a ledger. Nothing model‑specific.</p>`,
            ledger_unique: `<p><strong>Uniqueness:</strong> Ledgers are isomorphic; δ>0 kills the negative isomorphism, so essentially unique.</p>`,
            ledger_delta_rigid: `<p><strong>Rigidity:</strong> δ, the least positive unit, is invariant under order automorphisms. Anchors the unit scale.</p>`,
            ledger_necessity_strong: `<p><strong>Combined:</strong> Existence + uniqueness gives the <em>necessary</em> ledger for any recognition structure.</p>`,
            must_have_atomic_unit: `<p><strong>Atomicity:</strong> Without a minimal δ, you can subdivide forever; costs lose meaning. Proves necessity of an indivisible unit.</p>`,
            J_def: `<p><strong>Definition:</strong> J(x)=½(x+1/x)−1, normalized so J(1)=0. This is the only cost satisfying the requirements.</p>`,
            CostRequirements: `<p><strong>Requirements:</strong> Symmetry, normalization, positivity, bounded growth, and log‑convexity. These exactly characterize J.</p>`,
            J_works: `<p><strong>Verification:</strong> Shows J meets every requirement. Convexity arises because J(exp t)=cosh t−1.</p>`,
            J_unique: `<p><strong>Only J:</strong> Any cost satisfying the requirements must equal J. No free functional degrees of freedom remain.</p>`,
            φ_def: `<p><strong>Golden ratio:</strong> φ=(1+√5)/2. Appears as the nontrivial self‑similar fixed point of the recurrence.</p>`,
            φ_is_fixed_point: `<p><strong>Fixed point:</strong> Solves x=1+1/x with x>0. This is the unique stable self‑similar scale.</p>`,
            TickModel: `<p><strong>Ticks:</strong> Local model with atomic postings δ per tick—enforces integer counts of sub‑recognitions.</p>`,
            no_fractional_k: `<p><strong>Integer k:</strong> Discreteness forces k∈ℕ in x=1+k/x. No fractional freedom—kills tuning.</p>`,
            k_equals_one: `<p><strong>k=1 minimal:</strong> Using strict convexity of cosh, the k‑partition cost is minimized at k=1. Picks φ uniquely.</p>`,
            Cube_def: `<p><strong>3‑cube:</strong> Encodes three spatial degrees; visiting all vertices models complete update coverage.</p>`,
            Adj_def: `<p><strong>Adjacency:</strong> Flip exactly one coordinate per step—locality constraint.</p>`,
            HamWalk: `<p><strong>Hamiltonian walk:</strong> Periodic path touching adjacent vertices only.</p>`,
            CompleteWalk: `<p><strong>Complete pass:</strong> Must visit all 8 vertices—represents a full update.</p>`,
            period_at_least_8: `<p><strong>Lower bound:</strong> Surjectivity → period ≥ number of vertices = 8. Cannot be fewer.</p>`,
            gray_ham: `<p><strong>Construction:</strong> Exhibit a Gray code with period 8 satisfying adjacency—achievability.</p>`,
            period_exactly_8: `<p><strong>Exactness:</strong> Combine lower bound and construction → minimal period is exactly 8.</p>`,
            Chain: `<p><strong>Final theorem:</strong> Assembles the entire chain: tautology → structure → ledger (necessary & unique) → unique cost J → unique scale φ → unique period 8.</p>`
        };

        // Render Lean file with line numbers and hotspots
        async function loadLean() {
            const status = document.getElementById('status');
            status.textContent = 'Loading…';

            // Try multiple sources
            const candidates = [
                'Chain.lean',
                'Chain.lean.txt',
                'https://raw.githubusercontent.com/jonwashburn/rs-website/main/Chain.lean'
            ];

            let text = null;
            for (const url of candidates) {
                try {
                    const res = await fetch(url, { cache: 'no-cache' });
                    if (res.ok) {
                        text = await res.text();
                        break;
                    }
                } catch (_) { /* continue */ }
            }

            // Fallback to embedded source
            if (!text) {
                const embedded = document.getElementById('embedded-lean');
                if (embedded && embedded.textContent) {
                    text = embedded.textContent;
                }
            }

            if (!text) {
                status.textContent = 'Load failed';
                return;
            }

            const lines = text.split('\n');
            const container = document.getElementById('code');
            container.innerHTML = '';

            // Build DOM lines
            lines.forEach((t, i) => {
                const line = document.createElement('div');
                line.className = 'code-line';
                line.dataset.idx = String(i + 1);
                
                const ln = document.createElement('div');
                ln.className = 'ln';
                ln.textContent = String(i + 1).padStart(3, ' ');
                
                const code = document.createElement('div');
                code.className = 'code-text';
                code.textContent = t.replace(/\t/g, '  ');
                
                line.appendChild(ln);
                line.appendChild(code);
                container.appendChild(line);
            });

            // Tag hotspots
            markers.forEach(m => {
                const idx = lines.findIndex(l => l.includes(m.pattern));
                if (idx >= 0) {
                    const el = container.children[idx];
                    el.classList.add('hotspot');
                    el.setAttribute('data-key', m.key);
                    el.title = 'Click for explanation';
                }
            });

            // Heuristic hotspots for most code items
            const defLike = /^(\s*)(def|theorem|lemma|structure|namespace)\s+([A-Za-z0-9_\.]+)/;
            lines.forEach((raw, i) => {
                const textLine = raw.trim();
                if (!textLine || textLine.startsWith('--') || textLine.startsWith('/-')) return;
                const m = textLine.match(defLike);
                if (m) {
                    const el = container.children[i];
                    if (!el.classList.contains('hotspot')) {
                        el.classList.add('hotspot');
                        el.setAttribute('data-kind', m[2]);
                        el.setAttribute('data-name', m[3]);
                        el.title = `Explain ${m[2]} ${m[3]}`;
                    }
                }
            });

            status.textContent = '';
        }

        // Expansion handling
        function clearActives(exceptLine) {
            document.querySelectorAll('.code-line.active').forEach(l => {
                if (l !== exceptLine) l.classList.remove('active');
            });
            document.querySelectorAll('.expansion.active').forEach(x => {
                if (!exceptLine || x.previousElementSibling !== exceptLine) x.remove();
            });
        }

        document.addEventListener('click', (e) => {
            const line = e.target.closest('.code-line');
            if (!line) return;
            const key = line.getAttribute('data-key');
            const kind = line.getAttribute('data-kind');
            const name = line.getAttribute('data-name');
            if (!key && !kind) return; // not a hotspot

            // Toggle expansion below this line
            const isActive = line.classList.contains('active');
            clearActives(isActive ? null : line);
            if (isActive) {
                line.classList.remove('active');
                return;
            }
            line.classList.add('active');

            const exp = document.createElement('div');
            exp.className = 'expansion active';
            if (key && explain[key]) {
                exp.innerHTML = decorate(explain[key], key);
            } else {
                const textLine = line.querySelector('.code-text')?.textContent || '';
                exp.innerHTML = decorate(genericExplain(kind || 'def', name || '', textLine), kind || 'def');
            }
            line.insertAdjacentElement('afterend', exp);
        });

        // Quick index jumps
        document.getElementById('quick-index').addEventListener('click', (e) => {
            const a = e.target.closest('a');
            if (!a) return;
            e.preventDefault();
            const key = a.getAttribute('data-jump');
            const target = document.querySelector(`.code-line[data-key="${key}"]`);
            if (target) {
                target.scrollIntoView({ behavior: 'smooth', block: 'center' });
                target.click();
            }
        });

        // Generic explanation generator for arbitrary code items
        function genericExplain(kind, name, text) {
            const safe = (s) => (s || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            const head = `<p><span class="badge">${kind.toUpperCase()}</span> <code>${safe(name)}</code></p>`;
            let body = '';
            switch (kind) {
                case 'structure':
                    body = `<p><strong>What it is:</strong> Declares a typed record bundling fields and invariants. In Lean, <em>structures</em> model mathematical objects with named components.</p>
                            <p><strong>Why it matters:</strong> Structures anchor the ontology of the proof: once a thing is a structure, every theorem can refer to its components by name. This prevents hand‑waving.</p>`;
                    break;
                case 'def':
                    body = `<p><strong>What it is:</strong> Introduces a definition. In Lean, <em>def</em> binds a name to a term with a precise type.</p>
                            <p><strong>Why it matters:</strong> Definitions are executable contracts. They eliminate ambiguity and make downstream reasoning composable.</p>`;
                    break;
                case 'theorem':
                case 'lemma':
                    body = `<p><strong>What it is:</strong> States a proposition and provides a proof term that the typechecker validates.</p>
                            <p><strong>Why it matters:</strong> Machine‑checked means there are no rhetorical shortcuts—only logic that compiles.</p>`;
                    break;
                case 'namespace':
                    body = `<p><strong>What it is:</strong> Opens a scope for related declarations, avoiding name collisions and clarifying provenance.</p>`;
                    break;
                default:
                    body = `<p><strong>Lean item:</strong> Parsed, typed, and checked by the kernel for full correctness.</p>`;
            }
            const linePreview = `<div class="card"><h4>Source</h4><pre style="white-space:pre-wrap;">${safe(text)}</pre></div>`;
            const links = `<div class="grid">
                <div class="card"><h4>See also</h4><p><a href="/glossary.html">Glossary</a><br><a href="/logical-foundations.html">Foundations</a><br><a href="/formulas/">Formulas</a></p></div>
                <div class="card"><h4>Role in the Chain</h4><p class="template-text-muted">Connects tautology → ledger → cost → φ → 8‑tick.</p></div>
            </div>`;
            return head + body + linePreview + links;
        }

        // Decorate explanation with color accents and “why it matters / how it fits” prompts
        function decorate(html, key) {
            const prompts = {
                MetaPrinciple: `<div class="card"><h4>Why it matters</h4><p>Everything starts here: a tautology that forbids absolute nothingness. It seeds the existence of a recognizer/recognized relation.</p></div>` ,
                Ledger: `<div class="card"><h4>Why it matters</h4><p>Double‑entry is not a metaphor—it's the only way to keep contradictions out. Every conservation law is this, wearing physics' clothes.</p></div>`,
                J_def: `<div class="card"><h4>Why it matters</h4><p>J pins the universe's sense of fairness. It kills tuning: there is no other convex, symmetric choice with the right invariances.</p></div>`,
                φ_def: `<div class="card"><h4>Why it matters</h4><p>φ is the scaling DNA. It plants the ladder that becomes masses, wavelengths, and timing relationships.</p></div>`,
                period_exactly_8: `<div class="card"><h4>Why it matters</h4><p>Eight is not numerology—it’s the minimal complete pass through 3D recognition. This is the clock behind quantum phase.</p></div>`
            };
            const extra = prompts[key] ? `<div class="grid">${prompts[key]}</div>` : '';
            return html + extra;
        }

        // Load on page ready
        loadLean();
    </script>
</body>
</html>
