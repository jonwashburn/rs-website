<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapan Replica Generator</title>
    
  <link rel="stylesheet" href="/assets/css/template-core.css">
</head>
<body class="academic-page">
  <div id="header-placeholder"></div>
  <div id="sitewide-banner-placeholder"></div>

    <h1>Mapan Sketchbook B Replica Generator</h1>
    <button onclick="generateImage()">Generate New Replica</button>
    <canvas id="canvas" width="1024" height="1024"></canvas>
    <a id="download" href="#" download="mappan-replica.png">Download Image</a>

    <script>
        const SIZE = 1024;
        const PHI = (1 + Math.sqrt(5)) / 2;
        const VIRTUES = ['Love', 'Justice', 'Forgiveness', 'Wisdom', 'Courage', 'Temperance', 'Prudence', 'Compassion', 'Gratitude', 'Patience', 'Humility', 'Hope', 'Creativity', 'Sacrifice'];
        
        // Enhanced color palettes based on Mappan's works
        const PALETTES = [
            { bg: '#D32F2F', stripes: ['#1976D2', '#FF9800', '#FFC107', '#2196F3', '#FF5722', '#FFEB3B'], arrow: '#000000' },
            { bg: '#1976D2', stripes: ['#D32F2F', '#FFC107', '#FF9800', '#E91E63', '#FF5722', '#F44336'], arrow: '#000000' },
            { bg: '#F57C00', stripes: ['#303F9F', '#FFEB3B', '#1976D2', '#FFC107', '#2196F3', '#FF9800'], arrow: '#000000' },
            { bg: '#4CAF50', stripes: ['#FFEB3B', '#F57C00', '#FFC107', '#FF9800', '#FF5722', '#E91E63'], arrow: '#000000' }
        ];
        
        // Simple seeded random
        function seededRand(seed) {
            seed = (seed * 9301 + 49297) % 233280;
            return seed / 233280;
        }
        
        // Convert hex to RGB
        function hexToRgb(hex) {
            hex = hex.replace('#', '');
            return { 
                r: parseInt(hex.substr(0,2), 16), 
                g: parseInt(hex.substr(2,2), 16), 
                b: parseInt(hex.substr(4,2), 16) 
            };
        }
        
        // Adjust color brightness
        function adjustColor(color, amount) {
            let col = hexToRgb(color);
            col.r = Math.max(0, Math.min(255, col.r + amount));
            col.g = Math.max(0, Math.min(255, col.g + amount));
            col.b = Math.max(0, Math.min(255, col.b + amount));
            return `rgb(${col.r},${col.g},${col.b})`;
        }
        
        // Enhanced texture with better blending
        function addTexture(ctx) {
            const imageData = ctx.getImageData(0, 0, SIZE, SIZE);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const noise = (Math.random() - 0.5) * 15; // Reduced for subtlety
                data[i] = Math.max(0, Math.min(255, data[i] + noise));
                data[i+1] = Math.max(0, Math.min(255, data[i+1] + noise));
                data[i+2] = Math.max(0, Math.min(255, data[i+2] + noise));
            }
            ctx.putImageData(imageData, 0, 0);
        }
        
        // Enhanced rotated rectangle with gradients
        function drawRotatedRect(ctx, x, y, w, h, angle, color, eigenvalue = 1) {
            ctx.save();
            ctx.translate(x + w/2, y + h/2);
            ctx.rotate(angle * Math.PI / 180);
            
            // Create gradient for depth
            const grad = ctx.createLinearGradient(0, -h/2, 0, h/2);
            grad.addColorStop(0, color);
            grad.addColorStop(0.5, adjustColor(color, Math.sin(eigenvalue) * 10)); // Eigenvalue modulates middle
            grad.addColorStop(1, adjustColor(color, -20)); // Darker at bottom
            
            ctx.fillStyle = grad;
            ctx.fillRect(-w/2, -h/2, w, h);
            
            // Add slight edge variation for hand-drawn feel
            const edgeNoise = eigenvalue * 2;
            ctx.strokeStyle = adjustColor(color, -30);
            ctx.lineWidth = 1 + Math.sin(eigenvalue) * 0.5;
            ctx.strokeRect(-w/2 + edgeNoise, -h/2, w - edgeNoise*2, h);
            
            ctx.restore();
        }
        
        // Enhanced chevron with virtue influence
        function drawChevron(ctx, x, y, size, color, angle, courage) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle * Math.PI / 180);
            
            // Courage affects boldness
            const boldness = 1 + courage * 0.5;
            const adjustedSize = size * boldness;
            
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(-adjustedSize/2, 0);
            ctx.lineTo(0, -adjustedSize/2);
            ctx.lineTo(adjustedSize/2, 0);
            ctx.lineTo(0, adjustedSize/2);
            ctx.closePath();
            ctx.fill();
            
            // Add subtle outline
            ctx.strokeStyle = adjustColor(color, 30);
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.restore();
        }
        
        function generateImage() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            
            // Enable anti-aliasing
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            const seed = Math.random() * 10000;
            
            // Recognition Physics parameters
            const delta = seededRand(seed) * 8 - 4; // RS delta
            const virtueScores = VIRTUES.map((_, i) => seededRand(seed + i * 10));
            const eigenvalues = new Array(8).fill(0).map((_, i) => PHI ** (i / 4)); // 8 eigenvalues
            
            // Select palette
            const palette = PALETTES[Math.floor(seededRand(seed) * PALETTES.length)];
            
            // Solid background with subtle gradient
            const bgGrad = ctx.createRadialGradient(SIZE/2, SIZE/2, 0, SIZE/2, SIZE/2, SIZE);
            bgGrad.addColorStop(0, palette.bg);
            bgGrad.addColorStop(1, adjustColor(palette.bg, -10));
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, SIZE, SIZE);
            
            // Composition area offset by delta (RS influence)
            const deltaOffset = delta * 0.02;
            const zoneX = SIZE * (0.1 + seededRand(seed+1) * 0.3 + deltaOffset);
            const zoneY = SIZE * (0.1 + seededRand(seed+2) * 0.3 + deltaOffset);
            const zoneW = SIZE * (0.4 + seededRand(seed+3) * 0.4);
            const zoneH = SIZE * (0.5 + seededRand(seed+4) * 0.3);
            
            // Base angle influenced by Justice virtue
            const baseAngle = -45 + seededRand(seed+5) * 90 + virtueScores[1] * 20; // Justice affects symmetry
            
            // Stripe count influenced by Wisdom
            const stripeCount = 4 + Math.floor(virtueScores[3] * 4); // Wisdom: 4-8 stripes
            const stripeSpacing = zoneW / (stripeCount - 1);
            
            // Draw stripes with eigenvalue influence
            for (let i = 0; i < stripeCount; i++) {
                const color = palette.stripes[i % palette.stripes.length];
                const eigenvalue = eigenvalues[i % 8];
                
                // Width influenced by Courage
                const width = (zoneW / stripeCount) * (0.8 + virtueScores[4] * 0.4);
                
                // Height influenced by eigenvalue
                const stripeHeight = zoneH * 1.2 * (1 + (eigenvalue % 1) * 0.3);
                
                const x = zoneX + i * stripeSpacing;
                const y = zoneY - zoneH * 0.1;
                
                drawRotatedRect(ctx, x, y, width, stripeHeight, baseAngle, color, eigenvalue);
            }
            
            // Arrow count influenced by Hope
            const arrowCount = 1 + Math.floor(virtueScores[11] * 2); // Hope: 1-3 arrows
            
            for (let i = 0; i < arrowCount; i++) {
                const chevX = zoneX + zoneW * (0.3 + seededRand(seed+20+i) * 0.4);
                const chevY = zoneY + zoneH * (0.3 + seededRand(seed+21+i) * 0.4);
                const chevSize = Math.min(zoneW, zoneH) * (0.2 + seededRand(seed+22+i) * 0.3);
                const chevAngle = baseAngle + seededRand(seed+23+i) * 180;
                
                drawChevron(ctx, chevX, chevY, chevSize, palette.arrow, chevAngle, virtueScores[4]); // Courage
            }
            
            // Add texture
            addTexture(ctx);
            
            // Subtle blur for blending
            ctx.filter = 'blur(0.5px)';
            ctx.drawImage(canvas, 0, 0);
            ctx.filter = 'none';
            
            // Add frame
            ctx.strokeStyle = adjustColor(palette.bg, -50);
            ctx.lineWidth = 3;
            ctx.strokeRect(1, 1, SIZE-2, SIZE-2);
            
            // Update download with seed
            document.getElementById('download').href = canvas.toDataURL('image/png');
            document.getElementById('download').download = `soul-mappan-${Math.floor(seed)}.png`;
        }
        
        generateImage(); // Initial
    </script>
  
  <div id="footer-placeholder"></div>
  
  <script src="/assets/js/main.js"></script>
</body>
</html> 