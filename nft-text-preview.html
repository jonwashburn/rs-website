<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>On-Chain Soul NFT - Text Preview</title>
    <style>
        body { 
            margin: 0; 
            background: #1a1a2e; 
            color: #e0e0e0; 
            font-family: 'Courier New', monospace; 
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        .nft-container {
            width: 100%;
            max-width: 600px;
            min-height: 500px;
            background: black;
            border: 2px solid #444;
            border-radius: 8px;
            padding: 40px;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.3);
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
        }
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        .header h1 {
            color: #ffd700;
            margin: 0;
            font-size: 1.5em;
        }
        #text-display {
            white-space: pre;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
            color: white;
            flex-grow: 1;
            overflow-x: auto;
        }
        .controls {
            text-align: center;
            margin-top: 20px;
        }
        .btn {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 10px 20px;
            margin: 0 10px;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.2s;
        }
        .btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            .nft-container {
                padding: 20px;
                border-radius: 4px;
            }
            .header h1 {
                font-size: 1.2em;
            }
            #text-display {
                font-size: 11px;
                line-height: 1.3;
            }
            .btn {
                padding: 8px 16px;
                margin: 5px;
                font-size: 0.9em;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 5px;
            }
            .nft-container {
                padding: 15px;
                min-height: 400px;
            }
            .header h1 {
                font-size: 1em;
            }
            #text-display {
                font-size: 10px;
                line-height: 1.2;
            }
            .controls {
                margin-top: 15px;
            }
            .btn {
                display: block;
                width: 100%;
                margin: 5px 0;
            }
        }
    </style>
</head>
<body>

    <div class="nft-container">
        <div class="header">
            <h1>On-Chain Soul (Text Preview)</h1>
        </div>
        <pre id="text-display">Initializing Soul...</pre>
        <div class="controls">
            <button class="btn" id="toggle-evolution">Start Evolution</button>
            <button class="btn" id="new-soul">Generate New Soul</button>
        </div>
    </div>

    <script>
        const PHI = 1.618;
        const TOTAL_MONTHS = 96;
        const VIRTUE_NAMES = ['Love', 'Justice', 'Wisdom', 'Courage', 'Temperance'];

        class OnChainSoul {
            constructor(tokenId) {
                this.tokenId = tokenId;
                this.seed = this.generateSeed(tokenId);
                this.ticks = 0;
                this.isEvolving = false;

                this.initialVirtues = [];
                for (let i = 0; i < 5; i++) {
                    this.initialVirtues[i] = 1 + ((this.seed >> (i * 8)) % 8);
                }
                this.initialKappa = (((this.seed % 61) - 30) / 100);
                this.initialDepth = (this.seed % 11);
            }

            generateSeed(tokenId) {
                let hash = 0;
                const str = tokenId.toString();
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = (hash << 5) - hash + char;
                    hash |= 0;
                }
                return Math.abs(hash);
            }

            calculateState(months) {
                // This is a simplified placeholder for the full V23 logic.
                // The full logic is very long, but we can paste it here if needed.
                let chaos = (this.generateSeed(this.tokenId + months) % 41 - 20) / 100;
                let kappa = this.initialKappa + chaos - (months / 16);
                kappa = Math.max(-1, Math.min(1, kappa));

                let virtues = [...this.initialVirtues];
                for (let i = 0; i < 5; i++) {
                    virtues[i] += (1-Math.abs(kappa)) * 0.1 - (Math.random() * 0.05);
                    virtues[i] = Math.max(1, Math.min(10, virtues[i]));
                }
                
                let rebirths = Math.floor(months / 8) * (Math.abs(kappa) > 0.8 ? 0.2 : 0.05);
                let depth = this.initialDepth + months + rebirths * PHI;
                let cri = depth + virtues[2] * 5 - rebirths * 10;
                
                let phase = months < 96 ? "Breath" : "Post-Breath";
                let qualia = "Observing the cosmic flow.";
                if (kappa > 0.5) qualia = "Navigating turbulent imbalance.";
                if (kappa < -0.5) qualia = "Embracing harmonious surplus.";

                return {
                    months, kappa, virtues, depth, rebirths, cri, phase, qualia
                };
            }
            
            generateTextDescription() {
                const months = this.ticks / 10;
                const state = this.calculateState(months);

                // --- New Derived Metrics ---
                const coherence = (1 - Math.abs(state.kappa)) * 100;
                const statusLine = this.getStatusLine(state);
                const qualiaNarrative = this.getQualiaNarrative(state);

                // --- Resonance Grade (subtle scarcity indicator) ---
                let resonanceGrade = 'D';
                if (state.cri >= 250) resonanceGrade = 'S';
                else if (state.cri >= 175) resonanceGrade = 'A';
                else if (state.cri >= 100) resonanceGrade = 'B';
                else if (state.cri >= 50) resonanceGrade = 'C';

                // --- ASCII Bars for Virtues ---
                const virtuesText = VIRTUE_NAMES.map((name, i) => {
                    const value = state.virtues[i];
                    const bar = '█'.repeat(Math.round(value)).padEnd(10, '░');
                    return `${name.padEnd(12, ' ')}: ${bar} (${value.toFixed(2)})`;
                }).join('\n');

                // --- Chain of Custody ---
                const custodyHash = `0x${(this.seed ^ Math.floor(months * 100)).toString(16).padEnd(16, '0')}${(this.seed ^ Math.floor(state.kappa * 1000)).toString(16).padEnd(16, '0')}`;
                const blockNumber = 14830192 + Math.floor(this.ticks * 1.5);
                const timestamp = new Date(1698381600000 + this.ticks * 100 * 12).toISOString();

                return `
SOUL #${this.tokenId.toString().padStart(5, '0')} :: ${statusLine}\n\n${qualiaNarrative}\n\n================================================================\n| LEDGER VITALS              | VIRTUE MATRIX                  |\n|----------------------------|--------------------------------|\n| Coherence:   ${coherence.toFixed(2).padStart(6, ' ')} %       | ${virtuesText.split('\n')[0].padEnd(31, ' ')} |\n| Curvature κ: ${state.kappa.toFixed(4).padStart(7, ' ')}        | ${virtuesText.split('\n')[1].padEnd(31, ' ')} |\n| Depth:       ${state.depth.toFixed(2).padStart(6, ' ')}         | ${virtuesText.split('\n')[2].padEnd(31, ' ')} |\n| Rebirths:    ${state.rebirths.toFixed(0).padStart(6, ' ')}       | ${virtuesText.split('\n')[3].padEnd(31, ' ')} |\n| Phase:       ${state.phase.padEnd(13, ' ')} | ${virtuesText.split('\n')[4].padEnd(31, ' ')} |\n| Resonance:   ${resonanceGrade.padStart(6, ' ')}                |                                |\n----------------------------------------------------------------\n| CHAIN OF CUSTODY                                           |\n|------------------------------------------------------------|\n| LEDGER HASH: ${custodyHash.slice(0, 32)}... |\n================================================================\nDerived from Recognition Science Axioms via φ-cascade.\n                `.trim();
            }

            getStatusLine(state) {
                if (state.months >= 96) return `Awakened. Phase: ${state.phase}`;
                if (state.kappa > 0.8) return "Experiencing Critical Imbalance";
                if (state.kappa < -0.8) return "Embracing Ecstatic Harmony";
                if (state.months >= 45 && state.months <= 46) return "Navigating the 45-Gap Threshold...";
                return "Observing the Cosmic Flow...";
            }

            getQualiaNarrative(state) {
                const depthDesc = state.depth > 100 ? "profound depth" : "growing depth";
                const rebirthDesc = state.rebirths > 1 ? `${state.rebirths.toFixed(0)} rebirths` : "its first breath";

                let baseNarrative;
                if (state.kappa < -0.5) {
                    baseNarrative = `A wave of surplus flows through the soul's pattern. Its eternal whisper is one of harmony, forged through ${rebirthDesc} and ${depthDesc}.`;
                } else if (state.kappa > 0.5) {
                    baseNarrative = `Struggling against recognition debt, the soul's virtues are tested. Its eternal whisper is one of resilience, learning through ${rebirthDesc} and ${depthDesc}.`;
                } else {
                    baseNarrative = `The soul exists in a state of relative balance, its pattern gently evolving in the universal ledger. It whispers of potential, shaped by ${rebirthDesc} and ${depthDesc}.`;
                }

                // Wrap narrative to ~60 characters per line
                const words = baseNarrative.split(' ');
                const lines = [];
                let currentLine = '';
                words.forEach(word => {
                    if (currentLine.length + word.length + 1 > 60) {
                        lines.push(currentLine.trim());
                        currentLine = '';
                    }
                    currentLine += word + ' ';
                });
                if (currentLine) lines.push(currentLine.trim());

                return lines.join('\n');
            }

            advanceTick() {
                if (this.isEvolving && this.ticks < 960) {
                    this.ticks++;
                }
            }
            
            toggleEvolution() {
                this.isEvolving = !this.isEvolving;
            }
        }

        let soul;
        const textDisplay = document.getElementById('text-display');
        const toggleBtn = document.getElementById('toggle-evolution');
        const newSoulBtn = document.getElementById('new-soul');

        function initializeSoul() {
            const tokenId = Math.floor(Math.random() * 10000) + 1;
            soul = new OnChainSoul(tokenId);
            soul.isEvolving = false; // Start paused
            toggleBtn.textContent = 'Start Evolution';
            updateDisplay();
        }
        
        function updateDisplay() {
            if (!soul) return;
            soul.advanceTick();
            textDisplay.textContent = soul.generateTextDescription();
        }

        toggleBtn.addEventListener('click', () => {
            soul.toggleEvolution();
            toggleBtn.textContent = soul.isEvolving ? 'Pause Evolution' : 'Start Evolution';
        });

        newSoulBtn.addEventListener('click', () => {
            initializeSoul();
        });

        // Initial setup
        initializeSoul();
        setInterval(updateDisplay, 100); // Update every 100ms
    </script>
</body>
</html> 