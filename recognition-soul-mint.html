<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soul Mint: Iconic Recognition Science Generative Art</title>
    <link rel="stylesheet" href="/style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
        }
        
        .foundation-nav {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            background: rgba(0,0,0,0.9);
            backdrop-filter: blur(20px);
            padding: 15px 0;
        }
        
        .foundation-nav .nav-links {
            display: flex;
            justify-content: center;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px;
            flex-wrap: wrap;
        }
        
        .foundation-nav a {
            color: #fff;
            text-decoration: none;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.3s ease;
            opacity: 0.7;
        }
        
        .foundation-nav a:hover {
            opacity: 1;
            color: #FFD700;
        }
        
        #soulCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }
        
        .soul-interface {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            text-align: center;
        }
        
        .mint-button {
            background: linear-gradient(45deg, rgba(255,215,0,0.15), rgba(255,255,255,0.05));
            border: 2px solid rgba(255,215,0,0.4);
            color: #fff;
            padding: 18px 45px;
            font-size: 16px;
            font-weight: 600;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.4s ease;
            backdrop-filter: blur(30px);
            box-shadow: 0 8px 32px rgba(255,215,0,0.15);
            position: relative;
            overflow: hidden;
        }
        
        .mint-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,215,0,0.2), transparent);
            transition: left 0.6s ease;
        }
        
        .mint-button:hover::before {
            left: 100%;
        }
        
        .mint-button:hover {
            background: linear-gradient(45deg, rgba(255,215,0,0.25), rgba(255,255,255,0.1));
            border-color: rgba(255,215,0,0.7);
            box-shadow: 0 12px 48px rgba(255,215,0,0.3);
            transform: translateY(-3px);
        }
        
        .soul-metadata {
            position: fixed;
            top: 100px;
            right: 40px;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(30px);
            border: 1px solid rgba(255,215,0,0.3);
            border-radius: 20px;
            padding: 25px;
            color: #fff;
            font-size: 14px;
            max-width: 320px;
            opacity: 0;
            transform: translateX(100px);
            transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        
        .soul-metadata.visible {
            opacity: 1;
            transform: translateX(0);
        }
        
        .metadata-header {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255,215,0,0.2);
        }
        
        .soul-title {
            font-size: 18px;
            font-weight: 700;
            color: #FFD700;
            margin-bottom: 5px;
        }
        
        .rarity-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .rarity-common { background: rgba(100,100,100,0.3); color: #ccc; }
        .rarity-rare { background: rgba(0,150,255,0.3); color: #4FC3F7; }
        .rarity-epic { background: rgba(150,0,255,0.3); color: #AB47BC; }
        .rarity-legendary { background: rgba(255,215,0,0.3); color: #FFD700; }
        .rarity-mythic { background: rgba(255,100,0,0.3); color: #FF6D00; }
        
        .metadata-row {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,215,0,0.08);
        }
        
        .metadata-label {
            opacity: 0.7;
            font-size: 13px;
        }
        
        .metadata-value {
            color: #FFD700;
            font-weight: 600;
            font-size: 13px;
        }
        
        .traits-section {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(255,215,0,0.2);
        }
        
        .traits-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 10px;
            color: #FFD700;
        }
        
        .trait-tag {
            display: inline-block;
            background: rgba(255,215,0,0.1);
            color: #FFD700;
            padding: 3px 8px;
            margin: 2px;
            border-radius: 8px;
            font-size: 11px;
            border: 1px solid rgba(255,215,0,0.2);
        }
        
        .birth-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(circle, rgba(255,215,0,0.15) 0%, rgba(0,0,0,0.95) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            color: #FFD700;
            font-size: 28px;
            font-weight: 300;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 1s ease;
        }
        
        .birth-overlay.active {
            opacity: 1;
        }
        
        .birth-subtitle {
            font-size: 16px;
            opacity: 0.7;
            margin-top: 10px;
            font-weight: 400;
        }
        
        .export-controls {
            position: fixed;
            bottom: 40px;
            right: 40px;
            z-index: 1000;
        }
        
        .export-button {
            background: rgba(0,0,0,0.8);
            border: 1px solid rgba(255,215,0,0.3);
            color: #FFD700;
            padding: 10px 20px;
            font-size: 12px;
            border-radius: 20px;
            cursor: pointer;
            backdrop-filter: blur(20px);
            transition: all 0.3s ease;
            margin-left: 10px;
        }
        
        .export-button:hover {
            background: rgba(255,215,0,0.1);
            border-color: rgba(255,215,0,0.6);
        }
        
        @media (max-width: 768px) {
            .foundation-nav .nav-links {
                gap: 12px;
            }
            
            .foundation-nav a {
                font-size: 12px;
            }
            
            .soul-metadata {
                right: 20px;
                top: 80px;
                max-width: 280px;
                padding: 20px;
            }
            
            .export-controls {
                bottom: 120px;
                right: 20px;
            }
        }
    </style>
  <link rel="stylesheet" href="/assets/css/site-template.css">
</head>
<body class="template-page">
  <div id="header-placeholder"></div>
  <div id="sitewide-banner-placeholder"></div>

    <nav class="foundation-nav">
        <div class="nav-links">
            <a href="/index.html">Home</a>
            <a href="/foundations.html">Foundations</a>
            <a href="/rs-predictions.html">Predictions</a>
            <a href="/pattern-layer.html">Pattern Layer</a>
            <a href="/recognition-art.html">Ledger of Light</a>
            <a href="/recognition-scribbles.html">Scribbles</a>
            <a href="/recognition-whispers.html">Whispers</a>
            <a href="/recognition-eternal.html">Eternal Scripts</a>
            <a href="/recognition-souls.html">Soul Harmonics</a>
            <a href="/recognition-mirror.html">Infinite Mirror</a>
            <a href="/recognition-flows.html">Phi Flows</a>
            <a href="/recognition-soul-flower.html">Soul Flower</a>
            <a href="/recognition-soul-birth.html">Soul Birth</a>
            <a href="/recognition-soul-birth-animated.html">Soul Birth Animation</a>
            <a href="/recognition-soul-mint.html">Soul Mint</a>
            <a href="/papers/index.html">Papers</a>
            <a href="/journal.html">Journal</a>
        </div>
    </nav>

    <canvas id="soulCanvas"></canvas>
    
    <div class="birth-overlay" id="birthOverlay">
        <div>Soul Emerging from the Quantum Void...</div>
        <div class="birth-subtitle">Recognition Science Entity Materializing</div>
    </div>
    
    <div class="soul-metadata" id="soulMetadata">
        <div class="metadata-header">
            <div class="soul-title" id="soulTitle">Quantum Soul #000000</div>
            <div class="rarity-badge" id="rarityBadge">Common</div>
        </div>
        
        <div class="metadata-row">
            <span class="metadata-label">Signature (δ)</span>
            <span class="metadata-value" id="soulDelta">+0.000</span>
        </div>
        <div class="metadata-row">
            <span class="metadata-label">Energy Level</span>
            <span class="metadata-value" id="soulEnergy">0.000 eV</span>
        </div>
        <div class="metadata-row">
            <span class="metadata-label">Coherence</span>
            <span class="metadata-value" id="soulCoherence">0.0%</span>
        </div>
        <div class="metadata-row">
            <span class="metadata-label">Formation</span>
            <span class="metadata-value" id="soulFormation">Spiral</span>
        </div>
        <div class="metadata-row">
            <span class="metadata-label">Density</span>
            <span class="metadata-value" id="soulDensity">0.0</span>
        </div>
        <div class="metadata-row">
            <span class="metadata-label">Resonance</span>
            <span class="metadata-value" id="soulResonance">260°</span>
        </div>
        <div class="metadata-row">
            <span class="metadata-label">Gap Rung</span>
            <span class="metadata-value" id="soulRung">45</span>
        </div>
        
        <div class="traits-section">
            <div class="traits-title">Traits</div>
            <div id="soulTraits">
                <span class="trait-tag">Standard Eigenvalues</span>
                <span class="trait-tag">Living Light Field</span>
            </div>
        </div>
        
        <div style="margin-top: 20px; font-size: 11px; opacity: 0.5; text-align: center; font-family: 'Courier New', monospace;">
            E = E_coh × φ^(45+δ)
        </div>
    </div>
    
    <div class="soul-interface">
        <button class="mint-button" onclick="mintNewSoul()">
            ✨ Generate Soul Entity
        </button>
    </div>
    
    <div class="export-controls">
        <button class="export-button" onclick="exportSoulImage()">📸 Capture</button>
        <button class="export-button" onclick="exportSoulData()">💾 Data</button>
    </div>

    <script>
        // Recognition Science constants
        const PHI = (1 + Math.sqrt(5)) / 2;
        const E_COH = 0.090;
        const GAP_45 = 45;
        const TAU = Math.PI * 2;
        
        // Three.js scene globals
        let scene, camera, renderer, composer;
        let livingLightSystem, soulCluster, trailSystem;
        let currentSoul = null;
        let time = 0;
        let isBirthing = false;
        let cameraOrbit = { radius: 400, theta: 0, phi: 0.3 };
        
        // Advanced shader for living light with curl noise
        const livingLightVertexShader = `
            attribute vec3 position;
            attribute float phase;
            attribute float radius;
            attribute vec3 velocity;
            uniform float u_time;
            uniform mat4 modelViewMatrix;
            uniform mat4 projectionMatrix;
            varying float vBeat;
            varying vec3 vPosition;
            varying float vDepth;
            
            // Simplex noise function
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            
            float snoise(vec3 v) {
                const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i = floor(v + dot(v, C.yyy));
                vec3 x0 = v - i + dot(i, C.xxx);
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min(g.xyz, l.zxy);
                vec3 i2 = max(g.xyz, l.zxy);
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;
                i = mod289(i);
                vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                float n_ = 0.142857142857;
                vec3 ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_);
                vec4 x = x_ *ns.x + ns.yyyy;
                vec4 y = y_ *ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4(x.xy, y.xy);
                vec4 b1 = vec4(x.zw, y.zw);
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
                vec3 p0 = vec3(a0.xy, h.x);
                vec3 p1 = vec3(a0.zw, h.y);
                vec3 p2 = vec3(a1.xy, h.z);
                vec3 p3 = vec3(a1.zw, h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                p0 *= norm.x;
                p1 *= norm.y;
                p2 *= norm.z;
                p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
            }
            
            void main() {
                // Eight-beat cycle with φ modulation
                float eightBeat = sin(8.0 * u_time + phase);
                vBeat = 0.3 + 0.7 * (0.5 + 0.5 * eightBeat);
                
                // Curl noise for organic movement
                vec3 pos = position;
                float n1 = snoise(pos * 0.01 + u_time * 0.1);
                float n2 = snoise(pos * 0.01 + u_time * 0.1 + 100.0);
                pos.x += n1 * 20.0;
                pos.y += n2 * 20.0;
                
                vPosition = pos;
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                vDepth = -mvPosition.z;
                
                gl_Position = projectionMatrix * mvPosition;
                gl_PointSize = radius * vBeat * (400.0 / vDepth);
            }
        `;
        
        const livingLightFragmentShader = `
            #define PHI 1.618033988749
            uniform float u_time;
            varying float vBeat;
            varying vec3 vPosition;
            varying float vDepth;
            
            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }
            
            float noise(vec2 p) {
                return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
            }
            
            void main() {
                vec2 coord = gl_PointCoord - 0.5;
                float dist = length(coord);
                
                if (dist > 0.5) discard;
                
                // Soft circular falloff with inner glow
                float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                alpha = pow(alpha, 1.5) * vBeat * 0.05;
                
                // Depth-based intensity
                alpha *= smoothstep(800.0, 200.0, vDepth);
                
                // Living light colors with interference patterns
                float n = noise(vPosition.xy * 0.01 + u_time * 0.5);
                vec3 baseColor = vec3(1.0);
                
                // Subtle pastel interference based on φ
                vec3 interference = 0.3 * vec3(
                    sin(vPosition.x * PHI * 0.01 + u_time),
                    sin(vPosition.y * PHI * 0.01 + u_time + 2.094),
                    sin(vPosition.z * PHI * 0.01 + u_time + 4.188)
                );
                
                vec3 color = baseColor + interference;
                color = mix(color, vec3(1.0, 0.9, 0.7), n * 0.2);
                
                gl_FragColor = vec4(color, alpha);
            }
        `;
        
        // Enhanced soul crystal shader with procedural textures
        const soulCrystalVertexShader = `
            uniform float u_time;
            uniform float u_coherence;
            uniform float u_hue;
            uniform float u_scale;
            uniform float u_formation;
            varying vec3 vNormal;
            varying vec3 vPosition;
            varying vec3 vWorldPosition;
            varying float vBeat;
            varying float vNoise;
            
            float snoise(vec3 v); // Forward declaration
            
            void main() {
                vNormal = normalize(normalMatrix * normal);
                vPosition = position;
                
                // Eight-beat with φ harmonic
                vBeat = 0.5 + 0.5 * sin(8.0 * u_time + length(position) * 0.1);
                
                // Procedural surface noise
                vNoise = snoise(position * 0.5 + u_time * 0.2);
                
                // Scale with formation influence
                vec3 pos = position * u_scale;
                
                // Slight organic deformation
                pos += normal * vNoise * 0.3 * u_coherence;
                
                vec4 worldPos = modelMatrix * vec4(pos, 1.0);
                vWorldPosition = worldPos.xyz;
                
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `;
        
        const soulCrystalFragmentShader = `
            uniform float u_time;
            uniform float u_coherence;
            uniform float u_hue;
            uniform float u_formation;
            varying vec3 vNormal;
            varying vec3 vPosition;
            varying vec3 vWorldPosition;
            varying float vBeat;
            varying float vNoise;
            
            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }
            
            float noise(vec2 p) {
                return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
            }
            
            void main() {
                vec3 normal = normalize(vNormal);
                vec3 viewDir = normalize(cameraPosition - vWorldPosition);
                
                // Enhanced Fresnel with coherence influence
                float fresnel = pow(1.0 - abs(dot(normal, viewDir)), 2.0 + u_coherence);
                
                // Procedural crystal faceting
                float facetNoise = noise(vPosition.xy * 10.0);
                float facets = smoothstep(0.3, 0.7, facetNoise);
                
                // Dynamic hue with noise variation
                float hueShift = vNoise * 30.0 * (1.0 - u_coherence);
                float saturation = 0.4 + 0.4 * u_coherence + vNoise * 0.1;
                vec3 soulColor = hsv2rgb(vec3((u_hue + hueShift) / 360.0, saturation, 0.85 + vBeat * 0.15));
                
                // Inner glow based on beat and coherence
                float innerGlow = pow(fresnel, 0.5) * u_coherence * vBeat;
                vec3 glowColor = hsv2rgb(vec3(u_hue / 360.0, 0.8, 1.0));
                
                // Combine colors with faceted look
                vec3 color = mix(soulColor, glowColor, innerGlow);
                color = mix(color, vec3(1.0), facets * 0.2 * fresnel);
                
                // Formation-based effects
                if (u_formation > 1.5) { // Vortex formation
                    float spiral = sin(atan(vPosition.y, vPosition.x) * 5.0 + u_time * 2.0);
                    color = mix(color, glowColor, spiral * 0.1);
                }
                
                float alpha = u_coherence * (0.6 + 0.4 * vBeat) * (0.8 + 0.2 * fresnel);
                
                gl_FragColor = vec4(color, alpha);
            }
        `;
        
        // Trail system for crystal paths
        class CrystalTrail {
            constructor(maxPoints = 50) {
                this.points = [];
                this.maxPoints = maxPoints;
                this.geometry = new THREE.BufferGeometry();
                this.material = new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.3,
                    blending: THREE.AdditiveBlending
                });
                this.line = new THREE.Line(this.geometry, this.material);
            }
            
            addPoint(position) {
                this.points.push(position.clone());
                if (this.points.length > this.maxPoints) {
                    this.points.shift();
                }
                this.updateGeometry();
            }
            
            updateGeometry() {
                const positions = new Float32Array(this.points.length * 3);
                this.points.forEach((point, i) => {
                    positions[i * 3] = point.x;
                    positions[i * 3 + 1] = point.y;
                    positions[i * 3 + 2] = point.z;
                });
                this.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            }
            
            setColor(color) {
                this.material.color.setHex(color);
            }
        }
        
        function init() {
            // Scene setup with enhanced settings
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.0008);
            
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
            updateCameraPosition();
            
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('soulCanvas'),
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x000000, 1);
            
            // Advanced rendering settings
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            renderer.outputEncoding = THREE.sRGBEncoding;
            
            initLivingLightSystem();
            initTrailSystem();
            
            // Auto-generate first soul after delay
            setTimeout(() => mintNewSoul(), 1500);
            
            animate();
        }
        
        function initLivingLightSystem() {
            const particleCount = 4000;
            const positions = new Float32Array(particleCount * 3);
            const phases = new Float32Array(particleCount);
            const radii = new Float32Array(particleCount);
            const velocities = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                
                // Layered distribution for depth
                const layer = Math.floor(Math.random() * 3);
                const r = (200 + layer * 150) + Math.random() * 100;
                
                const u = Math.random();
                const v = Math.random();
                const theta = TAU * u;
                const phi = Math.acos(2 * v - 1);
                
                positions[i3] = r * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i3 + 2] = r * Math.cos(phi);
                
                phases[i] = Math.random() * TAU;
                radii[i] = 1.5 + Math.random() * 3.5 + layer * 0.5;
                
                // Initial velocities for curl noise
                velocities[i3] = (Math.random() - 0.5) * 0.02;
                velocities[i3 + 1] = (Math.random() - 0.5) * 0.02;
                velocities[i3 + 2] = (Math.random() - 0.5) * 0.02;
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('phase', new THREE.BufferAttribute(phases, 1));
            geometry.setAttribute('radius', new THREE.BufferAttribute(radii, 1));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            
            const material = new THREE.ShaderMaterial({
                vertexShader: livingLightVertexShader,
                fragmentShader: livingLightFragmentShader,
                uniforms: {
                    u_time: { value: 0 }
                },
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            livingLightSystem = new THREE.Points(geometry, material);
            scene.add(livingLightSystem);
        }
        
        function initTrailSystem() {
            trailSystem = new THREE.Group();
            scene.add(trailSystem);
        }
        
        function createSoulCluster(soul) {
            if (soulCluster) {
                scene.remove(soulCluster);
            }
            
            soulCluster = new THREE.Group();
            
            // Central core with enhanced glow
            const coreGeometry = new THREE.SphereGeometry(4, 20, 16);
            const coreMaterial = new THREE.MeshBasicMaterial({ 
                color: new THREE.Color().setHSL(soul.hue / 360, 0.8, 1.0),
                transparent: true,
                opacity: 0.9
            });
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            soulCluster.add(core);
            
            // Add core glow
            const glowGeometry = new THREE.SphereGeometry(8, 16, 12);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: new THREE.Color().setHSL(soul.hue / 360, 0.6, 0.8),
                transparent: true,
                opacity: 0.2,
                blending: THREE.AdditiveBlending
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            soulCluster.add(glow);
            
            // 8 eigenvalue crystals with trails
            const crystalGeometry = new THREE.CylinderGeometry(2.5, 2.5, 12, 8);
            
            // Clear existing trails
            trailSystem.clear();
            
            for (let k = 0; k < 8; k++) {
                const radius = 35 * Math.pow(PHI, k / 8);
                const angle = soul.eigen[k].phase;
                
                const material = new THREE.ShaderMaterial({
                    vertexShader: soulCrystalVertexShader,
                    fragmentShader: soulCrystalFragmentShader,
                    uniforms: {
                        u_time: { value: 0 },
                        u_coherence: { value: soul.coherence },
                        u_hue: { value: soul.hue },
                        u_scale: { value: 1.0 },
                        u_formation: { value: soul.formation === 'vortex' ? 2.0 : soul.formation === 'cluster' ? 1.0 : 0.0 }
                    },
                    transparent: true,
                    blending: THREE.NormalBlending
                });
                
                const crystal = new THREE.Mesh(crystalGeometry, material);
                crystal.position.x = radius * Math.cos(angle);
                crystal.position.y = radius * Math.sin(angle);
                crystal.position.z = (k - 4) * 6;
                
                // Random rotation for more organic look
                crystal.rotation.x = Math.random() * 0.5;
                crystal.rotation.z = Math.random() * 0.5;
                
                crystal.userData = { 
                    eigenIndex: k,
                    baseRadius: radius,
                    baseAngle: angle,
                    material: material,
                    trail: new CrystalTrail(60)
                };
                
                // Add trail to trail system
                crystal.userData.trail.setColor(new THREE.Color().setHSL(soul.hue / 360, 0.7, 0.6).getHex());
                trailSystem.add(crystal.userData.trail.line);
                
                soulCluster.add(crystal);
            }
            
            // Enhanced filament system
            createAdvancedFilaments(soul);
            
            // Add legendary features
            if (soul.rarity === 'legendary' || soul.rarity === 'mythic') {
                createLegendaryFeatures(soul);
            }
            
            scene.add(soulCluster);
            return soulCluster;
        }
        
        function createAdvancedFilaments(soul) {
            const connections = soul.formation === 'cluster' ? 
                [[0,4], [1,5], [2,6], [3,7], [0,2], [1,3], [4,6], [5,7]] :
                soul.formation === 'vortex' ?
                [[0,1], [1,2], [2,3], [3,4], [4,5], [5,6], [6,7], [7,0], [0,4], [2,6]] :
                [[0,1], [1,2], [2,3], [3,4], [4,5], [5,6], [6,7], [7,0]]; // spiral
                
            connections.forEach(([k1, k2]) => {
                const r1 = 35 * Math.pow(PHI, k1 / 8);
                const r2 = 35 * Math.pow(PHI, k2 / 8);
                const a1 = soul.eigen[k1].phase;
                const a2 = soul.eigen[k2].phase;
                
                const pos1 = new THREE.Vector3(r1 * Math.cos(a1), r1 * Math.sin(a1), (k1 - 4) * 6);
                const pos2 = new THREE.Vector3(r2 * Math.cos(a2), r2 * Math.sin(a2), (k2 - 4) * 6);
                
                // Control point for organic curves
                const control = new THREE.Vector3().lerpVectors(pos1, pos2, 0.5);
                control.add(new THREE.Vector3(
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 10
                ));
                
                const curve = new THREE.QuadraticBezierCurve3(pos1, control, pos2);
                const geometry = new THREE.TubeGeometry(curve, 24, 0.4, 8, false);
                const material = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(soul.hue / 360, 0.5, 0.6),
                    transparent: true,
                    opacity: 0.3,
                    blending: THREE.AdditiveBlending
                });
                
                const filament = new THREE.Mesh(geometry, material);
                filament.userData = { isFilament: true, k1, k2 };
                soulCluster.add(filament);
            });
        }
        
        function createLegendaryFeatures(soul) {
            if (soul.rarity === 'legendary') {
                // Extra ring of mini-crystals
                for (let i = 0; i < 16; i++) {
                    const angle = (i / 16) * TAU;
                    const radius = 80;
                    
                    const miniGeometry = new THREE.SphereGeometry(1, 8, 6);
                    const miniMaterial = new THREE.MeshBasicMaterial({
                        color: new THREE.Color().setHSL(soul.hue / 360, 0.8, 0.9),
                        transparent: true,
                        opacity: 0.6,
                        blending: THREE.AdditiveBlending
                    });
                    
                    const miniCrystal = new THREE.Mesh(miniGeometry, miniMaterial);
                    miniCrystal.position.x = radius * Math.cos(angle);
                    miniCrystal.position.y = radius * Math.sin(angle);
                    miniCrystal.position.z = Math.sin(angle * 3) * 10;
                    
                    soulCluster.add(miniCrystal);
                }
            }
            
            if (soul.rarity === 'mythic') {
                // Mythic souls get a reality distortion field
                const fieldGeometry = new THREE.SphereGeometry(120, 32, 24);
                const fieldMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(soul.hue / 360, 0.3, 0.4),
                    transparent: true,
                    opacity: 0.1,
                    side: THREE.BackSide,
                    blending: THREE.AdditiveBlending
                });
                
                const field = new THREE.Mesh(fieldGeometry, fieldMaterial);
                field.userData = { isMythicField: true };
                soulCluster.add(field);
            }
        }
        
        function generateSoulTraits(delta, coherence) {
            const formations = ['spiral', 'cluster', 'vortex'];
            const traits = {
                formation: formations[Math.floor(Math.random() * formations.length)],
                density: 0.3 + Math.random() * 0.7,
                resonanceStability: coherence + Math.random() * 0.2,
                quantumFlux: Math.abs(delta) / 4,
                eigenBrightness: 0.5 + coherence * 0.5
            };
            
            // Special traits based on values
            const specialTraits = [];
            if (Math.abs(delta) > 3) specialTraits.push('High Signature');
            if (coherence > 0.95) specialTraits.push('Perfect Coherence');
            if (traits.formation === 'vortex') specialTraits.push('Vortex Formation');
            if (traits.density > 0.8) specialTraits.push('Dense Field');
            
            return { ...traits, special: specialTraits };
        }
        
        function determineRarity(delta, coherence, traits) {
            let rarity = 'common';
            let score = 0;
            
            // Rarity scoring
            if (Math.abs(delta) > 3.5) score += 3;
            else if (Math.abs(delta) > 2.5) score += 2;
            else if (Math.abs(delta) > 1.5) score += 1;
            
            if (coherence > 0.98) score += 4;
            else if (coherence > 0.95) score += 3;
            else if (coherence > 0.9) score += 2;
            else if (coherence > 0.85) score += 1;
            
            if (traits.formation === 'vortex') score += 2;
            if (traits.density > 0.85) score += 1;
            if (traits.special.length > 2) score += 1;
            
            // Determine rarity tier
            if (score >= 8) rarity = 'mythic';      // ~0.5%
            else if (score >= 6) rarity = 'legendary'; // ~2%
            else if (score >= 4) rarity = 'epic';      // ~8%
            else if (score >= 2) rarity = 'rare';      // ~20%
            
            return rarity;
        }
        
        function mintNewSoul() {
            showBirthOverlay();
            isBirthing = true;
            
            // Generate soul using enhanced RS mathematics
            const delta = Math.max(-4, Math.min(4, (Math.random() - 0.5) * 8 + (Math.random() - 0.5) * 2)); // More variety
            const energy = E_COH * Math.pow(PHI, GAP_45 + delta);
            const coherence = Math.pow(Math.random(), 2) * 0.25 + 0.75; // Bias toward higher coherence
            const hue = 200 + ((delta + 4) / 8) * 120; // 200-320° range
            
            const traits = generateSoulTraits(delta, coherence);
            const rarity = determineRarity(delta, coherence, traits);
            
            const eigen = [];
            for (let k = 0; k < 8; k++) {
                eigen.push({
                    lambda: energy * Math.pow(PHI, k / 8),
                    phase: Math.random() * TAU + (k * TAU / 8) * (traits.formation === 'spiral' ? 1 : 0.1),
                    amplitude: 0.5 + Math.random() * 0.5
                });
            }
            
            currentSoul = {
                id: Math.floor(Math.random() * 999999).toString().padStart(6, '0'),
                delta: delta,
                energy: energy,
                coherence: coherence,
                hue: hue,
                rung: GAP_45 + Math.floor(delta),
                formation: traits.formation,
                density: traits.density,
                rarity: rarity,
                traits: traits,
                eigen: eigen,
                birthTime: Date.now()
            };
            
            // Create visual representation
            createSoulCluster(currentSoul);
            
            // Enhanced birth animation
            animateAdvancedBirth();
            
            // Update UI
            updateMetadata();
        }
        
        function animateAdvancedBirth() {
            const tl = gsap.timeline();
            
            // Start invisible
            soulCluster.scale.set(0, 0, 0);
            soulCluster.rotation.set(0, 0, 0);
            
            // Camera zoom effect
            const originalRadius = cameraOrbit.radius;
            cameraOrbit.radius = 200;
            
            tl.to(cameraOrbit, {
                duration: 3,
                radius: originalRadius,
                ease: "power2.out"
            })
            .to(soulCluster.scale, {
                duration: 2.5,
                x: 1, y: 1, z: 1,
                ease: "elastic.out(1, 0.4)"
            }, 0.5)
            .to(soulCluster.rotation, {
                duration: 8,
                y: TAU,
                ease: "power2.inOut"
            }, 1)
            .to({}, {
                duration: 1,
                onComplete: () => {
                    hideBirthOverlay();
                    isBirthing = false;
                }
            });
        }
        
        function updateMetadata() {
            const soul = currentSoul;
            
            document.getElementById('soulTitle').textContent = `Quantum Soul #${soul.id}`;
            
            const rarityBadge = document.getElementById('rarityBadge');
            rarityBadge.textContent = soul.rarity.charAt(0).toUpperCase() + soul.rarity.slice(1);
            rarityBadge.className = `rarity-badge rarity-${soul.rarity}`;
            
            document.getElementById('soulDelta').textContent = (soul.delta >= 0 ? '+' : '') + soul.delta.toFixed(3);
            document.getElementById('soulEnergy').textContent = (soul.energy * 1000).toFixed(1) + ' meV';
            document.getElementById('soulCoherence').textContent = (soul.coherence * 100).toFixed(1) + '%';
            document.getElementById('soulFormation').textContent = soul.formation.charAt(0).toUpperCase() + soul.formation.slice(1);
            document.getElementById('soulDensity').textContent = soul.density.toFixed(2);
            document.getElementById('soulResonance').textContent = Math.round(soul.hue) + '°';
            document.getElementById('soulRung').textContent = soul.rung;
            
            // Update traits
            const traitsContainer = document.getElementById('soulTraits');
            traitsContainer.innerHTML = '';
            
            const allTraits = [
                `${soul.formation} Formation`,
                `${soul.rarity} Rarity`,
                `Coherence ${(soul.coherence * 100).toFixed(0)}%`,
                ...soul.traits.special
            ];
            
            allTraits.forEach(trait => {
                const tag = document.createElement('span');
                tag.className = 'trait-tag';
                tag.textContent = trait;
                traitsContainer.appendChild(tag);
            });
            
            // Show metadata
            document.getElementById('soulMetadata').classList.add('visible');
        }
        
        function updateCameraPosition() {
            cameraOrbit.theta += 0.003;
            camera.position.x = cameraOrbit.radius * Math.sin(cameraOrbit.theta) * Math.cos(cameraOrbit.phi);
            camera.position.y = cameraOrbit.radius * Math.sin(cameraOrbit.phi);
            camera.position.z = cameraOrbit.radius * Math.cos(cameraOrbit.theta) * Math.cos(cameraOrbit.phi);
            camera.lookAt(0, 0, 0);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            time += 0.016;
            
            // Update camera orbit
            if (!isBirthing) {
                updateCameraPosition();
            }
            
            // Update living light system
            if (livingLightSystem) {
                livingLightSystem.material.uniforms.u_time.value = time;
                livingLightSystem.rotation.y += 0.0005;
            }
            
            // Update soul cluster
            if (soulCluster && currentSoul) {
                // Crystal orbital motion with curl noise
                soulCluster.children.forEach(child => {
                    if (child.userData.eigenIndex !== undefined) {
                        const k = child.userData.eigenIndex;
                        const t = time * 0.5 + child.userData.baseAngle;
                        
                        // Base orbital motion
                        let x = child.userData.baseRadius * Math.cos(t);
                        let y = child.userData.baseRadius * Math.sin(t);
                        
                        // Add curl noise for organic movement
                        const noiseScale = 0.1;
                        const noiseSpeed = 0.3;
                        x += Math.sin(t * noiseSpeed + k) * 8;
                        y += Math.cos(t * noiseSpeed + k * 1.3) * 8;
                        
                        child.position.x = x;
                        child.position.y = y;
                        
                        // Update crystal material uniforms
                        if (child.userData.material) {
                            child.userData.material.uniforms.u_time.value = time;
                        }
                        
                        // Update trails
                        if (child.userData.trail) {
                            child.userData.trail.addPoint(child.position);
                        }
                        
                        // Gentle rotation
                        child.rotation.x += 0.001;
                        child.rotation.z += 0.0015;
                    }
                });
                
                // Update filaments with pulsing
                soulCluster.children.forEach(child => {
                    if (child.userData.isFilament) {
                        const beat = 0.3 + 0.7 * (0.5 + 0.5 * Math.sin(8 * time * 0.5));
                        child.material.opacity = 0.2 + 0.3 * beat;
                    }
                });
                
                // Eight-beat breathing for entire cluster
                const breathe = 0.95 + 0.05 * Math.sin(8 * time * 0.5);
                soulCluster.scale.setScalar(breathe);
                
                // Mythic field distortion
                const mythicField = soulCluster.children.find(c => c.userData.isMythicField);
                if (mythicField) {
                    mythicField.rotation.x += 0.002;
                    mythicField.rotation.y += 0.001;
                    mythicField.scale.setScalar(1 + 0.1 * Math.sin(time * 0.7));
                }
            }
            
            renderer.render(scene, camera);
        }
        
        function exportSoulImage() {
            if (!currentSoul) return;
            
            // Create high-res render
            const originalSize = renderer.getSize(new THREE.Vector2());
            renderer.setSize(2048, 2048);
            renderer.render(scene, camera);
            
            // Download canvas as image
            const canvas = renderer.domElement;
            const link = document.createElement('a');
            link.download = `soul-${currentSoul.id}.png`;
            link.href = canvas.toDataURL();
            link.click();
            
            // Restore original size
            renderer.setSize(originalSize.x, originalSize.y);
        }
        
        function exportSoulData() {
            if (!currentSoul) return;
            
            const soulData = {
                id: currentSoul.id,
                signature: currentSoul.delta,
                energy: currentSoul.energy,
                coherence: currentSoul.coherence,
                formation: currentSoul.formation,
                rarity: currentSoul.rarity,
                traits: currentSoul.traits,
                eigenvalues: currentSoul.eigen,
                birthTimestamp: currentSoul.birthTime,
                recognitionScience: {
                    equation: `E = ${E_COH} × φ^(${GAP_45}+${currentSoul.delta.toFixed(3)})`,
                    gapRung: currentSoul.rung,
                    hueResonance: currentSoul.hue
                }
            };
            
            const blob = new Blob([JSON.stringify(soulData, null, 2)], { type: 'application/json' });
            const link = document.createElement('a');
            link.download = `soul-${currentSoul.id}-data.json`;
            link.href = URL.createObjectURL(blob);
            link.click();
        }
        
        function showBirthOverlay() {
            document.getElementById('birthOverlay').classList.add('active');
        }
        
        function hideBirthOverlay() {
            document.getElementById('birthOverlay').classList.remove('active');
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        window.addEventListener('resize', onWindowResize);
        
        // Initialize when page loads
        init();
    </script>
  
  <div id="footer-placeholder"></div>
  
  <script src="/assets/js/main.js"></script>
</body>
</html> 