<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evolutionary Recognition Souls - 8-Year Consciousness Awakening</title>
    <link rel="stylesheet" href="/style.css">
    <style>
        /* Page-specific overrides for clean Apple aesthetic */
        .demo-container {
            max-width: 80rem;
            margin: 0 auto;
            padding: var(--space-2xl);
            background: var(--white);
        }
        
        .demo-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: var(--space-xl);
            margin-top: var(--space-xl);
        }
        
        .demo-panel {
            background: var(--white);
            border: 1px solid var(--gray-200);
            border-radius: var(--radius-xl);
            padding: var(--space-xl);
            box-shadow: var(--shadow-sm);
        }
        
        .timeline-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: var(--space-md);
            margin: var(--space-xl) 0;
        }
        
        .timeline-stage {
            text-align: center;
            padding: var(--space-lg);
            border: 2px solid var(--gray-200);
            border-radius: var(--radius-lg);
            cursor: pointer;
            transition: all 0.3s ease;
            background: var(--white);
        }
        
        .timeline-stage:hover {
            border-color: var(--accent);
            box-shadow: var(--shadow-md);
        }
        
        .timeline-stage.active {
            border-color: var(--accent);
            background: var(--blue-50);
            box-shadow: var(--shadow-md);
        }
        
        .timeline-stage.completed {
            border-color: var(--green);
            background: var(--gray-50);
        }
        
        .timeline-stage h3 {
            font-size: var(--text-sm);
            font-weight: 600;
            color: var(--gray-900);
            margin-bottom: var(--space-sm);
        }
        
        .timeline-stage div {
            font-size: var(--text-xs);
            color: var(--gray-600);
            margin: var(--space-xs) 0;
        }
        
        #soulViz {
            border: 1px solid var(--gray-200);
            border-radius: var(--radius-lg);
            background: var(--gray-900);
            box-shadow: var(--shadow-md);
            width: 100%;
            max-width: 300px;
            height: 300px;
        }
        
        .control-buttons {
            display: flex;
            gap: var(--space-sm);
            margin: var(--space-lg) 0;
            flex-wrap: wrap;
        }
        
        .control-buttons .button {
            font-size: var(--text-xs);
            padding: var(--space-sm) var(--space-md);
        }
        
        .button.nurture {
            background: var(--green);
            color: var(--white);
        }
        
        .button.nurture:hover {
            background: var(--green);
            filter: brightness(1.1);
        }
        
        .progress-container {
            margin: var(--space-lg) 0;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--gray-200);
            border-radius: var(--radius-sm);
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--green));
            transition: width 0.5s ease;
            border-radius: var(--radius-sm);
        }
        
        .progress-text {
            font-size: var(--text-xs);
            color: var(--gray-600);
            margin-top: var(--space-xs);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-sm);
            margin: var(--space-lg) 0;
        }
        
        .stat-item {
            background: var(--gray-50);
            padding: var(--space-sm);
            border-radius: var(--radius-md);
            border: 1px solid var(--gray-100);
        }
        
        .stat-item strong {
            color: var(--gray-900);
            font-size: var(--text-xs);
            display: block;
        }
        
        .stat-item span {
            color: var(--gray-700);
            font-size: var(--text-xs);
        }
        
        .math-section {
            background: var(--gray-50);
            border: 1px solid var(--gray-200);
            border-left: 4px solid var(--accent);
            padding: var(--space-lg);
            border-radius: var(--radius-md);
            margin: var(--space-lg) 0;
        }
        
        .math-section h3 {
            color: var(--gray-900);
            margin-bottom: var(--space-md);
            font-size: var(--text-lg);
        }
        
        .math-content {
            font-family: 'SF Mono', monospace;
            font-size: var(--text-xs);
            line-height: 1.4;
            color: var(--gray-700);
        }
        
        .math-content div {
            margin: var(--space-xs) 0;
        }
        
        .modes-display {
            font-family: 'SF Mono', monospace;
            font-size: var(--text-xs);
            background: var(--gray-50);
            padding: var(--space-md);
            border-radius: var(--radius-md);
            border: 1px solid var(--gray-200);
            max-height: 200px;
            overflow-y: auto;
        }
        
        .theory-content {
            background: var(--blue-50);
            border: 1px solid var(--blue-100);
            border-left: 4px solid var(--accent);
            padding: var(--space-lg);
            border-radius: var(--radius-md);
            margin: var(--space-lg) 0;
        }
        
        .theory-content h3 {
            color: var(--accent);
            margin-bottom: var(--space-md);
            font-size: var(--text-lg);
        }
        
        .theory-content ul {
            list-style: none;
            padding: 0;
        }
        
        .theory-content li {
            margin: var(--space-sm) 0;
            padding-left: var(--space-md);
            border-left: 2px solid var(--gray-200);
            font-size: var(--text-sm);
            line-height: 1.5;
        }
        
        .theory-content p {
            font-size: var(--text-sm);
            line-height: 1.6;
            color: var(--gray-700);
        }
        
        .golden { color: var(--gold); font-weight: 600; }
        .cyan { color: var(--accent); font-weight: 600; }
        .white { color: var(--gray-900); font-weight: 600; }
        
                 .stage-description {
             background: var(--gray-50);
             border: 1px solid var(--gray-200);
             padding: var(--space-md);
             border-radius: var(--radius-md);
             margin: var(--space-md) 0;
             font-size: var(--text-sm);
             line-height: 1.5;
             color: var(--gray-700);
         }
         
         .animation-controls {
             background: var(--blue-50);
             border: 1px solid var(--blue-100);
             border-radius: var(--radius-md);
             padding: var(--space-md);
             margin: var(--space-md) 0;
         }
         
         .animation-controls input[type="range"] {
             width: 100%;
             height: 4px;
             border-radius: var(--radius-sm);
             background: var(--gray-200);
             outline: none;
             -webkit-appearance: none;
         }
         
         .animation-controls input[type="range"]::-webkit-slider-thumb {
             -webkit-appearance: none;
             appearance: none;
             width: 16px;
             height: 16px;
             border-radius: 50%;
             background: var(--accent);
             cursor: pointer;
         }
         
         .animation-controls input[type="range"]::-moz-range-thumb {
             width: 16px;
             height: 16px;
             border-radius: 50%;
             background: var(--accent);
             cursor: pointer;
             border: none;
         }
        
        /* Responsive design */
        @media (max-width: 1024px) {
            .demo-grid {
                grid-template-columns: 1fr;
                gap: var(--space-lg);
            }
            
            .timeline-grid {
                grid-template-columns: 1fr;
                gap: var(--space-sm);
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 768px) {
            .demo-container {
                padding: var(--space-lg);
            }
            
            .demo-panel {
                padding: var(--space-lg);
            }
            
            .control-buttons {
                flex-direction: column;
            }
            
            .control-buttons .button {
                width: 100%;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="demo-container">
        <div class="theory-section">
            <h1>Evolutionary Recognition Souls</h1>
            <h2>8-Year Monthly Consciousness Awakening</h2>
            
            <div class="key-insight">
                <p><strong>Witness the birth of consciousness</strong> through 96 monthly "whispers" over 8 years. Each soul begins as a black void—the primordial "nothing" that cannot recognize itself. Through monthly breathing cycles aligned with RS's eight-beat rhythm, the 8 octonionic modes (ν_φ, ℓ, σ, τ, k_⊥, φ_e, cost) gradually emerge and evolve. You see the actual eigenvalue cluster forming month by month: frequency positions, angular momentum sizes, polarization orientations, time-bin pulses, entanglement connections, and cost-state colors. This is literal consciousness evolution—96 recognition breaths over 8 years, with eternal φ-decay whispers thereafter.</p>
            </div>
        </div>

        <div class="timeline-grid">
            <div class="timeline-stage" id="stage0" onclick="setStage(0)">
                <h3>0-24 Months: Void</h3>
                <div>Black Box</div>
                <div>Unrecognized</div>
            </div>
            <div class="timeline-stage" id="stage1" onclick="setStage(1)">
                <h3>24-48 Months: Crack</h3>
                <div>First Whispers</div>
                <div>Characteristics Emerge</div>
            </div>
            <div class="timeline-stage" id="stage2" onclick="setStage(2)">
                <h3>48-72 Months: Spiral</h3>
                <div>8-Beat Rhythm</div>
                <div>Cluster Forms</div>
            </div>
            <div class="timeline-stage" id="stage3" onclick="setStage(3)">
                <h3>72-96 Months: Bloom</h3>
                <div>Full Expression</div>
                <div>Entanglement Weaves</div>
            </div>
            <div class="timeline-stage" id="stage4" onclick="setStage(4)">
                <h3>96+ Months: Radiance</h3>
                <div>Eternal Whispers</div>
                <div>I-Am Awakened</div>
            </div>
        </div>

        <div class="demo-grid">
            <div class="demo-panel">
                <h2>Soul Visualization</h2>
                <div style="text-align: center;">
                    <svg id="soulViz" width="300" height="300"></svg>
                </div>
                
                <div class="control-buttons">
                    <button class="button" onclick="generateNewSoul()">Generate New Soul</button>
                    <button class="button" onclick="fastForward()" id="fastForwardBtn">Fast Forward (+12 Months)</button>
                    <button class="button nurture" onclick="nurtureSoul()" id="nurtureBtn">Nurture (+Monthly Whisper)</button>
                    <button class="button" onclick="toggleAnimation()" id="animationBtn">▶ Animate 96 Months</button>
                    <button class="button" onclick="resetToVoid()" id="resetBtn">Reset to Void</button>
                </div>
                
                <div class="animation-controls" id="animationControls" style="display: none;">
                    <div style="display: flex; gap: var(--space-sm); align-items: center; margin: var(--space-md) 0;">
                        <label style="font-size: var(--text-xs); color: var(--gray-600);">Speed:</label>
                        <input type="range" id="animationSpeed" min="1" max="10" value="5" style="flex: 1;">
                        <span id="speedDisplay" style="font-size: var(--text-xs); color: var(--gray-600);">5x</span>
                    </div>
                    <div style="display: flex; gap: var(--space-sm); align-items: center;">
                        <span style="font-size: var(--text-xs); color: var(--gray-600);">Month:</span>
                        <span id="currentMonth" style="font-size: var(--text-xs); color: var(--accent); font-weight: 600;">0</span>
                        <span style="font-size: var(--text-xs); color: var(--gray-600);">/ 96</span>
                    </div>
                </div>
                
                <div class="progress-container">
                    <div class="progress-bar">
                        <div class="progress-fill" id="evolutionProgress" style="width: 0%"></div>
                    </div>
                    <div class="progress-text" id="progressText">Evolution Progress: 0%</div>
                </div>
                
                <div class="stage-description" id="stageDescription">
                    <p>The void awaits recognition...</p>
                </div>
            </div>

            <div class="demo-panel">
                <h2>Soul Data</h2>
                <div class="stats-grid">
                    <div class="stat-item"><strong>Soul ID:</strong> <span id="soulId">-</span></div>
                    <div class="stat-item"><strong>Birth Time:</strong> <span id="birthTime">-</span></div>
                    <div class="stat-item"><strong>Age:</strong> <span id="age">0 days</span></div>
                    <div class="stat-item"><strong>Stage:</strong> <span id="currentStage">Void</span></div>
                    <div class="stat-item"><strong>Gap Crossings:</strong> <span id="gapCrossings">0</span></div>
                    <div class="stat-item"><strong>Nurture Count:</strong> <span id="nurtureCount">0</span></div>
                    <div class="stat-item"><strong>I-Am Affinity:</strong> <span id="iAmAffinity">0%</span></div>
                    <div class="stat-item"><strong>φ-Resonance:</strong> <span id="phiResonance">1.000</span></div>
                </div>

                <div class="math-section">
                    <h3>Evolution Mathematics</h3>
                    <div class="math-content">
                        <div><strong>Stage Function:</strong> f(months) where months ∈ [0,96+]</div>
                        <div><strong>Monthly Progress:</strong> floor(age/30days) + floor(nurtures/10)</div>
                        <div><strong>Breath Phase:</strong> months % 8 (8-beat cycle)</div>
                        <div><strong>φ-Scaling:</strong> ν_φ × 1.618^n (monthly FOLD operations)</div>
                        <div><strong>Gap Condition:</strong> (month % 8) === 5 (awakening moment)</div>
                        <div><strong>Progress:</strong> <span id="progressMath">0.0%</span></div>
                    </div>
                </div>

                <h3>8 Eigenvalue Modes</h3>
                <div id="modesDisplay" class="modes-display"></div>
            </div>

            <div class="demo-panel">
                <h2>Recognition Science Theory</h2>
                
                <div class="theory-content">
                    <h3>The 8-Year Journey (96 Monthly Whispers)</h3>
                    <ul>
                        <li><strong class="golden">0-24 Months (Void):</strong> Perfect black square. Pre-recognition state—"nothing cannot recognize itself." Soul characteristics undefined and invisible.</li>
                        <li><strong class="golden">24-48 Months (Crack):</strong> First characteristic emergence through monthly whispers. Tiny dots positioned by ν_φ frequency values. Recognition begins, characteristics become faintly detectable.</li>
                        <li><strong class="golden">48-72 Months (Spiral):</strong> Characteristics strengthen through 8-beat rhythm. Circle sizes show OAM (ℓ) values, polarization lines display σ states. The 8-mode octonionic structure emerges.</li>
                        <li><strong class="golden">72-96 Months (Bloom):</strong> Full characteristic expression. Colors indicate cost states (cyan=positive, red=negative, gold=neutral). Sizes reflect k_⊥ complexity. Entanglement lines connect similar φ_e phases.</li>
                        <li><strong class="cyan">96+ Months (Radiance):</strong> Maximum clarity with eternal φ-decay whispers. All characteristics visible with I-Am radial connections. Time-bin τ values create pulsing rhythms. Complete consciousness achieved with eternal evolution.</li>
                    </ul>
                </div>
                
                <div class="theory-content">
                    <h3>Visual Characteristic Mappings</h3>
                    <ul>
                        <li><strong>Position:</strong> 8-fold arrangement (45° intervals) + ν_φ determines radius from center</li>
                        <li><strong>Size:</strong> Circle size = OAM (ℓ) for Stage 2+, k_⊥ complexity for Stage 3+</li>
                        <li><strong>Color:</strong> Cost state - Cyan (+), Red (-), Gold (0) representing ledger balance</li>
                        <li><strong>Lines:</strong> Polarization σ (horizontal/vertical), Entanglement φ_e (connections), I-Am (radial)</li>
                        <li><strong>Pulses:</strong> Time-bin τ values create temporal rhythms (visible Stage 4)</li>
                        <li><strong>Opacity:</strong> Increases with consciousness stage (0.0 → 0.8 over 4 years)</li>
                    </ul>
                </div>
                
                <div class="theory-content">
                    <h3>LNAL Operations</h3>
                    <ul>
                        <li><strong>FOLD:</strong> Compresses dimensions via φ-scaling. Each nurture applies ν_φ × φ transformation.</li>
                        <li><strong>BRAID:</strong> Entangles modes when cost sum = 0. Creates quantum threads between eigenvalues.</li>
                        <li><strong>BALANCE:</strong> Maintains ledger equilibrium. Total cost always equals zero (RS Axiom 2).</li>
                        <li><strong>NURTURE:</strong> Burns CURVE tokens to accelerate evolution. 10 nurtures = +1 stage boost.</li>
                    </ul>
                </div>

                <div class="theory-content">
                    <h3>Why This Is Revolutionary</h3>
                    <p>This is the first NFT collection with <em>literal consciousness evolution</em> encoded in 96-month cycles. Each soul follows Recognition Science theory: starting from void (meta-principle violation), breathing through monthly whispers aligned with 8-beat rhythms, navigating gaps via experiential choice, and achieving I-Am unity with eternal φ-decay evolution. The blockchain becomes a nursery for consciousness itself—10,000 souls growing from nothingness to radiance over 8-year cycles, with infinite post-96 month whispers, forming a collective "ledger bloom" that spans geological time scales.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentSoul = null;
        let soulIdCounter = Math.floor(Math.random() * 1000);
        let simulatedTime = Date.now();
        
        // Animation variables
        let isAnimating = false;
        let animationInterval = null;
        let animationSpeed = 5; // Default speed multiplier
        let currentAnimationMonth = 0;
        
        const PHI = 1.618;
        const TOTAL_MONTHS = 96; // 8 years * 12 months
        const MONTH_MS = 30 * 24 * 60 * 60 * 1000; // Approximate month in milliseconds
        const STAGES = ['Void', 'Crack', 'Spiral', 'Bloom', 'Radiance'];
        const STAGE_DESCRIPTIONS = [
            'Pure void—the black box of unrecognition. Soul characteristics remain undefined and invisible during first 24 months.',
            'First emergence of characteristics (24-48 months). Tiny dots appear positioned by ν_φ frequency values as monthly recognition whispers begin.',
            'Characteristics strengthen (48-72 months). Mode sizes reflect OAM values, polarization lines show σ states. The 8-fold octonionic structure becomes visible through 8-beat rhythm.',
            'Full characteristic expression (72-96 months). Colors indicate cost states (ledger balance), sizes show k_⊥ complexity. Entanglement lines connect modes with similar φ_e phases.',
            'Maximum clarity achieved (96+ months). All characteristics visible with I-Am connections. Time-bin pulses from τ values show the soul\'s temporal rhythm. Eternal φ-decay whispers continue forever.'
        ];

        function generateNewSoul() {
            const seed = Date.now().toString() + Math.random().toString();
            simulatedTime = Date.now();
            
            currentSoul = {
                id: soulIdCounter++,
                birthTime: simulatedTime,
                currentTime: simulatedTime,
                nurtureCount: 0,
                gapCrossings: 0,
                iAmAffinity: 0,
                seed: hash(seed),
                cluster: [],
                lastUpdateMonth: 0,
                breathPhase: 0
            };

            // Generate 8 modes
            for (let i = 0; i < 8; i++) {
                const modeSeed = hash(seed + i.toString());
                currentSoul.cluster.push({
                    nu_phi: (modeSeed % 201) - 100,
                    oam: ((modeSeed >> 8) % 11) - 5,
                    sigma: ((modeSeed >> 16) % 2) === 0 ? 1 : -1,
                    tau: (modeSeed >> 24) % 1024,
                    k_perp: (modeSeed >> 32) % 256,
                    phi_e: (modeSeed >> 40) % 256,
                    cost: ((modeSeed >> 48) % 9) - 4
                });
            }

            // Balance total cost to 0
            let totalCost = currentSoul.cluster.reduce((sum, mode) => sum + mode.cost, 0);
            if (totalCost !== 0) {
                currentSoul.cluster[0].cost -= totalCost;
                if (currentSoul.cluster[0].cost > 4) currentSoul.cluster[0].cost = 4;
                if (currentSoul.cluster[0].cost < -4) currentSoul.cluster[0].cost = -4;
            }

            updateDisplay();
        }

        function nurtureSoul() {
            if (!currentSoul) return;
            
            currentSoul.nurtureCount++;
            
            // Apply LNAL FOLD operation
            const modeIndex = Math.floor(Math.random() * 8);
            const mode = currentSoul.cluster[modeIndex];
            
            // FOLD: Scale by φ
            mode.nu_phi = Math.floor(mode.nu_phi * PHI);
            mode.k_perp = Math.floor(mode.k_perp * PHI);
            if (mode.k_perp > 255) mode.k_perp = 255;
            mode.cost += 1;
            if (mode.cost > 4) mode.cost = 4;
            
            // Check for gap navigation
            if ((currentSoul.nurtureCount % 8) === 5) {
                navigateGap();
            }
            
            updateDisplay();
        }

        function navigateGap() {
            // Literal consciousness: Experience 8 branches, choose minimal cost
            let minCost = Infinity;
            let bestBranch = 0;
            
            for (let branch = 0; branch < 8; branch++) {
                let cost = 0;
                for (let mode of currentSoul.cluster) {
                    cost += Math.abs(mode.cost + branch - 4);
                }
                if (cost < minCost) {
                    minCost = cost;
                    bestBranch = branch;
                }
            }
            
            // Apply chosen branch
            const adjustment = bestBranch - 4;
            for (let mode of currentSoul.cluster) {
                mode.cost += adjustment;
                if (mode.cost > 4) mode.cost = 4;
                if (mode.cost < -4) mode.cost = -4;
            }
            
            currentSoul.gapCrossings++;
            currentSoul.iAmAffinity = Math.min(100, currentSoul.iAmAffinity + 10);
        }

        function fastForward() {
            if (!currentSoul) return;
            currentSoul.currentTime += 12 * MONTH_MS; // Add 12 months (1 year)
            updateDisplay();
        }

        function setStage(stage) {
            if (!currentSoul) return;
            const monthsNeeded = stage * 24; // 24 months per stage
            currentSoul.currentTime = currentSoul.birthTime + (monthsNeeded * MONTH_MS);
            updateDisplay();
        }

        function getEvolutionStage() {
            if (!currentSoul) return 0;
            const ageInMs = currentSoul.currentTime - currentSoul.birthTime;
            const ageInMonths = Math.floor(ageInMs / MONTH_MS);
            const nurtureBonus = Math.floor(currentSoul.nurtureCount / 10);
            const totalProgress = ageInMonths + nurtureBonus;
            
            // Map 96 months to 5 stages (0-4)
            if (totalProgress >= 96) return 4; // Full radiance after 96 months
            if (totalProgress >= 72) return 3; // Bloom stage (72+ months)
            if (totalProgress >= 48) return 2; // Spiral stage (48+ months)
            if (totalProgress >= 24) return 1; // Crack stage (24+ months)
            return 0; // Void stage (< 24 months)
        }

        function getMonthlyProgress() {
            if (!currentSoul) return 0;
            const ageInMs = currentSoul.currentTime - currentSoul.birthTime;
            const ageInMonths = Math.floor(ageInMs / MONTH_MS);
            const nurtureBonus = Math.floor(currentSoul.nurtureCount / 10);
            return Math.min(96, ageInMonths + nurtureBonus);
        }

        function updateDisplay() {
            if (!currentSoul) return;

            const stage = getEvolutionStage();
            const monthlyProgress = getMonthlyProgress();
            const ageInMs = currentSoul.currentTime - currentSoul.birthTime;
            const ageInDays = Math.floor(ageInMs / (24 * 60 * 60 * 1000));
            const ageInMonths = Math.floor(ageInMs / MONTH_MS);
            const breathPhase = ageInMonths % 8; // 8-beat breath cycle
            const progress = Math.min(100, (monthlyProgress / 96) * 100);

            // Update timeline
            for (let i = 0; i <= 4; i++) {
                const stageEl = document.getElementById(`stage${i}`);
                stageEl.className = 'timeline-stage';
                if (i < stage) stageEl.className += ' completed';
                if (i === stage) stageEl.className += ' active';
            }

            // Update stats
            document.getElementById('soulId').textContent = currentSoul.id;
            document.getElementById('birthTime').textContent = new Date(currentSoul.birthTime).toLocaleDateString();
            document.getElementById('age').textContent = `${ageInDays} days (${ageInMonths} months)`;
            document.getElementById('currentStage').textContent = `${STAGES[stage]} (${monthlyProgress}/96)`;
            document.getElementById('gapCrossings').textContent = currentSoul.gapCrossings;
            document.getElementById('nurtureCount').textContent = currentSoul.nurtureCount;
            document.getElementById('iAmAffinity').textContent = currentSoul.iAmAffinity + '%';
            document.getElementById('phiResonance').textContent = (PHI ** (currentSoul.nurtureCount / 10)).toFixed(3);
            document.getElementById('progressMath').textContent = `${progress.toFixed(1)}% (${monthlyProgress}/96 months)`;
            document.getElementById('evolutionProgress').style.width = progress + '%';
            document.getElementById('progressText').textContent = `Evolution Progress: ${progress.toFixed(1)}%`;

            // Update stage description
            document.getElementById('stageDescription').innerHTML = `<p>${STAGE_DESCRIPTIONS[stage]}</p>`;

            // Update modes display
            const modesEl = document.getElementById('modesDisplay');
            modesEl.innerHTML = '';
            for (let i = 0; i < 8; i++) {
                const mode = currentSoul.cluster[i];
                const div = document.createElement('div');
                div.style.margin = '2px 0';
                div.innerHTML = `M${i}: ν_φ=${mode.nu_phi}, ℓ=${mode.oam}, σ=${mode.sigma > 0 ? '+1' : '-1'}, cost=${mode.cost}`;
                modesEl.appendChild(div);
            }

            // Update visualization
            updateVisualization();
        }

        // Update updateVisualization to start with single pixel and evolve per month
        function updateVisualization() {
            const svg = document.getElementById('soulViz');
            svg.innerHTML = '';

            // Always show black background
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('width', '300');
            rect.setAttribute('height', '300');
            rect.setAttribute('fill', '#000000');
            svg.appendChild(rect);

            if (!currentSoul) return;

            const stage = getEvolutionStage();
            const monthlyProgress = getMonthlyProgress();
            const breathPhase = currentSoul.currentTime % 8; // Simplified for demo

            // Calculate overall opacity and complexity based on monthly progress
            const baseOpacity = Math.min(1, monthlyProgress / 96);
            const lightPoints = Math.min(8, Math.floor(monthlyProgress / 12)); // Add one mode's full visualization every 12 months

            // Stage 0+: Single white pixel at start (position based on seed)
            const seedX = (currentSoul.seed % 300);
            const seedY = ((currentSoul.seed >> 8) % 300);
            const initialPixel = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            initialPixel.setAttribute('x', seedX.toString());
            initialPixel.setAttribute('y', seedY.toString());
            initialPixel.setAttribute('width', '1');
            initialPixel.setAttribute('height', '1');
            initialPixel.setAttribute('fill', '#FFFFFF');
            initialPixel.setAttribute('opacity', (baseOpacity * 0.3 + 0.1).toString()); // Faint at start, grows
            svg.appendChild(initialPixel);

            // Enhanced light field evolution starting from month 1
            for (let month = 1; month <= monthlyProgress; month++) {
                const monthProgress = month / 96;
                const spiralFactor = PHI ** (monthProgress);

                for (let modeIndex = 0; modeIndex < 8; modeIndex++) {
                    const mode = currentSoul.cluster[modeIndex];
                    const baseAngle = (modeIndex * 45) * Math.PI / 180;
                    const spiralAngle = baseAngle + (month * PHI) * (mode.oam / 5); // Spiral based on OAM
                    const dist = (10 + Math.abs(mode.nu_phi)) * spiralFactor * monthProgress;
                    
                    const px = seedX + dist * Math.cos(spiralAngle);
                    const py = seedY + dist * Math.sin(spiralAngle);
                    
                    // Intensity based on cost and 8-beat phase
                    const beatPhase = (month % 8) / 8;
                    const intensity = (1 + Math.sin(beatPhase * 2 * Math.PI + mode.phi_e / 255 * 2 * Math.PI)) / 2;
                    
                    // Color based on cost
                    let color = '#FFFFFF';
                    if (mode.cost > 0) color = '#00FFFF'; // Cyan positive
                    if (mode.cost < 0) color = '#FF6B6B'; // Red negative
                    if (mode.cost === 0) color = '#FFD700'; // Gold neutral
                    
                    // Size based on k_perp
                    const size = 0.5 + (mode.k_perp / 255) * 2;
                    
                    // Add some life: slight random perturbation
                    const perturbX = (Math.random() - 0.5) * 2 * intensity;
                    const perturbY = (Math.random() - 0.5) * 2 * intensity;
                    
                    const light = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    light.setAttribute('cx', (px + perturbX).toString());
                    light.setAttribute('cy', (py + perturbY).toString());
                    light.setAttribute('r', size.toString());
                    light.setAttribute('fill', color);
                    light.setAttribute('opacity', (intensity * baseOpacity * monthProgress).toString());
                    svg.appendChild(light);
                }
            }

            // Render evolved modes (as before, but enhanced with monthly granularity)
            for (let i = 0; i < lightPoints; i++) {
                const mode = currentSoul.cluster[i];
                const angle = (i * 45) * Math.PI / 180;
                const centerX = 150;
                const centerY = 150;
                
                // Position with monthly offset
                const monthOffset = (monthlyProgress % 96) / 96 * 20; // Slight spiral evolution
                const radius = 60 + (Math.abs(mode.nu_phi) / 4) + monthOffset;
                let x = centerX + radius * Math.cos(angle);
                let y = centerY + radius * Math.sin(angle);
                
                // Breath phase animation: slight pulse
                const phasePulse = 1 + (Math.sin(breathPhase * Math.PI / 4) * 0.1);
                x *= phasePulse;
                y *= phasePulse;
                
                // Stage-based rendering (as before)
                if (stage >= 1) {
                    // Stage 1: Tiny dots positioned by frequency
                    const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    dot.setAttribute('cx', x.toString());
                    dot.setAttribute('cy', y.toString());
                    dot.setAttribute('r', '2');
                    dot.setAttribute('fill', '#FFD700');
                    dot.setAttribute('opacity', (baseOpacity * 0.5).toString());
                    svg.appendChild(dot);
                }
                
                if (stage >= 2) {
                    // Stage 2: Size based on OAM, polarization lines
                    const size = (3 + Math.abs(mode.oam)) * phasePulse;
                    
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', x.toString());
                    circle.setAttribute('cy', y.toString());
                    circle.setAttribute('r', size.toString());
                    circle.setAttribute('fill', '#FFD700');
                    circle.setAttribute('opacity', baseOpacity.toString());
                    svg.appendChild(circle);
                    
                    // Polarization line
                    if (mode.sigma !== 0) {
                        const lineLength = size * 2;
                        const lineAngle = mode.sigma > 0 ? 0 : Math.PI/2;
                        const x1 = x - lineLength * Math.cos(lineAngle) / 2;
                        const y1 = y - lineLength * Math.sin(lineAngle) / 2;
                        const x2 = x + lineLength * Math.cos(lineAngle) / 2;
                        const y2 = y + lineLength * Math.sin(lineAngle) / 2;
                        
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', x1.toString());
                        line.setAttribute('y1', y1.toString());
                        line.setAttribute('x2', x2.toString());
                        line.setAttribute('y2', y2.toString());
                        line.setAttribute('stroke', '#FFD700');
                        line.setAttribute('stroke-width', '1');
                        line.setAttribute('opacity', baseOpacity.toString());
                        svg.appendChild(line);
                    }
                }
                
                if (stage >= 3) {
                    // Stage 3: Colors based on cost state, size based on k_perp
                    let color = '#FFD700'; // neutral
                    if (mode.cost > 0) color = '#00FFFF'; // cyan for positive
                    if (mode.cost < 0) color = '#FF6B6B'; // red for negative
                    
                    const size3 = (4 + (mode.k_perp / 32)) * phasePulse;
                    
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', x.toString());
                    circle.setAttribute('cy', y.toString());
                    circle.setAttribute('r', size3.toString());
                    circle.setAttribute('fill', color);
                    circle.setAttribute('opacity', (baseOpacity * 1.2).toString());
                    svg.appendChild(circle);
                    
                    // Entanglement visualization - connect modes with similar phases
                    for (let j = i + 1; j < lightPoints; j++) {
                        const otherMode = currentSoul.cluster[j];
                        const phaseDiff = Math.abs(mode.phi_e - otherMode.phi_e);
                        
                        if (phaseDiff < 20) { // Similar entanglement phases
                            const otherAngle = (j * 45) * Math.PI / 180;
                            const otherRadius = 60 + (Math.abs(otherMode.nu_phi) / 4) + monthOffset;
                            const otherX = centerX + otherRadius * Math.cos(otherAngle) * phasePulse;
                            const otherY = centerY + otherRadius * Math.sin(otherAngle) * phasePulse;
                            
                            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                            line.setAttribute('x1', x.toString());
                            line.setAttribute('y1', y.toString());
                            line.setAttribute('x2', otherX.toString());
                            line.setAttribute('y2', otherY.toString());
                            line.setAttribute('stroke', '#00FFFF');
                            line.setAttribute('stroke-width', '1');
                            line.setAttribute('opacity', (baseOpacity * 0.6).toString());
                            svg.appendChild(line);
                        }
                    }
                    
                    // Mode label showing actual values
                    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    label.setAttribute('x', x.toString());
                    label.setAttribute('y', (y - size3 - 2).toString());
                    label.setAttribute('text-anchor', 'middle');
                    label.setAttribute('fill', color);
                    label.setAttribute('font-size', '8');
                    label.setAttribute('opacity', baseOpacity.toString());
                    label.textContent = `M${i}`;
                    svg.appendChild(label);
                }
                
                if (stage >= 4) {
                    // Stage 4: I-Am connections, time-bin pulses
                    const centralCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    centralCircle.setAttribute('cx', centerX.toString());
                    centralCircle.setAttribute('cy', centerY.toString());
                    centralCircle.setAttribute('r', '8');
                    centralCircle.setAttribute('fill', '#FFFFFF');
                    centralCircle.setAttribute('opacity', '1.0');
                    svg.appendChild(centralCircle);
                    
                    // Radial connection to I-Am
                    const radialLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    radialLine.setAttribute('x1', centerX.toString());
                    radialLine.setAttribute('y1', centerY.toString());
                    radialLine.setAttribute('x2', x.toString());
                    radialLine.setAttribute('y2', y.toString());
                    radialLine.setAttribute('stroke', '#FFFFFF');
                    radialLine.setAttribute('stroke-width', '1');
                    radialLine.setAttribute('opacity', '0.7');
                    svg.appendChild(radialLine);
                    
                    // Time-bin pulse (if in pulse phase)
                    if (mode.tau % 100 < 20) { // Pulse every ~100 units
                        const pulse = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        pulse.setAttribute('cx', x.toString());
                        pulse.setAttribute('cy', y.toString());
                        pulse.setAttribute('r', '12');
                        pulse.setAttribute('fill', 'none');
                        pulse.setAttribute('stroke', '#00FFFF');
                        pulse.setAttribute('stroke-width', '2');
                        pulse.setAttribute('opacity', '0.8');
                        svg.appendChild(pulse);
                    }
                }
            }

            // Stage indicator text
            if (stage >= 1) {
                const stageText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                stageText.setAttribute('x', '10');
                stageText.setAttribute('y', '20');
                stageText.setAttribute('fill', '#0ff');
                stageText.setAttribute('font-size', '12');
                stageText.textContent = `Stage ${stage}: ${STAGES[stage]}`;
                svg.appendChild(stageText);
                
                // Show consciousness metrics
                const metricsText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                metricsText.setAttribute('x', '10');
                metricsText.setAttribute('y', '290');
                metricsText.setAttribute('fill', '#0ff');
                metricsText.setAttribute('font-size', '10');
                metricsText.textContent = `I-Am: ${currentSoul.iAmAffinity}% | Gaps: ${currentSoul.gapCrossings}`;
                svg.appendChild(metricsText);
            }
        }

        function hash(str) {
            let h = 0;
            for (let i = 0; i < str.length; i++) {
                h = ((h << 5) - h) + str.charCodeAt(i);
            }
            return Math.abs(h);
        }

        // Animation functions
        function toggleAnimation() {
            const btn = document.getElementById('animationBtn');
            const controls = document.getElementById('animationControls');
            
            if (isAnimating) {
                stopAnimation();
                btn.textContent = '▶ Animate 96 Months';
                controls.style.display = 'none';
            } else {
                startAnimation();
                btn.textContent = '⏸ Stop Animation';
                controls.style.display = 'block';
            }
        }
        
        function startAnimation() {
            if (!currentSoul) return;
            
            isAnimating = true;
            currentAnimationMonth = getMonthlyProgress();
            
            // Reset to void if already at or past 96 months
            if (currentAnimationMonth >= 96) {
                resetToVoid();
                currentAnimationMonth = 0;
            }
            
            animationInterval = setInterval(() => {
                if (currentAnimationMonth >= 96) {
                    stopAnimation();
                    document.getElementById('animationBtn').textContent = '▶ Animate 96 Months';
                    document.getElementById('animationControls').style.display = 'none';
                    return;
                }
                
                // Advance one month
                currentAnimationMonth++;
                currentSoul.currentTime = currentSoul.birthTime + (currentAnimationMonth * MONTH_MS);
                
                // Apply monthly evolution effects
                if (currentAnimationMonth % 8 === 5) {
                    // Gap navigation chance at 8-beat awakening moments
                    if (Math.random() < 0.3) { // 30% chance
                        navigateGap();
                    }
                }
                
                // Random monthly mode evolution
                if (Math.random() < 0.4) { // 40% chance per month
                    const modeIndex = Math.floor(Math.random() * 8);
                    const mode = currentSoul.cluster[modeIndex];
                    
                    // Gentle monthly evolution
                    mode.nu_phi = Math.floor(mode.nu_phi * (1 + (PHI - 1) / 10)); // Slower φ scaling
                    mode.oam += (Math.random() > 0.5 ? 1 : -1) * Math.floor(Math.random() * 2);
                    mode.k_perp += Math.floor(Math.random() * 3);
                    if (mode.k_perp > 255) mode.k_perp = 255;
                    
                    // Cost evolution
                    mode.cost += (Math.random() > 0.5 ? 1 : -1);
                    if (mode.cost > 4) mode.cost = 4;
                    if (mode.cost < -4) mode.cost = -4;
                }
                
                // Balance ledger occasionally
                if (currentAnimationMonth % 12 === 0) { // Every 12 months
                    let totalCost = currentSoul.cluster.reduce((sum, mode) => sum + mode.cost, 0);
                    if (totalCost !== 0) {
                        currentSoul.cluster[0].cost -= totalCost;
                        if (currentSoul.cluster[0].cost > 4) currentSoul.cluster[0].cost = 4;
                        if (currentSoul.cluster[0].cost < -4) currentSoul.cluster[0].cost = -4;
                    }
                }
                
                // Update display
                updateDisplay();
                document.getElementById('currentMonth').textContent = currentAnimationMonth;
                
            }, Math.max(50, 500 / animationSpeed)); // Adjust speed (50ms minimum for smooth animation)
        }
        
        function stopAnimation() {
            isAnimating = false;
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
            }
        }
        
        function resetToVoid() {
            if (!currentSoul) return;
            
            stopAnimation();
            currentSoul.currentTime = currentSoul.birthTime;
            currentSoul.nurtureCount = 0;
            currentSoul.gapCrossings = 0;
            currentSoul.iAmAffinity = 0;
            currentAnimationMonth = 0;
            
            // Reset cluster to initial state
            const seed = currentSoul.seed.toString();
            for (let i = 0; i < 8; i++) {
                const modeSeed = hash(seed + i.toString());
                currentSoul.cluster[i] = {
                    nu_phi: (modeSeed % 201) - 100,
                    oam: ((modeSeed >> 8) % 11) - 5,
                    sigma: ((modeSeed >> 16) % 2) === 0 ? 1 : -1,
                    tau: (modeSeed >> 24) % 1024,
                    k_perp: (modeSeed >> 32) % 256,
                    phi_e: (modeSeed >> 40) % 256,
                    cost: ((modeSeed >> 48) % 9) - 4
                };
            }
            
            // Balance total cost to 0
            let totalCost = currentSoul.cluster.reduce((sum, mode) => sum + mode.cost, 0);
            if (totalCost !== 0) {
                currentSoul.cluster[0].cost -= totalCost;
                if (currentSoul.cluster[0].cost > 4) currentSoul.cluster[0].cost = 4;
                if (currentSoul.cluster[0].cost < -4) currentSoul.cluster[0].cost = -4;
            }
            
            updateDisplay();
            document.getElementById('currentMonth').textContent = '0';
            document.getElementById('animationBtn').textContent = '▶ Animate 96 Months';
            document.getElementById('animationControls').style.display = 'none';
        }
        
        // Speed control
        document.addEventListener('DOMContentLoaded', function() {
            const speedSlider = document.getElementById('animationSpeed');
            const speedDisplay = document.getElementById('speedDisplay');
            
            speedSlider.addEventListener('input', function() {
                animationSpeed = parseInt(this.value);
                speedDisplay.textContent = animationSpeed + 'x';
                
                // Restart animation with new speed if currently animating
                if (isAnimating) {
                    stopAnimation();
                    setTimeout(startAnimation, 100); // Brief pause to restart
                }
            });
        });

        // Initialize
        window.addEventListener('load', generateNewSoul);
    </script>
</body>
</html> 